\documentclass[
  12pt,
  a4paper,
  oneside,
  headsepline,
  DIV13,
  bibtotoc,
  twoside,
  BCOR15mm,
  liststotoc,
  cleardoubleplain]
{scrbook} %

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
\usepackage[latin1]{inputenc}
\usepackage[dvips]{color,graphicx}
%\usepackage[pdftex]{color,graphicx}
\usepackage[usenames,dvipsnames]{pstricks}
\usepackage{url}
\usepackage{rotating}
\usepackage{fancybox}
\usepackage{textcomp}
%% Mathe Packete
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{mathrsfs}
\usepackage{amsfonts}
\usepackage[all]{xy}
\DeclareMathAlphabet{\mathpzc}{OT1}{pzc}{m}{it}

\usepackage{hyperref}
\hypersetup{
    % bookmarks=false      % show bookmarks bar?
    , bookmarksopenlevel=2
    , unicode=false          % non-Latin characters in Acrobats bookmarks
    , pdftoolbar=true        % show Acrobats toolbar?
    , pdfmenubar=true        % show Acrobats menu?
    , pdffitwindow=true      % window fit to page when opened
    % , pdfstartview={FitH}  % fits the width of the page to the window
    , pdftitle={Automatische Pruefung und Berechnung von Ueberlappungen zum 
        Vollstaendigkeitsnachweis von Diagrammen in Programmiersprachen hoeherer Ordnung}
    , pdfsubject={Diplomarbeit},
    , pdfauthor={Conrad Rau} 
    , pdfcreator={Conrad Rau}
    , pdfproducer={Conrad Rau}
    % , pdfkeywords={keyword1} {key2} {key3} % list of keywords
    % , pdfnewwindow=true      % links in new window
    , colorlinks=true       % false: boxed links; true: colored links
    , linkcolor=blue        % color of internal links (change box color with linkbordercolor)
    , citecolor=green       % color of links to bibliography
    , filecolor=magenta     % color of file links
    , urlcolor=cyan         % color of external links
    % , pagecolor=blue
    % , menucolor=blue
    % , pdfborder={0 0 1}    % {RadiusH RadiusV Width [Dash-Pattern]}
    % , urlbordercolor={0 0 1} % RGB value of url border color
    , linkbordercolor={0.8 0.8 0.6}
    , urlbordercolor={0.8 0.8 0.6}  % Gray
    % , urlbordercolor={0.4 0.7 0.95}  % light Blue
    % , allbordercolors={0 0 1}
    , pdfborderstyle={/S/U/W 1}
  }
  
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\renewcommand{\textfraction}{0.05}
\renewcommand{\topfraction}{0.95}
\renewcommand{\bottomfraction}{0.95}
\renewcommand{\floatpagefraction}{0.35}
\setcounter{totalnumber}{5}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newcommand{\fdiagrammA}[4]{
$\xymatrix{%Vierecke
\cdot \ar@{->}[rr]^{#1} \ar@{->}[d]_{#2} & & \cdot \ar@{.>}[d]^{#3} \\
\cdot \ar@{.>}[rr]^{#4}                  & & \cdot
}$}
\newcommand{\fdiagrammB}[5]{
$\xymatrix{%Vierecke
\cdot \ar@{->}[rr]^{#1} \ar@{->}[d]_{#2} &                         & \cdot \ar@{.>}[d]^{#3} \\
\cdot \ar@{.>}[r]^{#4}                   & \cdot \ar@{.>}[r]^{#5}  & \cdot
}$}

\newcommand{\enolletin}{\emph{eno,llet-in}}
\newcommand{\islletin}{\emph{iS,llet-in}}
\newcommand{\enollete}{\emph{eno,llet-e}}
\newcommand{\isllete}{\emph{iS,llet-e}}
\newcommand{\enocpin}{\emph{eno,cp-in}}
\newcommand{\iscpin}{\emph{iS,cp-in}}
\newcommand{\enocpe}{\emph{eno,cp-e}}
\newcommand{\iscpe}{\emph{iS,cp-e}}
\newcommand{\enolbeta}{\emph{eno,lbeta}}
\newcommand{\islbeta}{\emph{iS,lbeta}}
\newcommand{\enolapp}{\emph{eno,lapp}}
\newcommand{\islapp}{\emph{iS,lapp}}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\usepackage{epsfig}
\usepackage{pst-grad} % For gradients
\usepackage{pst-plot} % For axes
\usepackage{stmaryrd}
%\usepackage{pst-pdf}

\usepackage{subfigure}
\usepackage{longtable}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Abstaende und Raender
%\renewcommand{\baselinestretch}{1.2} % Zeilenabstand
\setlength{\parindent}{0pt} % Einrücken nach Absatz
\setlength{\parskip}{6pt} % Abstand nach Abstz
%\setlength{\parskip}{0.3cm plus4mm minus3mm}
\setlength{\unitlength}{1mm} % Millimeter als Standart 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Bibliographie
\usepackage[hyper,nosectionbib]{myapacite}
\bibliographystyle{myapacite}
\setlength{\bibitemsep}{\baselineskip}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Captions
\usepackage{ccaption}
\captiondelim{. }

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Tabellen
\renewcommand {\arraystretch}{1.2} % Zeilenabstand in Tabellen 
\renewcommand{\arraycolsep}{0.08cm}
\renewcommand{\tabcolsep}{0.08cm}
\setlength{\doublerulesep}{.0pt} % Abstand zwischen zwei hlines; damit Tab. besser aussieht 
%% tabularx (Tabellen ueber ganze Seitenbreite)
\usepackage{tabularx}
\newcolumntype{C}{>{\centering\arraybackslash}X}
\newcolumntype{L}{>{\raggedleft\arraybackslash}X}
\newcolumntype{R}{>{\raggedright\arraybackslash}X}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Theoreme 
\newtheoremstyle{plainNoItalics}{}{}{\normalfont}{}{\bfseries}{.}{ }{}

% basic definitions, use roman font:
\theoremstyle{plainNoItalics}
\newtheorem{definition}{Definition}[section]
\newtheorem{satz}[definition]{Satz}
\newtheorem{lemma}[definition]{Lemma}
\newtheorem{proposition}[definition]{Proposition}
\newtheorem{notation}[definition]{Notation}
\newtheorem{beispiel}[definition]{Beispiel}
\newtheorem{bemerkung}[definition]{Bemerkung}
\newtheorem{korollar}[definition]{Korollar}

\newenvironment{beweis}
  {\emph{Beweis.}}
  {} %\hfill $\qed$

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Mengenklammern
\newcommand{\set}[1]{\{ #1 \}}
\newcommand{\setf}[1]{\{\!| #1 |\!\}}
% =? fuer Unifikationsgleichungen 
\newcommand{\ue}{=^{?}}
\newcommand{\wklammer}{{\color{white}{\{}}}
\newcommand{\terminates}{{\Downarrow}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Terme (letrec und case) mit letrec
% letrec in einer Zeile 
\newcommand{\letrec}[2]{{\upshape{(\texttt{letrec}}} #1
  {\upshape{\texttt{in}}} #2{\upshape{)}}}
% letrec in einer Zeile im Math-Modus
\newcommand{\letrecm}[2]{(\mathtt{letrec} \; \set{#1} \;
  \mathtt{in} \; #2)}
% letrec mit 'in' Teil in neuem Absatz 
\newcommand{\letrecs}[2]
{\begin{tabular}[t]{rl}
  {\upshape{(\texttt{letrec}}} & #1 \\
  {\upshape{\texttt{in}}}      & #2{\upshape{)}}
\end{tabular}}
% letrec mit 'in' Teil in neuem Absatz im Mathmodus
\newcommand{\letrecms}[2]
{\begin{array}[t]{rl}
  (\mathtt{letrec} & #1 \\
  \mathtt{in}      & #2)
\end{array}}
% letrec in drei Absaetzen 
\newcommand{\letrect}[3]
{\begin{tabular}[t]{rl}
  {\upshape{(\texttt{letrec}}} & #1 \\
                               & #2 \\
  {\upshape{\texttt{in}}}      & #3{\upshape{)}}
\end{tabular}}
%
\newcommand{\letrecmt}[3]
{\begin{array}[t]{rl}
  (\mathtt{letrec} & #1 \\
                   & #2 \\
  \texttt{in}      & #3)
\end{array}}

\newcommand{\case}[2]{{\upshape{(\texttt{case}}} #1 {\upshape{\texttt{of}}}
  #2{\upshape{)}}}
\newcommand{\caset}[3]{{\upshape{(\texttt{$\mathtt{case_{#3}}$}}} #1 {\upshape{\texttt{of}}}
  #2{\upshape{)}}}
\newcommand{\casetm}[3]{(\mathtt{case_{#3}} \; #1 \; \mathtt{of} \; #2)}
\newcommand{\casel}[5]
{\begin{array}[t]{rlr}
\mathtt{case_{#4}} & #1 \\
\mathtt{of}        & #2 \\
                   & #3)#5
\end{array}}

\newcommand{\seq}[2]{{\upshape{(\texttt{seq}}} #1 #2{\upshape{)}}}
\newcommand{\seqm}[2]{(\mathtt{seq} \; #1 \; #2)}

\newcommand{\lamb}[2]{{\upshape{(\texttt{$\lambda$}}}#1.#2{\upshape{)}}}
% Abstraktion im Mathmodus
\newcommand{\lambd}[2]{(\lambda #1.#2)}

% Loecher fuer Kontexte
\newcommand{\loch}{$[\cdot]$}
\newcommand{\lochm}{[\cdot]}

% Reduktionregeln 
\newcommand{\lletin}{\emph{llet-in }}
\newcommand{\llete}{\emph{llet-e}}
\newcommand{\llet}{\emph{llet}}
\newcommand{\llllet}{\emph{lll}}
\newcommand{\casec}{\emph{case-c}}
\newcommand{\casein}{\emph{case-in}}
\newcommand{\casee}{\emph{case-e}}
\newcommand{\redcase}{\emph{case}}
\newcommand{\seqc}{\emph{seq-c}}
\newcommand{\seqin}{\emph{seq-in}}
\newcommand{\seqe}{\emph{seq-e}}
\newcommand{\redseq}{\emph{seq}}
\newcommand{\lcase}{\emph{lcase}}
\newcommand{\lapp}{\emph{lapp}}
\newcommand{\lseq}{\emph{lseq}}
\newcommand{\lbeta}{\emph{lbeta}}
\newcommand{\cpin}{\emph{cp-in}}
\newcommand{\cpe}{\emph{cp-e}}
\newcommand{\cp}{\emph{cp}}
\newcommand{\choicer}{\emph{choice-r}}
\newcommand{\choicel}{\emph{choice-l}}
\newcommand{\choice}{\emph{choice}}
% letrec in tt gesetzt
\newcommand{\letr}{\texttt{letrec}}

\newcommand{\xkette}[1]{x_1 = #1, \set{x_i = x_{i-1}}^n_{i=2}}
\newcommand{\chain}[3]{CH_{#1}(#2,#3)}
% Bindungen: b(x_i)
\newcommand{\bin}[2]{b(#1_{#2})}
% fuer Vmv-Ketten Bindungen 
\newcommand{\bi}[2]{#1_{#2}=#1_{#2-1}}
\newcommand{\aue}[2]{\ar@{-}[#1]|{#2}}
\newcommand{\nodeftab}[5]{\begin{tabular}{p{#1\textwidth}l}
    #3 & #4 #5 \end{tabular}}

\newcommand{\tesx}{T(\Sigma,S,X)}
\newcommand{\ssig}{S_{\Sigma}}
\newcommand{\ssigf}[1]{S_{\Sigma}(#1)}
\newcommand{\ls}[1]{LS_{\Sigma}(#1)}

% Ubersetzung \Lambd^{let} -> T(\Sigma^{let},X)
\newcommand{\transl}[1]{\llbracket #1 \rrbracket}

% Sigma,E Gleichung 
%\newcommand{\gee}{=_{\Sigma,E}}
\newcommand{\gee}{=_{\mathpzc{E}}}
\newcommand{\gE}{=_{\mathcal{E}}}
% Simga,E Gleichheit
\newcommand{\uee}{=_{\Sigma,E}^?}
\newcommand{\uE}{=_{\mathcal{E}}^?}
% Instantiierungs Quasiordnung, Simga,E
\newcommand{\iqse}{\lesssim_{\mathpzc{E}}}
\newcommand{\eqse}{\sim_{\mathpzc{E}}}

\newcommand{\eletcl}{$\mathpzc{E}^{let}_{Cl}$ }
\newcommand{\eletcln}{$\mathpzc{E}^{let}_{Cl}$}
\newcommand{\eletac}{$\mathpzc{E}^{let}_{AC}$ }

\DeclareMathOperator{\Var}{\emph{Var}}
\DeclareMathOperator{\Dom}{\emph{Dom}}
\DeclareMathOperator{\Ran}{\emph{Ran}}
\DeclareMathOperator{\VRan}{\emph{VRan}}
\DeclareMathOperator{\Top}{\emph{TOP}}
\DeclareMathOperator{\Pos}{\emph{Pos}}
\DeclareMathOperator{\Sub}{\emph{Sub}}
\DeclareMathOperator{\CX}{\emph{CX}}
\DeclareMathOperator{\Unify}{\emph{Unify}}

\newcommand{\todo}[1]{{\color{red}{#1}}}

% undertilde fuer Quasiordnung
\def\undertilde#1{\mathord{\vtop{\ialign{##\crcr
$\hfil\displaystyle{#1}\hfil$\crcr\noalign{\kern1.5pt\nointerlineskip}
$\hfil\tilde{}\hfil$\crcr\noalign{\kern1.5pt}}}}}
\newcommand{\sseq}{\;\undertilde{\sqsubset}\;}
\newcommand{\sigmaLet}{\Sigma^{let}}%_{\setf{\cdot|\cdot}}}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% lhs2tex
\usepackage{amstext}
\DeclareFontFamily{OT1}{cmtex}{}
\DeclareFontShape{OT1}{cmtex}{m}{n}
  {<5><6><7><8>cmtex8
   <9>cmtex9
   <10><10.95><12><14.4><17.28><20.74><24.88>cmtex10}{}
\DeclareFontShape{OT1}{cmtex}{m}{it}
  {<-> ssub * cmtt/m/it}{}
\newcommand{\texfamily}{\fontfamily{cmtex}\selectfont}
\DeclareFontShape{OT1}{cmtt}{bx}{n}
  {<5><6><7><8>cmtt8
   <9>cmbtt9
   <10><10.95><12><14.4><17.28><20.74><24.88>cmbtt10}{}
\DeclareFontShape{OT1}{cmtex}{bx}{n}
  {<-> ssub * cmtt/bx/n}{}
\newcommand{\tex}[1]{\text{\texfamily#1}}	% NEU

\newcommand{\Sp}{\hskip.33334em\relax}

\newlength{\lwidth}\setlength{\lwidth}{4.5cm}
\newlength{\cwidth}\setlength{\cwidth}{8mm} % 3mm

\newcommand{\Conid}[1]{\mathit{#1}}
\newcommand{\Varid}[1]{\mathit{#1}}
\newcommand{\anonymous}{\kern0.06em \vbox{\hrule\@width.5em}}
\newcommand{\plus}{\mathbin{+\!\!\!+}}
\newcommand{\bind}{\mathbin{>\!\!\!>\mkern-6.7mu=}}
\newcommand{\sequ}{\mathbin{>\!\!\!>}}
%\renewcommand{\leq}{\leqslant}
%\renewcommand{\geq}{\geqslant}
\newcommand{\NB}{\textbf{NB}}
\newcommand{\Todo}[1]{$\langle$\textbf{To do:}~#1$\rangle$}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Silbentrennung
\hyphenation{Uni-fi-ka-ti-on Uni-fi-ka-ti-ons-pro-blem Uni-fi-ka-ti-ons-pro-blems}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Titel
\title{Automatische Prüfung und Berechnung von Überlappungen zum 
  Vollständigkeitsnachweis von Diagrammen in Programmiersprachen höherer Ordnung}
\author{Conrad Rau}
\date{06. März 2009}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%
%% Document
%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}
\frontmatter
\titlehead{ 
\begin{flushright}
{\Large Johann Wolfgang Goethe-Universit\"at \\[0.3cm]
Frankfurt am Main}
%\line(1,0){\textwidth} 
\\
\hrulefill 
\end{flushright}
Fachbereich Informatik und Mathematik \\
Institut für Informatik }
\subject{\sffamily Diplomarbeit}
\title{Automatische Prüfung und Berechnung von Überlappungen zum 
Vollständigkeitsnachweis von Diagrammen in Programmiersprachen höherer Ordnung}
\author{\bf \sffamily Conrad Rau}
\date{\sffamily 06. März 2009}
\publishers{eingereicht bei \\
Prof. Dr. Manfred Schmidt-Schauß \\
Künstliche Intelligenz und Softwaretechnologie}
\maketitle

\thispagestyle{empty}
\subsection*{Danksagung}
Ich möchte mich hiermit bei allen bedanken, die mich während der
Entstehung dieser Arbeit begleitet und unterstützt haben. 

Mein besonderer Dank gilt meinem Betreuer, Herrn Prof. Dr. Manfred
Schmidt-Schauß und seinem Mitarbeiter Dr. David Sabel für Ihre
hervorragende Betreuung und Ihre zahlreichen hilfreichen Anregungen. 

Auch danken möchte ich auf diesem Wege ganz besonders meinen Eltern,
die mir dieses Studium ermöglicht haben, meiner Freundin Rebecca, die
immer ein offenes Ohr für meine Sorgen im Zusammenhang mit der
Diplomarbeit hatte, und mir geholfen hat, diese zu meistern, meinem
Bruder Philip, der meine Arbeit korrigiert und mir hilfreiche Tipps
bezüglich verschiedener Formulierungen gegeben hat, Sieglinde Braun,
die meine Arbeit Korrektur gelesen hat, sowie Florian Dörfler, der
mich bei der Erstellung einer Webseite, zur Veröffentlichung des im
Rahmen dieser Arbeit entstandenen Programms, unterstützt hat. 
\\[3.5cm] Conrad Rau
\cleardoubleemptypage
\thispagestyle{empty}
\subsection*{Erklärung gemäß DPO \S11 Abs. 11}
Hiermit bestätige ich, dass ich die vorliegende Arbeit selbständig verfasst habe und
keine anderen Quellen oder Hilfsmittel als die in dieser Arbeit angegebenen verwendet
habe.\\[3.5cm] Conrad Rau, Oberursel den 06. März 2009
\cleardoubleemptypage
%\pagenumbering{roman}
\tableofcontents

\mainmatter
\chapter{Einleitung}
\section{Motivation und Zielsetzung}
Funktionale Programmiersprachen weisen eine Reihe von Eigenschaften
auf, die zur modernen Softwareentwicklung benötigt werden:
Zuverlässigkeit, Modularisierung, Wiederverwendbarkeit und
Verifizierbarkeit. 

Als Basis der Semantik von funktionalen Programmiersprachen dient der 
$\lambda$-Kalkül \cite{barendregt_lambda_1984}. Er besteht aus einer
Sprache, den so genannten $\lambda$-Ausdrücken und aus Regeln, die
angeben, wie $\lambda$-Ausdrücke transformiert werden können. 
%Diese Reduktionsregeln beschreiben die schrittweise Auswertung von
%Ausdrücken zu Werten. 
Die Folge einer Anwendung von Reduktionsregeln auf einen Ausdruck
wird als Reduktion oder Auswertung des Ausdrucks bezeichnet. Endet
eine Folge von Reduktionen mit einem Ausdruck, auf den keine
Reduktionsregel mehr anwendbar ist, und besitzt dieser Ausdruck eine
bestimmte festgelegte Form, dann sagt man die Auswertung terminiert. 
Der resultierende Ausdruck wird als Wert bezeichnet. 

Funktionale Programme, deren Semantik auf dem $\lambda$-Kalkül
basiert, können als $\lambda$-Ausdrücke betrachtet werden. 
Die Art und Weise wie der 
Wert eines funktionalen Programmes berechnet wird, ist dann durch die
Reduktionsregeln des $\lambda$-Kalküls bestimmt. Man bezeichnet
den $\lambda$-Kalkül in diesem Fall als die Kernsprache der
funktionalen Programmiersprache. 

Es existieren eine Vielzahl verschiedener Varianten von
$\lambda$-Kalkülen, die sich in ihrem Sprachumfang, ihren
Reduktionsregeln und ihren Auswertungsstrategien unterscheiden. 
Eine Klasse von Varianten des $\lambda$-Kalküls, die eine besondere
Relevanz als semantische Grundlage für funktionale
Programmiersprachen besitzt, sind die so genannten
Lazy-$\lambda$-Kalküle, die auch $\lambda$-Kalküle mit Sharing oder
$\lambda$-Kalküle mit \letr-Konstrukt genannt werden 
\cite{abramsky_lazy_1990,ariola_call-by-need_1997,schmidt-schauss_fundio:lambda-calculus_2003}. 
Sie verfügen über Sprachkonstrukte und entsprechende
Reduktionsregeln, die eine effiziente Auswertung von Ausdrücken durch
die geteilte Nutzung gemeinsamer Unterausdrücke erlaubt. 

Die Methode, die Semantik einer funktionalen Programmiersprache auf
einer Variante des $\lambda$-Kalküls aufzubauen, hat den Vorteil,
dass der zugrundeliegende Kalkül verwendet werden kann, um Aussagen
darüber zu treffen, wann ein Berechnungsschritt 
bei der Auswertung eines funktionalen Programms als korrekt zu
bezeichnen ist. Als theoretische 
Basis für solche Korrektheitsaussagen dient das Konzept der Gleichheit
von Ausdrücken.
Der Begriff der Gleichheit von Ausdrücken ist als
Verhaltensgleichheit von Ausdrücken definiert: Zwei Ausdrücke $s$
und $t$ sind gleich, wenn in einem beliebigen Programm der Ausdruck
$s$ durch den Ausdruck $t$ ersetzt werden kann, ohne dass sich etwas
am Terminierungsverhalten des Programms ändert. 
In $\lambda$-Kalkülen bezeichnet man das umschließende Programm als
Kontext und die Gleichheitsrelation auf Ausdrücken als kontextuelle
Äquivalenz. Die Gleichheitsrelation kann man auch folgenderma"sen
interpretieren: 
\begin{quote}
Ausdrücke sind gleich, wenn man sie mit keinem Experiment
unterscheiden kann \cite{Schmidt-Schauss-Skript-05}. 
\end{quote}
Das Experiment besteht aus der Einsetzung in einen Kontext (für alle
möglichen Kontexte) und der anschließenden Beobachtung des
Terminierungsverhaltens, des durch die Einsetzung entstandenen
Programms. 

Die so definierte Gleichheitsrelation ist eine Äquivalenzrelation auf
Ausdrücken, die verwendet wird um die Korrektheit von
Programmtransformationen zu definieren. Durch
Programmtransformationen können Ausdrücke zu anderen 
Ausdrücken umgeformt werden. 
Für eine korrekte Programmtransformation gilt, dass der Ausdruck, auf
den die Transformation angewendet wird, kontextuell
äquivalent ist zu dem Ausdruck, der aus der Anwendung der
Transformation resultiert. D.h. ein Ausdruck, der durch eine 
korrekte Programmtransformation umgeformt wird, weist vor und nach der
Transformation das gleiche Terminierungsverhalten unter Einsetzung in
einen beliebigen Kontext auf. 

Die Reduktionsregeln eines $\lambda$-Kalküls sind
Programmtransformationen. 
Durch den Begriff der Korrektheit von Programmtransformationen hat man
eine Methode, um für eine funktionale Programmiersprache, deren
Semantik auf einem $\lambda$-Kalkül basiert, Aussagen über die
Korrektheit von Berechungsschritten in der funktionalen
Programmiersprache zu machen. 
Eine andere wichtige Anwendung des Konzepts der Korrektheit von
Programmtransformationen liegt im Bereich der Optimierung. 
Ein ineffizientes Unterprogramm 
%(d.h. ein Ausdruck) 
wird durch eine
Transformation zu einem effizienten Unterprogramm umgeformt. 
Wenn diese Transformation korrekt ist, dann wird durch die
kontextuelle Äquivalenz der beiden Unterprogramme sichergestellt, dass
in einem Programm 
%(d.h. einem Kontext) 
das ineffiziente Unterprogramm an
jeder Stelle durch seine transformierte, effiziente Variante ersetzt
werden kann.

Um die Korrektheit einer Programmtransformation, die einen Ausdruck
$s$ zu einem Ausdruck $t$ umformt, zu beweisen, muss gezeigt werden, dass
$s$ und $t$ kontextuell 
äquivalent sind. Dazu muss das Terminierungsverhalten von $s$
eingesetzt in einen beliebigen Kontext $C$ (geschrieben als $C[s]$)
verglichen werden mit dem Terminierungsverhalten von $t$ eingesetzt in
den gleichen Kontext $C$. 
Dies kann man zeigen, indem man annimmt, dass
$C[s]$ ein Programm repräsentiert, das terminiert. D.h. es gibt für
$C[s]$ eine Folge von Reduktionen, so dass die Auswertung mit
einem Wert anhält. Nun versucht man, induktiv über die Anzahl der
Reduktionsschritte eine Folge von Reduktionen zu konstruieren,
so dass das Programm $C[t]$ unter dieser Folge 
terminiert. F\"ur den vollst\"andigen Beweis der kontextuellen Äquivalenz von
$s$ und $t$, muss noch analog gezeigt werden: Wenn $C[t]$
ein terminierendes Programm darstellt, dann ist auch $C[s]$ ein
terminierendes Programm. 
Die Konstruktion einer terminierenden Folge von Reduktionen 
während der Induktion geschieht unter der Verwendung von Diagrammen. 
Für die beiden Schritte im Korrektheitsbeweis\footnote{Die Terminierung von
  $C[s]$ impliziert die Terminierung von 
  $C[t]$ und die Terminierung von $C[t]$ impliziert die Terminierung
  von $C[s]$.} 
werden verschiedene Arten von Diagrammen benötigt.  
Damit die Diagramme im Beweis verwendbar sind, muss außerdem ein
bestimmtes Vollständigkeits-Kriterium erfüllt sein: Es wird eine Menge
von Diagrammen benötigt, die alle Möglichkeiten der
Konstruktion von terminierenden Reduktionsfolgen abdeckt. 
Die Erstellung vollständiger Mengen von Diagrammen erfolgt in den
Arbeiten, die Korrektheit von Programmtransformationen in $\lambda$-Kalkuli mit
Sharing untersuchen von Hand 
\cite{kutzner_ein_2000,schmidt-schauss_fundio:lambda-calculus_2003,sabel_realisierung_2003,schmidt-schauss_safety_2007,sabel_semantics_2008}.
Dieses Vorgehen ist umständlich,
fehleranfällig und variiert stark im Grade der Ausführlichkeit zwischen
den einzelnen Arbeiten. 

\citeA{Huber2000} stellt in seiner Diplomarbeit ein Programm vor,
das f\"ur eine gegebene Menge von Diagrammen anhand von Beispielausdrücken
testet, ob die Menge der Diagramme die geforderte
Vollständigkeits-Bedingung erfüllt.
Dieses Vorgehen kann durch die geschickte Erzeugung von Ausdrücken
feststellen, ob in einer Menge von Diagrammen, eines
enthalten ist, das für die zu testenden Ausdrücke anwendbar ist. 
Die Vollständigkeit einer Menge von Diagrammen kann mit dieser
Methode nicht gezeigt werden. 

In dieser Arbeit wird ein einfacher $\lambda$-Kalkül mit einem
\letr-Konstrukt betrachtet, der so genannte
$\Lambda^{let}$-Kalkül. Das Ziel, ist für diesen Kalkül eine 
Methode zu entwickeln, mit der eine vollständige Menge von Diagrammen
berechnet werden kann, die bei den Korrektheitsbeweisen von
Programmtransformationen im $\Lambda^{let}$-Kalkül verwendet werden. 
%Dabei beschränken wir uns auf die Berechnung einer vollständigen
%Menge von Diagrammen die für den Schritt: 
%Die Terminierung von $C[s]$ impliziert die Terminierung von $C[t]$ des
%Korrektheistbeweises von 

\section{\"Uberblick}
Im Folgenden geben wir einen Überblick über die weiteren Kapitel.

In Kapitel \ref{cha:der-lambdalet-kalkul} wird der $\Lambda^{let}$-Kalkül definiert. 
Der Kalkül stellt eine Teilmenge des $LR$-Kalküls aus
\citeA{schmidt-schauss_safety_2007} dar. 
Es werden die zentralen
Konzepte der Reduktion, eine standardisierte Form der Auswertung und
der Begriff der kontextuellen Äquivalenz aus
\citeA{schmidt-schauss_safety_2007} angegeben. 
Anschließend wird beschrieben, wann Programmtransformationen als korrekt
bezeichnet werden, und welche Hilfsmittel für den Beweis der
Korrektheit von Programmtransformationen verwendet werden.
Diese sind das Kontextlemma und vollständige Sätze von Gabel- und
Vertauschungsdiagrammen.  
Das Kapitel endet mit einer Skizzierung der Methode zur
Berechnung eines vollständigen Satzes von Gabeldiagrammen. 
Die Methode basiert auf der Berechnung von Überlappungen von
Reduktionsregeln. Dazu müssen Reduktionsregeln des
$\Lambda^{let}$-Kalküls unifiziert werden. 
%Die Probleme, die sich für die Unifikation ergeben werden kurz angesprochen. 
 
Die folgenden vier Kapitel beschäftigen sich mit den
Unifikationsmethoden, die zur Unifikation von verschiedenen  
Konstrukten, die in $\Lambda^{let}$-Reduktionsregeln enthalten sind,
ben\"otigt werden. Die Objekte auf denen
$\Lambda^{let}$-Reduktionsregeln operieren, werden als Ausdrücke
bezeichnet. 
In der Literatur wird die Theorie der Unifikation
\cite{baader_unification_2001} allerdings im Rahmen von Termen
und nicht bezüglich Ausdrücken behandelt. In den Kapiteln 
\ref{cha:unif-fur-terme-mit-sorten}, \ref{cha:ac-unifikation},
\ref{cha:unif-von-ketten} und \ref{cha:unif-von-kontexten}
wird deshalb eine Signatur $\sigmaLet$
definiert, mit deren Hilfe Konstrukte, die in
$\Lambda^{let}$-Reduktionsregeln vorkommen, als Terme über der
Signatur $\sigmaLet$ dargestellt und unifiziert werden können. 

Die Reduktionsregeln in $\Lambda^{let}$ enthalten Variablen
verschiedener Sorten. In Kapitel \ref{cha:unif-fur-terme-mit-sorten}
werden Terme mit Sorten definiert 
%und die Signatur $\sigmaLet$ eingeführt, über der Terme erster Ordnung 
und das Verfahren 
zur Unifikation von Termen mit Sorten beschrieben. 

Kapitel \ref{cha:ac-unifikation} befasst sich mit der Unifikation von
Funktionssymbolen, deren Argumente vertauschbar sind. 
Diese Unifikationsmethode wird benötigt, da die Elemente von
\letr-Umgebungen in $\Lambda^{let}$ vertauschbar sind und diese
Vertauschbarkeit bei der Unifikation berücksichtigt werden muss. 

\letr-Umgebungen in $\Lambda^{let}$-Reduktionsregeln enthalten in
manchen Fällen ein Konstrukt, um Variablenketten beliebiger Länge
darzustellen. Die Methoden, die zur Unifikation von Variablenketten verwendet werden,
sind in Kapitel \ref{cha:unif-von-ketten} beschrieben.  

Als letztes Konstrukt, das es bei der Unifikation zu berücksichtigen
gilt, enthalten $\Lambda^{let}$-Reduktionsregeln Kontextvariablen mit
Sorten. Deren Unifikation erfolgt wie in 
Kapitel \ref{cha:unif-von-kontexten} dargelegt. 

In Kapitel \ref{cha:berechn-von-uberl} wird der Begriff der Überlappung von Reduktionsregeln
formal definiert. Dazu geben wir zuerst die Definition der Signatur
$\sigmaLet$, die zur Darstellung und Unifikation von
$\Lambda^{let}$-Reduktionsregeln verwendet wird, zusammenfassend an. 
Dann werden Reduktionsregeln für Terme über dieser
Signatur und eine standardisierte Form der Auswertung, analog zu den
entsprechenden Definitionen des $\Lambda^{let}$-Kalküls, definiert. 
Die in $\sigmaLet$ definierte Normalordnungsreduktion stellt eine
Einschr\"ankung der Normalordnungsreduktion aus $\Lambda^{let}$ dar.
Abschließend beschreiben wir, wie alle Überlappungen für einen 
vollständigen Satz von Gabeldiagrammen berechnet werden können. 

Das Kapitel \ref{cha:impl-und-ergebn} befasst sich mit
der Implementierung, die im Rahmen dieser Arbeit entstanden ist. 
Sie berechnet vollständige Sätze von Gabeldiagrammen. 
Wir skizzieren einige Datenstrukturen des Programms und geben 
Beispiele für die Arbeitsweise der wichtigsten Funktionen.
Anschließend geben wir die vollständigen Sätze von Gabeldiagrammen
an, die das Programm berechnet. 

Eine Zusammenfassung der Arbeit sowie ein
Ausblick auf mögliche weitere Untersuchungen bezüglich des in der
Arbeit behandelten Themas wird in Kapitel \ref{cha:zusamm-und-ausbl} gegeben.

\chapter{Der $\Lambda^{let}$-Kalkül}
\label{cha:der-lambdalet-kalkul}
Der $\Lambda^{let}$-Kalkül ist ein Lambda-Kalkül, erweitert um ein
\letr-Konstrukt. Der Kalkül ist eine Teilmenge des $LR$-Kalküls aus 
\cite{schmidt-schauss_safety_2007} und besteht aus der Sprache
$L_{\Lambda^{let}}$, \emph{Reduktionsregeln} zur Transformation von
Ausdrücken der Sprache und einer standardisierten Form der
Auswertung, der so genannten \emph{Normalordnung}. 
Im vorliegenden Kapitel werden diese Begriffe analog zu
\cite{schmidt-schauss_safety_2007} definiert. 
Ebenfalls auf diesem Artikel basierend, wird das
zentrale Konzept der \emph{kontextuellen Äquivalenz} von Ausdrücken
definiert und davon ausgehend wird festgelegt, wann Transformationen
von Ausdrücken (so genannte \emph{Programmtransformationen}) als
\emph{korrekt} bezeichnet werden. 
Als wesentliche Hilfsmittel, um die Korrektheit von
Programmtransformationen zu zeigen, dienen das \emph{Kontextlemma} und 
vollständige Sätze von \emph{Gabel- und Vertauschungsdiagrammen}. 
Abschließend wird informell besprochen, wie die Berechnung aller
Überlappungen für Gabeldiagramme möglich ist. 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Syntax}
\label{sec:syntax}

\begin{definition}%[$\Lambda_{let}$] 
\label{def:syntax}
%In Abbildung \ref{fig-syntax} ist die Syntax für Ausdrücke $E$ in der
%Sprache LRA zu sehen. 
Sei $X$ eine abzählbar unendliche Menge von Variablen. 
Die Syntax der Sprache $L_{\Lambda^{let}}$ wird durch die Grammatik in
Abbildung \ref{fig-syntax} definiert. 

\begin{figure}[h!t]
\center
\framebox{
\begin{tabular}{lclr}
E & ::= & V & (Variable) \\ 
% &$|$ & $(c \; E_1 \dots E_{ar(c)})$ & (Konstruktoranwendung) \\
% &$|$ & $\casetm{E}{Alt_1 \dots Alt_{|T|}}{T}$ & ({\upshape\texttt{case}}-Ausdruck)\\
 &$|$ & $(\lambda V.E)$ & (Abstraktion) \\
 &$|$ & $(E_1 \; E_2)$ & (Applikation)\\
 &$|$ & $\letrecm{V_1 = E_1, \dots, V_n = E_n}{E}$ & ({\upshape\texttt{letrec}}-Ausdruck)\\
% &$|$ & $\seqm{E_1}{E_2}$ & ({\upshape\texttt{seq}}-Ausdruck)\\
% &$|$ & $(E_1 \oplus E_2)$ & ({\upshape\texttt{choice}}-Ausdruck)\\
%Alt & ::= & $(Pat \rightarrow E)$ & (Alternative)\\
%Pat & ::= & $(c \; V_1 \dots V_{ar(c)})$ & (Pattern) \\
\end{tabular}}
\caption{Syntax der Sprache $L_{\Lambda^{let}}$\label{fig-syntax}}
\end{figure}
Die Nichtterminale $V, V_i$ erzeugen Variablen $x,y,z, \dots$ aus der
Menge der Variablen $X$. 
Die Nichtterminale $E, E_i$ erzeugen Ausdrücke. 
%Folgende Bedingungen gelten für Ausdrücke in $\Lambda^{let}$:
Für den \letr-Ausdruck gelten folgende Bedingungen:
\begin{itemize}
\item 
Die Variablen $V_i$ sind paarweise verschiedene Variablen. 
\item 
Die Bindungen in \letr-Ausdrücken sind kommutativ (d.h. vertauschbar). 
D.h. zwei \letr-Ausdrücke, die sich lediglich in der Reihenfolge der
Bindungen unterscheiden, sind syntaktisch äquivalent. 
\item \sloppy
Das \letr-Konstrukt ist rekursiv, d.h. im Ausdruck 
$\letrecm{x_1 = E_1, \dots, x_n = E_n}{E}$
sind die Variablen $x_1, \dots, x_n$ in $E_1 \dots, E_n, E$ gebunden. 
%@FRAGE: Was bedeutet der Satz (S.8): This fixes the notion of ..
\end{itemize}
\end{definition}
\sloppy
Mit $x,x_1,\dots, y,z$ bezeichnen wir Variablen aus der Menge
$X$. Beliebige Ausdrücke werden durch 
$s,s_1, \dots, t,u$ bezeichnet. 
Die einzelnen Elemente $x_i = s_i$ eines \letr-Ausdrucks nennen wir
\letr-\emph{Bindungen} und die Menge aller \letr-Bindungen eines
\letr-Ausdruckes \letr-\emph{Umgebung}. Für einen \letr-Ausdruck 
$\letrecm{x_1=s_1, \dots, x_n = t_n}{t}$ schreiben wir auch
$\letrecm{Env}{t}$, wobei $Env$ syntaktisch äquivalent ist zu
$x_1=t_1, \dots, x_n=t_n$.
Die Notation 
$\set{x_{g(i)} = s_{h(i)}}^n_{i=m}$ wird verwendet für die Folge von
\letr-Bindungen $x_{g(m)} = s_{h(m)},x_{g(m+1)} = s_{h(m+1)},\dots,x_{g(n)}
= s_{h(n)}$, mit $g,h: \mathbb{N} \rightarrow \mathbb{N}$. Eine solche
Folge von Bindungen wird Kette genannt. 
Die Bindung $x_{g(m)}=s_{h(m)}$ wird als Anfangsbindung, die Bindung 
$x_{g(n)}=s_{h(n)}$ als Endbindung der Kette bezeichnet. 
D.h. $\set{x_{i} = s_{i-1}}^n_{i=m}$ steht für die Kette 
$x_{m} = s_{m-1},x_{m+1}=s_{m},\dots,x_n=s_{n-1}$ 
mit Anfangsbindung $x_m=s_{m-1}$ und Endbindung $x_n=s_{n-1}$.

Freie und gebundene Variablen von Ausdrücken werden auf die übliche
Art und Weise definiert (siehe beispielsweise \citeA{sabel_realisierung_2003}).
Abstraktionen und \letr-Ausdrücke binden Variablen. 
Um bei der Reduktion von Ausdrücken das ungewollte Einführen von
freien Variablen in Bindungsbereiche zu vermeiden, wird für Ausdrücke
angenommen, dass 
%(sie der Barendregthschen Variablennamen-Konvention genügen.)
alle gebundenen Variablen verschiedene Namen besitzen, die sich von den 
Namen der freien Variablen eines Ausdrucks unterscheiden. 
Reduktionen führen bei Bedarf eine Umbenennung gebundener Variablen
durch (was nur notwendig ist für die Kopier-Regel (\emph{cp}), siehe
Definition \ref{def:reduktionen}). 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Kontexte}
\label{sec:kontexte}
%Durch die Verwendung von \emph{Kontexten}, ergibt sich die Möglichkeit
%jeden Ausdruck der Sprache $\Lambda^{let}$ in einen übergeordneten Teil, den Kontext, 
%und einen untergeordneten Teil, einen Subterm, zu zerlegen. Der Subterm
%befindet sich an einer spezifischen Stelle im Kontext.

Kontexte sind Ausdrücke, die an einer bestimmten Stelle ein Loch $\lochm$ 
enthalten. Es werden verschiedene Klassen von Kontexten definiert, die
sich dadurch unterscheiden, an welchen Positionen ein Loch zulässig
ist. 

%[Kontext]
\begin{definition}%[Allgemeiner Kontext]
\label{def:allg-kontext}
Die Klasse $\mathcal{C}$ der \emph{allgemeinen Kontexte} ist durch
folgende Grammatik definiert:

\begin{tabular}{lcl}
$\mathcal{C}$ & ::= & $\lochm$ \\
% &$|$ & $(c \; E_1 \dots E_{i-1} \; \mathcal{C} \; E_{i+1} \dots E_{ar(c)})$ \\
% &$|$ & $\casetm{\mathcal{C}}{Alts}{T}$ $|$ $\casetm{E}{Alt_1 \dots (Pat \rightarrow \mathcal{C}) \dots Alt_{|T|}}{T}$ \\
 &$|$ & $(\lambda x.\mathcal{C})$ \\
 &$|$ & $(\mathcal{C} \; E)$ $|$ $(E \; \mathcal{C})$ \\
 &$|$ & $\letrecm{x_1 = E_1, \dots, x_n = E_n}{\mathcal{C}}$ \\
 &$|$ & $\letrecm{x_1 = E_1, \dots, x_{i-1}=E_{i-1}, x_i=\mathcal{C},x_{i+1}=E_{i+1}, \dots, x_n = E_n}{E}$ \\
% &$|$ & $\seqm{\mathcal{C}}{E}$ $|$ $\seqm{E}{\mathcal{C}}$ \\
% &$|$ & $(\mathcal{C} \oplus E)$ $|$ $(E \oplus \mathcal{C})$ \\
\end{tabular}
\end{definition}

Für Kontexte aus der Klasse der allgemeinen Kontexte verwenden wir
die Buchstaben $C,D$. In einem allgemeinen Kontext darf das Loch an
einer beliebigen Position in einem Ausdruck stehen, abgesehen von
Positionen, an denen nur Variablen erlaubt sind (beispielsweise ist
$\lambda \lochm. t$ kein allgemeiner Kontext). 
Sei $C$ ein Kontext 
%aus der Klasse der allgemeinen Kontexte 
und $t$ ein Ausdruck, dann ist $C[t]$ der Ausdruck, der sich ergibt,
wenn das Loch in $C$ durch $t$ ersetzt wird.  

Wir definieren die Klasse der Oberflächenkontexte, die eine
Einschränkung der Klasse der allgemeinen Kontexte darstellt: In einem
Oberflächenkontext darf das Loch nicht im Rumpf einer Abstraktion
vorkommen.  
\begin{definition}%[Oberflächenkontext]
\label{def:oberflaechenkontext}
Die Klasse $\mathcal{S}$ der \emph{Oberflächenkontexte} ist durch
folgende Grammatik definiert:

\begin{tabular}{lcl}
$\mathcal{S}$ & ::= & $\lochm$ \\
% &$|$ & $(c \; E_1 \dots E_{i-1} \; \mathcal{S} \; E_{i+1} \dots E_{ar(c)})$ \\
% &$|$ & $\casetm{\mathcal{S}}{Alts}{T}$ $|$ $\casetm{E}{Alt_1 \dots (Pat \rightarrow \mathcal{S}) \dots Alt_{|T|}}{T}$ \\
% &$|$ & $(\lambda V.\mathcal{S})$ \\
 &$|$ & $(\mathcal{S} \; E)$ $|$ $(E \; \mathcal{S})$ \\
 &$|$ & $\letrecm{x_1 = E_1, \dots, x_n = E_n}{\mathcal{S}}$ \\
 &$|$ & $\letrecm{x_1 = E_1, \dots, x_{i-1}=E_{i-1}, x_i=\mathcal{S},x_{i+1}=E_{i+1}, \dots, x_n = E_n}{E}$ \\
% &$|$ & $\seqm{\mathcal{S}}{E}$ $|$  $\seqm{E}{\mathcal{S}}$ \\
% &$|$ & $(\mathcal{S} \oplus E)$ $|$ $(E \oplus \mathcal{S})$ \\
\end{tabular}
\end{definition}

Wir schreiben $S$ für einen Kontext aus der Klasse der
Oberflächenkontexte. 

Eine weitere Kontextklasse ist die Klasse der Reduktionskontexte, die
mit Hilfe einer Unterklasse, der Klasse der schwachen
Reduktionskontexte, definiert wird. 
\begin{definition}%[Schwacher Reduktionskontext, Reduktionskontext]
\label{def:reduktionskontexte}
Die Klasse $\mathcal{R^-}$ der \emph{schwachen Reduktionskontexte} ist
durch folgende Grammatik definiert:
%Ein Reduktionskontext $\mathcal{R}$ ist ein Kontext, so dass sein Loch vom Unwind
%Algorithmus mit einem $S$ oder $T$ Label markiert wird. Ein schwacher
%Reduktionskontext $\mathcal{R}^-$ ist ein Reduktionskontext, bei dem das Loch
%nicht in eiem \texttt{letrec}-Ausdruck vorkommt:

\begin{tabular}{lcl}
$\mathcal{R^-}$ & ::= & $\lochm$ \\
% &$|$ & $(c \; E_1 \dots E_{i-1} \; \mathcal{C} \; E_{i+1} \dots E_{ar(c)})$ \\
% &$|$ & $\casetm{\mathcal{R^-}}{Alts}{T}$ \\ %$|$ $\casetm{E}{Alt_1 \dots (Pat \rightarrow \mathcal{C}) \dots Alt_{|T|}}{T}$ \\
% &$|$ & $(\lambda V.\mathcal{C})$ \\
 &$|$ & $(\mathcal{R^-} \; E)$ \\ %$|$ $(E \; \mathcal{C})$ \\
% &$|$ & $\letrecm{x_1 = E_1, \dots, x_n = E_n}{\mathcal{C}}$ \\
% &$|$ & $\letrecm{x_1 = E_1, \dots, x_{i-1}=E_{i-1}, x_i=\mathcal{C},x_{i+1}=E_{i+1}, \dots, x_n = E_n}{E}$ \\
% &$|$ & $\seqm{\mathcal{R^-}}{E}$ \\ %$|$  $\seqm{E}{\mathcal{C}}$ \\
% &$|$ & $(\mathcal{C} \oplus E)$ $|$ $(E \oplus \mathcal{C})$ \\
\end{tabular}

Die Klasse $\mathcal{R}$ der \emph{Reduktionskontexte} ist definiert durch:

\begin{tabular}{lcl}
$\mathcal{R}$ & ::= & $\mathcal{R^-}$ \\
 &$|$ & $\letrecm{Env}{\mathcal{R^-}}$ \\
 &$|$ & $\letrecm{x_1 = \mathcal{R}^-_1, x_2=\mathcal{R}^-_2[x_1], \dots, 
    x_j=\mathcal{R}^-_j[x_{j-1}], Env}{\mathcal{R}^-[x_j]}$, \\
 & & %mit $j \geq 1$ 
  wobei $\mathcal{R}^-, \mathcal{R}^-_i$ Kontexte der Klasse der
 schwachen Reduktionskontexte sind. %für $i=1, \dots, j$.  
\end{tabular} \\
\end{definition}

Für Kontexte aus der Klasse der schwachen Reduktionskontexte schreiben
wir $R^-$ und für Kontexte aus der Klasse der Reduktionskontexte $R$. 

Sei $t$ ein Ausdruck mit $t = R^-[t_1]$, dann nennen wir $R^-$
\emph{maximal für t}, wenn es keinen größeren schwachen
Reduktionskontext $R_0^-$ gibt, so dass $t = R_0^-[t_2]$. 

Sei $t = R[t_1]$ ein Ausdruck, so nennen wir $R$ einen 
\emph{maximalen Reduktionskontext für $t$}, wenn $R$
\begin{itemize}
\item ein maximaler schwacher Reduktionskontext $R^-$ ist, oder 
\item von der Form $\letrecm{x_1 = s_1, \dots, x_n = s_n}{R^-}$ ist, 
  wobei $R^-$ ein maximaler schwacher Reduktionskontext ist und 
  für alle $j$ gilt $t_1 \neq x_j$, oder
\item 
von der Form 
$\letrecm{x_1 = R^-_1, x_2 = R^-_2[x_1], \dots, x_j = R^-_j[x_{j-1}], Env}{R^-[x_j]}$
ist, wobei $R^-_1$ ein maximaler schwacher Reduktionskontext für
$R^-_1[t_1]$ und die Anzahl $j$ der Bindungen maximal ist. 
\end{itemize}

\begin{beispiel}
\label{bsp:max-red-kontext}
Für den Ausdruck $t = \letrecm{x_1 = (\lambda y. y), x_2 = (x_1 \; x_2)}{x_2}$
ist der maximale Reduktionskontext 
$\letrecm{x_1 = \lochm, x_2 = (x_1 \; x_2)}{x_2}$. 
%im Gegensatz zu den nicht maximalen 
Reduktionskontexte für $t$, die nicht maximal sind, haben die Form 
$\letrecm{x_1 = (\lambda y. y), x_2 = (x_1 \; x_2)}{\lochm}$ oder
$\letrecm{x_1 = (\lambda y. y), x_2 = (\lochm \; x_2)}{x_2}$. 
%für die jeweils die Bedinung $t_1 \neq x_j$ verletzt ist. 
\end{beispiel}

Eine Möglichkeit für einen Ausdruck $t = R[t_1]$ den maximalen
Reduktionskontext zu bestimmen, ist durch den so genannten 
\emph{Unwind} Algorithmus gegeben:  

\begin{definition}[Unwind]
\label{def:unwind}
%Unwind sucht den maximalen Reduktionskontext zu einem Term $t$, 
%so kann die Position an der eine no-Reduktion ausgeführt wird,
%gefunden werden. 
Es werden vier Markierungen verwendet, die über die Struktur eines
Ausdrucks geschoben werden: $T,S,V,W$.  
Die Markierung $T$ kennzeichnet den am weitesten oben
stehenden Ausdruck. Soll für einen Ausdruck $t$ der maximale
Reduktionskontext bestimmt werden, dann startet der Algorithmus mit $t^T$. 
Unterausdrücke von $t$ werden 
%an denen der Algorithmus (erflogreich) stopp, oder die Markierung weiter verschiebt, 
mit $S$ markiert. Unterausdrücke, die schon einmal besucht wurden, werden durch 
$V$ und $W$ markiert. 
Die Markierung $W$ wird für Variablen an bestimmten Positionen verwendet
und signalisiert, dass die markierte Variable nicht durch eine
\emph{cp}-Reduktion (die in Definition \ref{def:reduktionen} zu sehen
ist) ersetzt wird.   
Die Markierung $S \vee T$ steht für einen
entweder mit $S$ oder $T$ gekennzeichneten Ausdruck. 
%Für einen Ausdruck $s$ startet der Algorithmus mit $s^T$ und in $s$
%sind keine Subterme markiert. 
Soll ein bereits mit $V$ oder $W$ markierter Unterausdruck eine weitere
Markierung erhalten, stoppt Unwind mit einem Fehler, um
Schleifen zu vermeiden. Wenn keine Regel zum 
Verschieben von Markierungen mehr anwendbar ist, stoppt Unwind, 
mit dem Resultat $t = R[t_1^{S\vee T}]$, wobei $R$ ein maximaler
Reduktionskontext für $t$ ist.
Die Markierungen werden nach folgenden Regeln verschoben:

\begin{tabular}{llrl}
1. & $\letrecm{Env}{s}^T$ & $\rightarrow$ & $\letrecm{Env}{s^S}^V$ \\
2. & $(s \; t)^{S \vee T}$ & $\rightarrow$ & $(s^S \; t)^V$ \\
%$\casetm{s}{Alts}{T}^{S \vee T}$ & $\rightarrow$ &
%  $\casetm{s^S}{Alts}{T}^V$ \\
%$\seqm{s}{t}^{S \vee T}$ & $\rightarrow$ & $\seqm{s^S}{t}^V$ \\
3. & $\letrecm{x=s,Env}{C[x^S]}$ & $\rightarrow$ &
  $\letrecm{x=s^S,Env}{C[x^V]}$ \\
%& & wenn $s$ noch nicht markiert war. \\ 
4. & $\letrecm{x=s,y=C[x^S],Env}{t}$ & $\rightarrow$ &
  $\letrecm{x=s^S,y=C[x^V],Env}{t}$ \\
& & &  wenn $C[x] \neq x$ gilt\\
5. & $\letrecm{x=s,y=x^S,Env}{t}$ & $\rightarrow$ &
  $\letrecm{x=s^S,y=x^W,Env}{t}$ \\
\end{tabular}

Der Markierungsalgorithmus steigt nicht in 
\letr-Ausdrücke hinab, die mit $S$ markiert sind. 
\end{definition}

\begin{beispiel}
\label{bsp:unwind}
Sei $t = \letrecm{x_1 = (\lambda y. y), x_2 = (x_1 \; x_2)}{x_2}$ ein
Ausdruck, für den der maximale Reduktionskontext mit Unwind bestimmt
werden soll. Der Pfeil $\xrightarrow{i}$ gibt an, dass die Regel
$i$ des Algorithmus zum Verschieben einer Markierung verwendet wurde. 
\[\begin{array}{rl}
 & \letrecm{x_1 = (\lambda y. y), x_2 = (x_1 \; x_2)}{x_2}^T \\
\xrightarrow{1} & \letrecm{x_1 = (\lambda y. y), x_2 = (x_1 \; x_2)}{x_2^S}^V \\
\xrightarrow{3} & \letrecm{x_1 = (\lambda y. y), x_2 = (x_1 \; x_2)^S}{x_2^V}^V \\
\xrightarrow{2} & \letrecm{x_1 = (\lambda y. y), x_2 = (x_1^S \; x_2)^V}{x_2^V}^V \\
\xrightarrow{4} & \letrecm{x_1 = (\lambda y. y)^S, x_2 = (x_1^V \; x_2)^V}{x_2^V}^V \\
\end{array}\]
Auf den markierten Ausdruck in der letzten Zeile ist keine Regel mehr
anwendbar. Der maximale Reduktionskontext von $t$ ist somit
$\letrecm{x_1 = \lochm, x_2 = (x_1 \; x_2)}{x_2}$,
entsprechend dem Beispiel \ref{bsp:max-red-kontext}. 
\end{beispiel}

%Ein maximaler Reduktionskontext eines Ausdruck $s$ ist ein
%Reduktionskontext $\mathcal{R}$ mit $\mathcal{R}[s'] = s$, so dass
%Unwind angewandt auf $s$ den Subterm $s'$ mit $S$ oder $T$ markiert
%und dann mit Erfolg stoppt. 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Reduktionen}
\label{sec:reduktionen}
%% Reduktionenen
\begin{definition}[Reduktionsregeln]
\label{def:reduktionen}
Die \emph{Reduktionsregeln} des $\Lambda^{let}$-Kalküls sind in Abbildung
\ref{fig-reduktionen} zu sehen. 
Eine Reduktionsregel der Form 
\[(name) \;\; a \rightarrow b\]
ist zu lesen als: Ein Ausdruck der Form $a$ kann durch einen Ausdruck
der Form $b$ ersetzt werden durch Anwendung der Reduktionsregel mit
der Bezeichnung $(name)$. 

Die Vereinigung der Regeln (\emph{llet-in}) und (\emph{llet-e}) wird als
(\emph{llet}), 
%Die Vereinigung der Regeln $(choice-l)$ und $(choice-r)$ wird als 
%$(choice)$ bezeichnet. Die Vereinigung der Regeln $(case-c)$,
%$(case-in)$ und $(case-e)$ wird als $(case)$ bezeichnet. Die
%Vereinigung der Regeln $(seq-c)$, $(seq-in)$ und $(seq-e)$ wird als
%$(seq)$ bezeichnet. 
die Vereinigung der Regeln (\emph{cp-in}) und (\emph{cp-e})
als (\emph{cp}) und die Vereinigung der Regeln 
(\emph{lapp}) und (\emph{llet}) als (\emph{lll}) bezeichnet. 

\begin{figure}[htp]
\centering
\fbox{
\begin{Bitemize}
\item [(llet-in)] $\letrecm{Env_1}{\letrecm{Env_2}{s}^S}$  \\
  $\longrightarrow \letrecm{Env_1, Env_2}{s}$
%  $\letrecm{x_1=s_1, \dots, x_n=s_n}{\letrecm{y_1=t_1,
%  \dots, y_m=t_m}{r}}$  \\
%  $\longrightarrow \letrecm{x_1=s_1, \dots, x_n=s_n, y_1=t_1, \dots, y_m=t_m}{r}$
\item [(llet-e)] $\letrecm{Env_1, x=\letrecm{Env_2}{s}^S}{t}$ \\
  $\longrightarrow \letrecm{Env_1, Env_2, x=s}{t}$
\item [(cp-in)] $\letrecm{\xkette{v^S},Env}{C[x_n^V]}$ \\
  $\longrightarrow \letrecm{\xkette{v},Env}{C[v]}$ \\
  wenn $v$ eine Abstraktion ist. 
\item [(cp-e)] $\letrecm{\xkette{v^S},Env, y=C[x_n^V]}{t}$ \\
  $\longrightarrow$ 
  $\letrecm{\xkette{v},Env, y=C[v]}{t}$ \\
  wenn $v$ eine Abstraktion ist. 
\item [(lapp)]   $C[(\letrecm{Env}{s}^S \; t)]  \longrightarrow C[\letrecm{Env}{(s \; t)}]$
\item [(lbeta)] $C[((\lambda x . s)^S \; t)] \longrightarrow C[\letrecm{x=t}{s}]$
%\item [(lcase)]  $\casetm{\letrecm{Env}{s}}{Alts}{T} \longrightarrow \letrecm{Env}{\casetm{s}{Alts}{T}}$
%\item [(lseq)]   $\seqm{\letrecm{Env}{s}}{t} \longrightarrow \letrecm{Env}{\seqm{s}{t}}$
%\item [(case-c)] $\casetm{(c \; s_1 \dots s_n)}{((c \; y_1 \dots y_n) \rightarrow s), Alts}{T} \longrightarrow
%    \letrecm{y_1=s_1, \dots, y_n=s_n}{s}$
%\item [(case-in)] \letrecs{$x_1 = (c \; s_1 \dots s_n), x_2 = x_1, \dots , x_m =
%  x_{m-1}, Env$}{$C[$\caset{$x_m$}{$((c \; y_1 \dots y_n) \rightarrow s), Alts$}{T}$]$} \\
%  $\longrightarrow$ \\
%  \letrecs{$x_1 = (c \; z_1 \dots z_n), z_1=s_1, \dots, z_n=s_n, x_2 = x_1, \dots , x_m =
%  x_{m-1}, Env$}{$C[\letrecm{y_1=z_1, \dots, y_n=z_n}{s}]$}
%\item [(case-e)] \letrect{$x_1 = (c \; s_1 \dots s_n), x_2 = x_1, \dots , x_m = x_{m-1}, Env$}
%  {$u = C[$\caset{$x_m$}{$((c \; y_1 \dots y_n) \rightarrow s), Alts$}{T}$]$}{t} \\
%  $\longrightarrow$ \\
%  \letrect{$x_1 = (c \; z_1 \dots z_n), z_1=s_1, \dots, z_n=s_n, x_2 = x_1, \dots , x_m =
%  x_{m-1}, Env$}
% {$u = C[\letrecm{y_1=z_1, \dots, y_n=z_n}{s}]$}{t}
%\item [(seq-c)] $\seqm{s}{t} \longrightarrow t$, 
%  wenn $s$ ein Wert (Abstraktion oder Konstruktoranwendung) ist.
%\item [(seq-in)] \letrec{\xkette{(c \; s_1 \dots s_n)}$,Env$}{$C[\seqm{x_m}{t}]$} \\
%  $\longrightarrow$ \\
%  \letrec{\xkette{(c \; s_1 \dots s_n)}$,Env$}{$C[t]$} 
%\item [(seq-e)]  \letrec{\xkette{(c \; s_1 \dots s_n)}$,Env, y=C[\seqm{x_m}{t}]$}{s} \\
%  $\longrightarrow$ \\
%  \letrec{\xkette{(c \; s_1 \dots s_n)}$,Env, y=C[t]$}{s} 
%\item [(choice-l)] $R_0[(s \oplus t)] \longrightarrow R_0[s]$ 
%\item [(choice-r)] $R_0[(s \oplus t)] \longrightarrow R_0[t]$ 
\end{Bitemize}}
\caption{Reduktionsregeln des $\Lambda^{let}$-Kalküls. \label{fig-reduktionen}}
\end{figure}
\end{definition}

Wenn notwendig, notieren wir die verwendete Reduktionsregel oder auch
den verwendeten Kontext über dem Reduktionspfeil. So ist z.B.
$\xrightarrow{R,\emph{llet-in}}$ eine $(\emph{llet-in})$-Reduktion
in einem Reduktionskontext.
Die transitive Hülle von Reduktionen  bezeichnen wir mit $+$, die
reflexiv-transitive Hülle mit $*$. So ist beispielsweise 
$\xrightarrow{let^+}$ die transitive Hülle von
$\xrightarrow{let}$. 

Die Reduktionsregeln (\emph{cp-in}) und (\emph{cp-e})
kann man als Regelschemata verstehen, die eine Menge von Regeln beschreiben: 
Für alle $m$ die entsprechende Regel mit einer Variablenkette
$\set{x_i=x_{i-1}}^m_{i=2}$ der L\"ange $m$.

Die Reduktionsregeln des $\Lambda^{let}$-Kalküls verwenden eine
Meta-Notation: In den Reduktionsregeln symbolisieren die Buchstaben
$s,t$ beliebige Ausdrücke, $Env, Env_i$ steht für beliebige
\letr-Umgebungen und $v$ repräsentiert eine beliebige Abstraktion. 
Außerdem enthalten die Reduktionsregeln die Kontextvariable $C$, die
einen allgemeinen Kontext symbolisiert. 
Die jeweiligen Symbole können wie \emph{Metavariablen} verstanden werden,
für die Ausdrücke eines entsprechenden Typs eingesetzt werden können. 
In späteren Kapiteln werden wir schrittweise eine Abbildung
definieren, die Ausdrücke in Terme eines anderen Kalküls
übersetzt. Dabei sind wir vor allem an der Übersetzung von linken
Seiten von Reduktionsregeln interessiert. Diese enthalten
Metavariablen, die kein direkter Bestandteil der Sprache
$L_{\Lambda^{let}}$ sind. Deswegen legen wir als Bezeichnung fest:
Wenn wir in Zukunft von
$\Lambda^{let}$-Ausdrücken sprechen, dann meinen wir Ausdrücke der
Sprache $L_{\Lambda^{let}}$ erweitert um die Meta-Notation der
Reduktionsregeln. Ist von der Übersetzung von $\Lambda^{let}$ die
Rede, dann ist die Übersetzung von Ausdrücken der
Sprache $L_{\Lambda^{let}}$ erweitert um die Meta-Notation der
Reduktionsregeln gemeint. 


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Normalordnungsreduktion}
\label{sec:no}

Sei $R$ ein maximaler Reduktionskontext für einen Ausdruck $t$ und $t =
R[t']$. Die Normalordnungsreduktion wendet eine der Reduktionsregeln
aus Definition \ref{def:reduktionen} auf $t'$ oder den Ausdruck direkt
über $t'$ an. 
Bevor wir die Normalordnungsreduktion formal definieren, betrachten
wir, wie sie mit Hilfe des Unwind Algorithmus formuliert werden kann. 

%call-by-need Strategie, die einer call-by-name Strategie angepasst an Sharing 
%entspricht. 

%\begin{definition}[Normalordnungsreduktion]
%\label{def-no}
Sei t ein Ausdruck. Eine Ein-Schritt \emph{Normalordnungsreduktion}
$\xrightarrow{n}$ ist so definiert, dass zuerst  
der Unwind Algorithmus (aus  Definition \ref{def:unwind}) auf $t$
angewendet wird. 
Terminiert dieser erfolgreich, dann wird, wenn
möglich, eine der Reduktionen aus Definition \ref{def:reduktionen}
angewendet, wobei die Markierungen $S$ und $V$ der Regeln den
Markierungen von $t$ entsprechen müssen. 
%\end{definition}

\begin{beispiel}
\label{bsp:no-reduktion}
Wir reduzieren einen Ausdruck $t$ in Normalordnung. 
In jedem Ausdruck sind die Markierungen, die durch \emph{Unwind}
gesetzt werden, mit angegeben. 
\[\begin{array}{rl}
t = & \letrecm{x_1=(\lambda y.y)^S, x_2 = x_1^W, x_3 = (x_2^V \; (\lambda z. z))^V}{x_3^V} \\
%\xrightarrow{Unwind} & \letrecm{x_1=(\lambda y.y)^S, x_2 = x_1^W, x_3 = (x_2^V \; (\lambda z. z))^V}{x_3^V} \\
\xrightarrow{n,\emph{cp-e}} & \letrecm{x_1=(\lambda y.y), x_2 = x_1, x_3 = ((\lambda y.y)^S \; (\lambda z. z))^V}{x_3^V} \\
\xrightarrow{n,\emph{lbeta}} & \letrecm{x_1=(\lambda y.y), x_2 = x_1, x_3 = \letrecm{y=(\lambda z. z)}{y}^S}{x_3^V} \\
\xrightarrow{n,\emph{llet-in}} & \letrecm{x_1=(\lambda y.y), x_2 = x_1, x_3 = y^W, y=(\lambda z. z)^S}{x_3^V} \\
\xrightarrow{n,\emph{cp-in}} & \letrecm{x_1=(\lambda y.y), x_2 = x_1, x_3 = y, y=(\lambda z. z)}{(\lambda z. z)^S}^V \\
\end{array}\]
Auf den letzten Ausdruck ist keine Normalordnungsreduktion mehr
anwendbar. 
\end{beispiel}

\begin{definition}[Normalordnungsreduktion\label{def-no}]
Sei $t$ ein Ausdruck und $R$ ein maximaler Reduktionskontext, so dass $t = R[t']$
für einen Ausdruck $t'$. Die Normalordnungsreduktion
$\stackrel{n}{\rightarrow}$ ist durch einen der folgenden Fälle
definiert:
\begin{enumerate}
\item $t'$ ist ein \letr-Ausdruck und $R$ ist nicht trivial
  (d.h. nicht gleich $\lochm$). Sei $R_0$ ein Reduktionskontext, 
  so können folgende Fälle auftreten:
\begin{itemize}
%%\item [(lseq)] 
%%  \nodeftab{0.3}{0.33}
%%  {$R = R_0[$\seq{\loch}{r}$]$}{Reduziere \seq{$t'$}{r} mit Regel}{(lseq).} 
\item [a)] %\nodeftab{0.3}{0.33}
  {$R = R_0[(\lochm \; s)]$.} {Dann reduziere $(t' \; s)$ mit der Regel} {(\emph{lapp}).}
%%\item [(lcase)] \nodeftab{0.3}{0.33}
%%  {$R = R_0[$\caset{\loch}{Alts}{T}$]$}
%%  {Reduziere \caset{$t'$}{Alts}{T} mit Regel}{(lcase).}
\item [b)] %\nodeftab{0.3}{0.33}
  {$R =$ \letrec{$Env$}{\loch}.} {Dann reduziere $t$ mit der Regel} {(\emph{llet-in}).}
\item [c)] %\nodeftab{0.3}{0.33}
  {$R = \letrecm{x = \lochm, \; Env}{t''}$.} {Dann reduziere $t$ mit der Regel} {(\emph{llet-e}).}
\end{itemize}

%%\item $t' = (c \; s_1 \dots s_{ar(c)})$ ist Konstruktoranwendung, $R_0$ ist Reduktionskontext,
%%  $R^-_0$ ist schwacher Reduktionskontext.
%%\begin{itemize}
%%\item [(case-c)] $R = R_0[$\caset{\loch}{Alts}{T}$]$ \\
%%Wenn $c :: T$, dann reduziere \caset{$t'$}{Alts}{T} mit Regel (case-c).
%%\item [(case-in)] $R =$\letrecs{$x_1 = \lochm, x_2 = x_1, \dots , x_m =
%%  x_{m-1}, Env$}{$R^-_0[$\caset{$x_m$}{$((c \; y_1 \dots y_{ar(c)})
%%  \rightarrow r)$ Alts}{T}$]$} \\ %
%%Wenn $c :: T$, dann reduziere $t$ mit Regel (case-in).
%%\item [(case-e)] $R =$\letrect{$x_1 = \lochm, x_2 = x_1, \dots , x_m =
%%  x_{m-1}, Env,$}{$y = R^-_0[$ \caset{$x_m$}{$((c \; y_1 \dots y_{ar(c)})
%%  \rightarrow u)$ Alts}{T}$]$}{r} \\
%%$y$ ist in einem Reduktionskontext. 
%%Wenn $c :: T$, dann reduziere $t$ mit Regel (case-e).
%%\item [(seq-c)] $R = R_0[$\seq{\loch}{r}$]$ \\
%%Reduziere \seq{$t'$}{r} mit Regel (seq-c).
%%\item [(seq-in)] $R =$\letrecs{$x_1 = \lochm, x_2 = x_1, \dots, x_m =
%%  x_{m-1}, Env$}{$R^-_0[$\seq{$x_m$}{r}$]$} \\
%%Reduziere $t$ mit Regel (seq-in).
%%\item [(seq-e)] $R =$\letrect{$x_1 = \lochm, x_2 = x_1, \dots, x_m =
%%  x_{m-1}, Env$}{$y = R^-_0[$\seq{$x_m$}{u}$]$}{r} \\
%%$y$ ist in einem Reduktionskontext. 
%%Reduziere $t$ mit Regel (seq-e).
%%\end{itemize}
%%
\item $t'$ ist eine Abstraktion. $R_0$ ist Reduktionskontext und
  $R^-_0$ ist schwacher Reduktionskontext. Es können folgende Fälle
  auftreten: 		  
\begin{itemize}
\item [a)] $R = R_0[(\lochm \; s)]$. 
  Dann reduziere $(t \; s)$ mit der Regel (\emph{lbeta}).
\item [b)] $R = \letrecm{\xkette{\lochm}, Env}{R^{-}_{0}[x_n]}$.
  Dann reduziere $t$ mit der Regel (\emph{cp-in}), so dass
  $R^-_0[x_n]$ durch $R^-_0[t']$ ersetzt wird.
\item [d)] $R = \letrecm{\xkette{\lochm}, Env, y = R^-_0[(x_n \; s)]}{t''}$,
  wobei $y$ in einem Reduktionskontext ist.  
  Dann reduziere $t$ mit der Regel (\emph{cp-e}), so dass $R^-_0[(x_n
  \; s)]$ durch $R^-_0[(t' \; s)]$ ersetzt wird.
\end{itemize}
%%\item $t' = q \oplus r$. Reduziere $t'$ mit (choice-l) oder (choice-r)
%%  (nichtdeterministisch). 
\end{enumerate}

Der \emph{Normalordnungsredex} ist der gesamte Unterausdruck, auf den
die entsprechende Reduktionsregel angewendet wird.
\end{definition}

Der Begriff Normalordnungsreduktion wird abgekürzt als \emph{no-Reduktion}.
Eine Reduktionsfolge $t \rightarrow \dots \rightarrow t_n$ ist
eine Folge von Reduktionen des $\Lambda^{let}$-Kalküls. 
Besteht die Reduktionsfolge ausgehend von $t$ ausschließlich aus
Normalordnungsreduktionen, wird sie als \emph{no-Reduktionsfolge von t}
bezeichnet.  

%Für $t= R^-[t_0]$ ist $R^-$ maximal (bezüglich $t$), wenn es keinen
%größeren schwach Reduktionskontext $R'^-$ mit $t=R'^-[t_0]$ gibt. 
%Ist $t=R[t_0]$, dann ist $R$ maximaler Reduktionskontext (für $t$),
%wenn
%\begin{itemize}
%\item $R$ ist maximaler schwacher Reduktionskontext, oder
%\item $R$ ist von der Form $\letrecm{x_1=E_1,\dots, x_n=E_n}{R^-}$ wobei
%   $R^-$ ein schwacher Reduktionskontext ist und für alle $j = 1,
%   \dots, n$ gilt $t_0 \neq x_j$. Oder
%\item $R$ ist von der Form $\letrecm{x_1=R^-_1, x_2=R^-_2[x_1], \dots,
%   x_j=R^-_j[x_{j-1}]}{R^-[x_j]}$ wobei $R^-_i$ schwache
%   Reduktionskontexte sind und $R^-_1$ maximal im Bezug auf $t_0$ ist und
%   die Anzahl der Bindungen $j$ maximal ist.
%\end{itemize}
%\end{definition}
%
%Maximale Reduktionskontexte werden verwendet, um eine standardisierte Form der
%Auswertung zu definieren (Normalordnung \ref{def-no}).

%In Abbildung \ref{fig-noUnwind} ist die Normalordnung mit Hilfe von
%Unwind definiert. 
%
%\begin{figure}[h!tp]
%\fbox{
%\begin{Bitemize}
%\item [(llet-in)] $\letrecm{Env_1}{\letrecm{Env_2}{s}^S}  \longrightarrow \letrecm{Env_1, Env_2}{s}$
%\item [(llet-e)]  $\letrecm{Env_1, x=\letrecm{Env_2}{s}^S}{r} \longrightarrow \letrecm{Env_1, Env_2, x=s}{r}$
%\item [(lapp)]   $R[(\letrecm{Env}{s}^S \; r)]  \longrightarrow R[\letrecm{Env}{(s \; r)}]$
%\item [(lcase)]  $R[\casetm{\letrecm{Env}{s}^S}{Alts}{T}] \longrightarrow R[\letrecm{Env}{\casetm{s}{Alts}{T}}]$
%\item [(lseq)]   $R[\seqm{\letrecm{Env}{s}^S}{r}] \longrightarrow R[\letrecm{Env}{\seqm{s}{r}}]$
%\item [(case-c)] $R[\casetm{(c \; s_1 \dots s_n)^S}{((c \; y_1 \dots y_n) \rightarrow s), Alts}{T}] \longrightarrow
%    R[\letrecm{y_1=s_1, \dots, y_n=s_n}{s}]$
%\item [(case-in)] \letrecs{$x_1 = (c \; s_1 \dots s_n)^S, x_2 = x_1, \dots , x_m =
%  x_{m-1}, Env$}{$R^-[$\caset{$x_m$}{$((c \; y_1 \dots y_n) \rightarrow s), Alts$}{T}$]$} \\
%  $\longrightarrow$ \\
%  \letrecs{$x_1 = (c \; z_1 \dots z_n), z_1=s_1, \dots, z_n=s_n, x_2 = x_1, \dots , x_m =
%  x_{m-1}, Env$}{$R^-[\letrecm{y_1=z_1, \dots, y_n=z_n}{s}]$}
%\item [(case-e)] \letrect{$x_1 = (c \; s_1 \dots s_n)^S, x_2 = x_1, \dots , x_m = x_{m-1}, Env$}
%  {$y = R^-[$\caset{$x_m$}{$((c \; y_1 \dots y_n) \rightarrow s), Alts$}{T}$]$}{t} \\
%  $\longrightarrow$ \\
%  \letrect{$x_1 = (c \; z_1 \dots z_n), z_1=s_1, \dots, z_n=s_n, x_2 = x_1, \dots , x_m =
%  x_{m-1}, Env$}{$y = R^-[\letrecm{y_1=z_1, \dots, y_n=z_n}{s}]$}{t} \\
% $y$ steht in einem Reduktionskontext. 
%\item [(lbeta)] $R[((\lambda x . s)^S \; r)] \longrightarrow R[\letrecm{x=r}{s}]$
%\item [(cp-in)] \letrec{\xkette{(\lambda x.s)^S},$Env$}{$R^-[x_m]$} \\
%  $\longrightarrow$ \\
%  \letrec{\xkette{(\lambda x.s)},$Env$}{$R^-[(\lambda x'.s[x'/x])]$} \\
%\item [(cp-e)] \letrec{\xkette{(\lambda x.s)^S},$Env, y=R^-[x_m]$}{t} \\
%  $\longrightarrow$ \\
%  \letrec{\xkette{(\lambda x.s)},$Env, y=R^-[(\lambda x'.s[x'/x])]$}{t} \\
%  $y$ steht in einem Reduktionskontext. 
%\item [(seq-c)] $R[\seqm{s^S}{t}] \longrightarrow R[t]$, 
%  wenn $s$ ein Wert (Abstraktion oder Konstruktoranwendung) ist.
%\item [(seq-in)] \letrec{\xkette{(c s_1 \dots s_n)^S}$,Env$}{$R^-[\seqm{x_m}{t}]$} \\
%  $\longrightarrow$ \\
%  \letrec{\xkette{(c s_1 \dots s_n)}$,Env$}{$R^-[t]$} 
%\item [(seq-e)]  \letrec{\xkette{(c s_1 \dots s_n)^S}$,Env, y=R^-[\seqm{x_m}{t}]$}{s} \\
%  $\longrightarrow$ \\
%  \letrec{\xkette{(c s_1 \dots s_n)}$,Env, y=R^-[t]$}{s} \\
%  $y$ steht in einem Reduktionskontext. 
%\item [(choice-l)] $R[(s \oplus t)^S] \longrightarrow R[s]$ 
%\item [(choice-r)] $R[(s \oplus t)^S] \longrightarrow R[t]$ 
%\end{Bitemize}}
%\caption{Normalordnungsreduktion definiert mit Hilfe von Unwind. 
%  $R$ ist Reduktionskontext, $R^-$ ist schwacher Reduktionskontext. \label{fig-noUnwind}}
%\end{figure}
%\end{definition}

\begin{korollar}%[Eindeutigkeit der Normalordnungsreduktion]
\label{kor.no-eindeutig}
Für alle Ausdrücke $t$ gilt:
Wenn $t$ einen Normalordnungsredex besitzt, dann ist dieser eindeutig.
\end{korollar}
%\begin{beweis}
%Durch Prüfen aller Fälle. $\qed$
%\end{beweis}

Wir sind hauptsächlich an Folgen von Normalordnungsreduktionen
interessiert $\xrightarrow{n,^*}$, die mit Ausdrücken enden, 
die nicht mehr weiter reduzierbar sind. 
 
%% WHNF
\begin{definition}[WHNF]
\label{def:whnf}
Ein Ausdruck $t$ ist eine \emph{schwache Kopfnormalform}
(WHNF\footnote{WHNF ist die Abkürzung des englischen Begriffs weak
  head normalform.}), wenn
\begin{itemize}
\item $t$ eine Abstraktion ist, oder
\item $t$ von der Form $t = \letrecm{Env}{v}$ und $v$ eine Abstraktion ist.
%\item $t =$ \letrec{\xkette{(c \; s_1 \dots s_n)}, Env}{$x_m$}
\end{itemize}
\end{definition}

Der letzte Ausdruck in Beispiel \ref{bsp:no-reduktion} ist eine WHNF,
da er der zweiten Form aus obiger Definition entspricht. 


%% Konvergenz
\begin{definition}%[Terminierung]
\label{def:konvergenz}
Man sagt ein Ausdruck $t$ \emph{terminiert}, geschrieben als
$t\terminates$, gdw. eine 
no-Reduktionsfolge ausgehend von $t$ zu einer WHNF existiert.
Sonst sagt man $t$ \emph{divergiert} und schreibt $t\!\!\Uparrow$.
\end{definition}

\section{Kontextuelle Äquivalenz}
\label{sec:kontextuelle-aquivalenz}
%% Kontextuelle Praeordnung, Equivalenz

Die Grundlage der Semantik des $\Lambda^{let}$-Kalküls ist die
Gleichheit von Ausdrücken, die durch den Begriff der
\emph{kontextuellen Äquivalenz} definiert wird. 

\begin{definition}[Kontextuelle Äquivalenz]
\label{def-kontextuellePraeordnung}
Die \emph{Kontextuelle Quasiordnung} $\leq_{C}$ auf Ausdrücken $s,t$
ist definiert durch 
\[ s \leq_C t, \; gdw. \; \forall C\lochm: C[s]\terminates \Rightarrow C[t]\terminates,\]

und die \emph{Kontextuelle Äquivalenz} $\sim_{C}$ für Ausdrücke $s,t$
ist definiert durch 
\[s \sim_C t, \; gdw. \; s \leq_C t \wedge t \leq_c s.\]
\end{definition}

Unter der Kontextuellen Äquivalenz werden zwei Ausdrücke als gleich
angesehen, wenn ihr Terminierungsverhalten unter Einsetzung in
beliebige Kontexte gleich ist. 

Die Relation $\leq_C$ ist eine Quasiordnung auf Ausdrücken (d.h. sie
ist reflexiv und transitiv) und die Relation $\sim_C$ ist eine
Äquivalenzrelation auf Ausdrücken (d.h. sie ist reflexiv, transitiv
und symmetrisch). Außerdem sind beide Relationen 
stabil unter Einsetzung in Kontexte.

\begin{proposition}%[Präkongruenz, Kongruenz]
\label{prop.kongruenz}
Die Relation $\leq_C$ ist eine Quasikongruenz, d.h. für alle Kontexte
$C$ gilt 
$s \leq_c t \Rightarrow C[s] \leq_c C[t]$.
Die Relation $\sim_C$ ist eine Kongruenz, d.h.  für alle Kontexte $C$ gilt
$s \sim_c t \Rightarrow C[s] \sim_c C[t]$.
\end{proposition}
\begin{beweis}
Siehe \cite{schmidt-schauss_fundio:lambda-calculus_2003}, Proposition 6.6. $\qed$
\end{beweis}

Um für zwei Ausdrücke $s$ und $t$ 
%zu zeigen, dass sie kontextuell äquivalent sind, 
eine Aussage über ihre Kontextuelle Äquivalenz zu treffen, 
muss ihr Terminierungsverhalten unter Einsetzung in
(alle) Kontexte $C$ betrachtet werden. Die Kontexte sind dabei aus der
Klasse der allgemeinen Kontexte. Folgendes Lemma zeigt, dass eine
Betrachtung aller Kontexte $R$ aus der kleineren Klasse der
Reduktionskontexte ausreichend ist, um die Kontextuelle Äquivalenz von 
zwei Ausdrücken zu zeigen. 

\begin{lemma}[Kontextlemma]
\label{lem:kontextlemma}
Seien $s$ und $t$ Ausdrücke. Wenn für alle Reduktionskontexte $R$ gilt:
$R[s]\terminates \; \Rightarrow R[t]\terminates$, dann gilt auch
für alle Kontexte $C$: $C[s]\terminates \; \Rightarrow C[t]\terminates$.
\end{lemma}
\begin{beweis}
Siehe \cite{schmidt-schauss_safety_2007}, Lemma A.1. $\qed$
\end{beweis}

\begin{definition}[Korrekte Programmtransformation]
\label{def:programmtransformation}
Eine \emph{Programmtransformation} $T$ ist eine binäre Relation auf Ausdrücken. 

Eine Programmtransformation $T$ ist korrekt, wenn für zwei Ausdrücke
$s,t$ gilt: 
\[s \; T \; t \Rightarrow s \sim_C t.\]
\end{definition}

%
%%{\color{blue}{Folgende $\Lambda^{let}$-Reduktionen (Programmtransformationen) sind korrekt: ...}}
%
%\begin{lemma}[Letrec-Shifting\label{lem-letrecShifting}]
%Sei $t= \letrecm{Env}{t'}$ und $R$ ein Reduktionskontext.
%\begin{enumerate}
%\item Ist $R$ von der Form $R=\letrecm{Env_R}{R^-}$, wobei $R^-$ ein schwacher
%  Reduktionskontext ist, dann gilt $R[\letrecm{Env}{t'}]\xrightarrow{(n,lll)^+}
%  \letrecm{Env_R,Env}{R^-[t]}$
%\item Ist $R$ von der Form $R = \letrecm{Env_R,x=R^-}{r}$ wobei $R^-$ ein schwacher
%  Reduktionskontext ist, dann gilt $\letrecm{Env_R,x=R^-[\letrecm{Env}{t'}]}{r}
%  \xrightarrow{(n,lll)^+} \letrecm{Env_R,Env,x=R[t']}{r}$ wobei $\letrecm{Env_R,Env,x=R\lochm}{r}$
%  ein Reduktionskontext ist. 
%\item Ist $R$ keine \texttt{letrec}-Ausdruck, d.h. ein schwacher Reduktionskontext, 
%  dann gilt $R[\letrecm{Env}{t'}] \xrightarrow{(n,lll)^*} \letrecm{Env}{R[t']}$, wobei
%  $\letrecm{Env}{R\lochm}$, ein Reduktionskontext ist. 
%\end{enumerate}
%\end{lemma}
%\begin{proof}[Beweis]
%Durch Induktion über die Anzahl der Reduktionen, unter Verwendung der 
%Definitionen von Reduktions- und schwachen Reduktionskontexten, sowie
%(lll)-Reduktionen. 
%\end{proof}

Die Reduktionsregeln des $\Lambda^{let}$-Kalküls sind
Programmtransformationen im Sinne der Definition
\ref{def:programmtransformation}. 

Für manche Reduktionsregeln ist die Korrektheit einfach zu zeigen. 
\begin{proposition}%[Korrektheit von lbeta lapp]
\label{prop:korrekt-lbeta-lapp}
Die Reduktionsregeln \emph{lbeta} und \emph{lapp} sind korrekte
Programmtransformationen. D.h. es gilt 
$s \xrightarrow{a} t \Rightarrow s \sim_{C} t$ für $a \in \set{lbeta,lapp}$.
\end{proposition}
\begin{beweis}
Es sei $s \xrightarrow{a} t$, $a \in \set{lbeta,lapp}$ gegeben. 
Nach dem Kontextlemma reicht es zu zeigen, dass $R[s]\terminates
\Leftrightarrow R[t]\terminates$ für alle Reduktionskontexte $R$
gilt. Nach der Struktur von Reduktionskontexten kann eine $a \in
\set{lbeta,lapp}$ Reduktion in einem Reduktionskontext nur eine 
no-Reduktion sein, d.h. $R[s] \xrightarrow{n,a} R[t]$. 
Da die Normalordnungsreduktion nach Korollar \ref{kor.no-eindeutig}
eindeutig ist, folgt $R[s]\terminates \Leftrightarrow
R[t]\terminates$. Durch Anwendung des Kontextlemmas folgt die
Aussage des Lemmas. $\qed$
\end{beweis}

Um generell die Korrektheit einer Programmtransformation $s \xrightarrow{a} t$ zu
zeigen, muss $s \xrightarrow{a} t \Rightarrow s \sim_C t$ gezeigt werden, 
was nach Definition \ref{def-kontextuellePraeordnung} und dem
Kontextlemma gleichbedeutend ist mit 
$s \xrightarrow{a} t \Rightarrow R[s]\terminates \Leftrightarrow R[t]\terminates$.
Zum Beweis der Korrektheit der Programmtransformation $a$ wird 
angenommen, dass $s \xrightarrow{a} t$ und 
$R[s]\terminates$ 
(bzw. $R[t]\terminates$) %, wir betrachten hier nur die $\Rightarrow$ Implikation). 
gelte.
D.h. für  
$R[s]$ ($R[t]$) existiert eine no-Reduktionsfolge, die mit einem Ausdruck $s'$
in WHNF terminiert. Ausgehend von dieser no-Reduktionsfolge und von $s
\xrightarrow{a} t$ wird induktiv eine terminierende Reduktionsfolge für
$R[t]$ ($R[s]$) konstruiert. Das wesentliche Hilfsmittel zu diesem Vorgehen
sind Diagramme, die die Konstruktion von terminierenden
Reduktionsfolgen während der Induktion ermöglichen. 
%Ist $R[s]\terminates$ gegeben, wird ein vollst\"andiger Satz von
%Gabeldiagrammen ben\"otigt. Ist $R[t]\terminates$ gegeben, wird ein
%vollst\"andiger Satz von Vertauschungsdiagrammen ben\"otigt. 

%Für eine korrekte Programmtransformation $t \rightarrow s$ gilt, 
%dass $t$ und $s$ kontextuelle äquivalent sind. 
%Die Reduktionsrelgen des $\Lambda^{let}$-Kalküls sind
%Programmtransformationen im Sinne der Definition
%\ref{def:programmtransformation}. Um für die Reduktionsreglen zu
%zeigen, dass sie korrekte Programmtransformationen sind, muss
%überprüft werden ob $t \xrightarrow{a} s \Rightarrow t \sim_{C} t'$,
%für alle Reduktionsregeln $a$ des Kalküls gilt. 
%Die zwei wichtigsten Hilfsmitell um die Korrektheit von
%Programmtransformationen zu zeigen, sind das Kontextlemma
%(\ref{lem:kontextlemma}), das die Klasse der zu betrachtenden Kontexte
%einschränkt und Diagramme, die es zusammen mit einem induktiven
%Vorgehen ermöglichen, terminierende Reduktionsfolgen zu 
%konstruieren. 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Vertauschungs- und Gabeldiagramme}
\label{sec:diagramme}
%% Interne Reduktionen 
\begin{notation}%[Interne Reduktionen]
\label{not:interne-reduktionen}
Reduktionen, die keine no-Reduktionen sind, werden \emph{interne Reduktionen}
genannt und mit $\xrightarrow{i}$ bezeichnet. Findet eine interne
Reduktion in einem bestimmten Kontext statt, schreiben wir den Kontext
mit an den Pfeil, beispielsweise $\xrightarrow{iC}$ für eine interne
Reduktion in einem allgemeinen Kontext. 
\end{notation}

Interne Reduktionen sind von besonderem Interesse, weil für
eine no-Reduktion $s \xrightarrow{n,a} t$ gilt 
$R[s] \xrightarrow{n,a} R[t]$ für alle Reduktionskontexte $R$ und, da
die no-Reduktion eindeutig ist, (Korollar \ref{kor.no-eindeutig}) haben
wir $R[s]\terminates \Leftrightarrow R[t]\terminates$. 
Dies gilt für interne Reduktionen i.A. nicht (außer für
$(iR,lbeta)$ und $(iR,lapp)$ wie wir in Proposition
\ref{prop:korrekt-lbeta-lapp} gesehen haben).

%% Diagramme 
\begin{definition}%[Reduktionsfolge, Transformation auf %Reduktionsfolge]
\label{def:transform-von-red-folgen}
Eine Transformation auf Reduktionsfolgen hat die Form 
\[\xrightarrow{iX, red} \cdot \xrightarrow{n,a_1} \cdot \; \dots \;
\cdot \xrightarrow{n,a_k} \quad \leadsto \quad 
\xrightarrow{n, b_1} \cdot \; \dots \; \cdot \xrightarrow{n,b_m}
\cdot \xrightarrow{iX,red_1} \cdot \; \dots \; \cdot
\xrightarrow{iX,red_h},\]
wobei $red$ eine $\Lambda^{let}$-Reduktion aus Definition
\ref{def:reduktionen} ist und $iX \in \{iC,iS,iR\}$. 
%Obige Regel kann auf die Reduktionsfolge $RED$ angewandt werde,	
%wenn deren Präfix folgende Form hat: 
%\[s \xrightarrow{iX,red} t_1 \xrightarrow{n,a_1} t_2 \dots  t_k \xrightarrow{n,a_k} t.\]

Eine Transformation
\[\xrightarrow{iX, red} \cdot \xrightarrow{n,a_1} \cdot \; \dots \;
\cdot \xrightarrow{n,a_k} \quad \leadsto \quad 
\xrightarrow{n, b_1} \cdot \; \dots \; \cdot \xrightarrow{n,b_m}
\cdot \xrightarrow{iX,red_1} \cdot \; \dots \; \cdot
\xrightarrow{iX,red_h}\]
ist \emph{anwendbar} auf den Präfix einer Reduktionsfolge \emph{RED}
\[s \xrightarrow{iX,red} t_1 \xrightarrow{n,a_1} t_2 \dots  t_k \xrightarrow{n,a_k} t\] 
wenn Ausdrücke $y_1, \dots y_m, z_1, \dots z_{h-1}$ existieren,
so dass
\[s \xrightarrow{n,b_1} y_1 \dots y_{m-1} \xrightarrow{n,b_m} y_m 
\xrightarrow{iX,red_1} z_1 \dots z_{h-1} \xrightarrow{iX, red_h} t\] 
gilt. 
Die Transformation besteht aus dem Ersetzen des Präfixes mit dem
Resultat: 
\[s \xrightarrow{n,b_1} t'_1 \dots t'_{m-1} \xrightarrow{n,b_m} t'_m 
\xrightarrow{iX,red_1} t''_1 \dots t''_{h-1} \xrightarrow{iX, red_h}t,\] 
wobei die Ausdrücke $t'_i, t''_j$ durch die entsprechenden $b_i$-,
$red_j$-Reduktionen entstehen.
\end{definition}

\begin{definition}[Vollständiger Satz von Vertauschungsdiagrammen]
\label{def-vertauschungsDiagramm}
Zur Reduktion $\xrightarrow{iX,red}$ ist ein vollständiger Satz von
Vertauschungsdiagrammen gegeben durch eine Menge von Transformationen
auf Reduktionsfolgen der Form 
\[\xrightarrow{iX, red} \cdot \xrightarrow{n,a_1} \cdot \; \dots \;
\cdot \xrightarrow{n,a_k} \quad \leadsto \quad 
\xrightarrow{n, b_1} \cdot \; \dots \; \cdot \xrightarrow{n,b_m}
\cdot \xrightarrow{iX,red_1} \cdot \; \dots \; \cdot
\xrightarrow{iX,red_{k'}}\]
mit $k,k' \geq 0, m \geq 1$, so dass für jede Reduktionsfolge
$t_0 \xrightarrow{iX,red} t_1 \xrightarrow{n} \dots \xrightarrow{n}
t_l$, wobei $t_l$ eine WHNF ist, mindestens eine der
Transformationsregeln auf einen Präfix der Reduktionsfolge anwendbar
ist. 

Für den Fall $l=1$ muss $t_0 \xrightarrow{iX,red} t_1$ so aussehen, dass
$t_0$ keine WHNF und $t_1$ eine WHNF ist.
\end{definition}

Zur Vereinfachung der Notation werden Vertauschungsdiagramme in
Diagrammform dargestellt. Beispielsweise wird das Vertauschungsdiagramm 
$\xrightarrow{iS,llet} \cdot \xrightarrow{n,a} \quad \leadsto \quad
\xrightarrow{n,a} \cdot \xrightarrow{iS,llet}$ repräsentiert durch 
\[\xymatrix@R=1cm@C=1cm{%Vierecke
\cdot \ar@{.>}[d]_{n,a} \ar@{->}[r]^{iS,llet} & \cdot \ar@{->}[d]_{n,a} \\
\cdot \ar@{.>}[r]^{iS,llet} & \cdot \\
}\]
wobei die durchgezogenen Pfeile die gegebenen Reduktionen der linken
Seite der Transformationsregeln und die gestrichelten Pfeile die
existierenden Reduktionen der rechten Seite der Transformationsregel
darstellen. 
Eine Variable $a$ für den Namen einer Reduktionsregel, die mehrmals
in einem Diagramm vorkommt, symbolisiert überall die gleiche
Reduktionsregel.

Anstatt einer Reduktion $\xrightarrow{a}$ kann in einem Diagramm auch
die transitive Hülle $\xrightarrow{a^+}$ (bzw. die
reflexiv-transitive Hülle) einer Reduktion stehen. 

\begin{definition}[Vollständiger Satz von Gabeldiagrammen]
\label{def-gabelDiagramm}
Zur Reduktion $\xrightarrow{iX,red}$ ist ein vollständiger Satz von
Gabeldiagrammen gegeben durch eine Menge von Transformationen auf
Reduktionsfolgen der Form 
\[\xleftarrow{n, a_1} \cdot \; \dots \; \cdot \xleftarrow{n,a_k} 
\cdot \xrightarrow{iX,red} \quad \leadsto \quad 
\xrightarrow{iX,red_1} \cdot \; \dots \; \cdot \xrightarrow{iX,red_{k'}}
\cdot \xleftarrow{n,b_1} \cdot \; \dots \; \cdot
\xleftarrow{n,b_m}\]
mit $k,k' \geq 0, m \geq 1$, so dass für jede Reduktionsfolge
$t_l \xleftarrow{n} \dots t_2 \xleftarrow{n} t_1 \xrightarrow{iX,red}
t_0$, $l > 1$, wobei $t_l$ eine WHNF ist, mindestens eine der
Transformationsregeln auf einen Suffix der Reduktionsfolge anwendbar
ist.

Für den Fall $l=1$ muss $t_1 \xrightarrow{iX,red} t_0$ so aussehen, dass
$t_1$ eine WHNF und $t_0$ keine WHNF ist.
\end{definition}

Für Gabeldiagramme verwenden wir ebenfalls eine vereinfachte
Schreibweise. Beispielsweise wird das Gabeldiagramm 
$\xleftarrow{n,a} \cdot \xrightarrow{iS,llet} \quad \leadsto \quad
\xrightarrow{iS,llet} \cdot \xleftarrow{n,a}$ repräsentiert durch 
\[\xymatrix@R=1cm@C=1cm{%Vierecke
\cdot \ar@{->}[d]_{n,a} \ar@{->}[r]^{iS,llet} & \cdot \ar@{.>}[d]_{n,a} \\
\cdot \ar@{.>}[r]^{iS,llet} & \cdot \\
}\]

In den meisten Fällen können dieselben Diagramme für eine
vollständige Menge von Gabel- und eine vollständige Menge von 
Vertauschungsdiagrammen verwendet werden. Mit dem Unterschied, an 
welcher Seite sich die existensquantifizierten Reduktionen befinden 
(siehe \citeA{sabel_semantics_2008}, S. 113.)
Aus diesem Grund ist es meistens ausreichend, sich bei der Erstellung
eines vollständigen Diagrammsatzes entweder auf Gabel- oder
Vertauschungsdiagramme zu konzentrieren. Der jeweils andere Satz kann
dann durch Rückgriff auf den bereits vorhanden Satz
gewonnen werden. In dieser Arbeit konzentrieren wir uns auf
Gabeldiagramme. 

\subsection{Berechnung von Überlappungen für Gabeldiagramme}
\label{sec:berechn-von-uberl}
Um die Vollständigkeit eines Satzes von Gabeldiagrammen für eine
interne Reduktion $red$ zu zeigen, müssen alle Gabelungen der Form 
$\xleftarrow{n,a} \cdot \xrightarrow{iS,red}$,\footnote{Nach dem
  Kontextlemma ist es eigentlich ausreichend, interne Reduktionen in
  Reduktionskontexten zu betrachten. Zum Schließen von Diagrammen ist
  es aber in manchen Fällen notwendig, interne Reduktionen 
  in den etwas allgemeineren Oberflächenkontexten zu betrachten.}
wobei $a$ eine beliebige 
no-Reduktion ist, betrachtet werden. Dazu müssen alle Überlappungen
zwischen der no-Reduktion $a$ und $red$ bestimmt werden.
%d.h. alle Positionen in $a$ an denen $red$ vorkommen kann.
Informell definieren wir Überlappungen folgendermaßen: Die
Ausdrücke $s,t$ \emph{überlappen} in einem Ausdruck 
$u$, wenn $s$ und $t$ beides Unterausdrücke von $u$ sind (d.h. sie
kommen in $u$ vor). Zwei Reduktionen $a,b$ überlappen in $u$, wenn
$s$ ein $a$-Redex ist und $t$ ein $b$-Redex und beide Redexe im
Ausdruck $u$ vorkommen.\footnote{Eine formale Definition ist an
    dieser Stelle schwierig, weil Begriffe wie Substitution und
    Positionen eines Ausdrucks nicht zur Verfügung stehen.
    Eine formale Definition des Überlappungsbegriffs wird in Kapitel \ref{cha:berechn-von-uberl}
    gegeben.}
Wenn alle möglichen Überlappungen zwischen einer no-Reduktion $a$
und einer internen Reduktion $red$ bestimmt werden sollen, kann man
sich aufgrund der Struktur von Reduktionskontexten und der
Normalordnungsreduktion darauf beschränken, alle Positionen in $a$ zu
bestimmen, an denen ein $red$-Redex vorkommen kann.
(Da $a$ eine no-Reduktion ist, ist die Struktur des $(n,a)$-Redexes
$s$ festgelegt auf $R[s]$, wobei $R$ ein Reduktionskontext ist. 
Der $(iS,red)$-Redex $t$ kann dann in $R$ oder in $s$ vorkommen.) 
Sind alle Überlappungen zwischen den $(n,a)$-Reduktionen und der
internen Reduktion $red$ bestimmt, dann
müssen die Gabeln noch geschlossen werden. Dabei muss unter
anderem überlegt werden, ob die Reduktion des internen
Redexes den betrachteten no-Redex in einem
Reduktionskontext belässt. 
Wir geben ein Beispiel, welche Überlegungen bezüglich Gabeldiagrammen
angestellt werden müssen (für eine bestimmte no-Reduktion $a$, nicht
für einen vollständigen Satz). 

\begin{beispiel}
\label{bsp:alle-gabeln}
\sloppy
Wir betrachten als interne Reduktion eine \emph{llet-in}-Reduktion und
als no-Reduktion eine \emph{lapp}-Reduktion, deren Redex die Form 
$R[(\letrecm{Env}{s}\; t)]$ hat. D.h. die Gabelung hat die Form 
$\xleftarrow{n,lapp} \cdot \xrightarrow{iS,\emph{llet-in}}$. 
Die Positionen, an denen der interne
\emph{llet-in}-Redex im no-Redex vorkommen kann, sind:
In $R$, $Env$, $s$ oder $t$ oder der interne Redex kann mit dem
\letr-Ausdruck des no-Redexes überlappen: %in folgender Form:
\newcommand{\saa}{\letrecm{Env}{\letrecm{Env'}{s'}}}
$R[(\saa \; t)]$.
Für die ersten vier Fälle können die zugehörigen Gabeldiagramme
jeweils durch 
$\xrightarrow{iS,\emph{llet-in}} \cdot \xleftarrow{n,lapp}$ geschlossen werden, da die
Reduktion des internen Redexes keinen Einfluss auf den no-Redex hat, 
d.h. eine Reduktion des internen Redexes belässt den no-Redex in
einem Reduktionskontext und somit bleibt dieser no-reduzierbar. 
Ebenso wenig wird der interne Redex durch die Reduktion des no-Redex
beeinflusst. 
Für diese Fälle ergibt sich folgendes Gabeldiagramm:
\[\xymatrix@R=1cm@C=1cm{%Vierecke
\cdot \ar@{->}[d]_{n,lapp} \ar@{->}[r]^{iS,\emph{llet-in}} & \cdot \ar@{.>}[d]_{n,lapp} \\
\cdot \ar@{.>}[r]^{iS,\emph{llet-in}} & \cdot \\
}\]

Für den letzten Fall kann das Diagramm folgendermaßen geschlossen
werden:

\newcommand{\taa}{\letrecm{Env, Env'}{s'}}
\[\begin{array}{rlr}
& R[(\saa \; t)] &  \\
\xrightarrow{iS, \emph{llet-in}} & R[(\taa \; t)] & \\
\xrightarrow{n, \emph{lapp}} & R[(\letrecm{Env, Env'}{(s' \; t)}] & \\
\xrightarrow{(n, \emph{lll})^*} & \letrecm{Env, Env'}{R[(s' \; t)]} & \\ \hline
& R[(\saa \; t)] & \\
\xrightarrow{n, \emph{lapp}} & R[\letrecm{Env}{(\letrecm{Env'}{s'} \; t)}] & \\
\xrightarrow{(n, \emph{lll})^*} & \letrecm{Env}{R[(\letrecm{Env'}{s'} \; t)]} & \\
\xrightarrow{n, \emph{lapp}} & \letrecm{Env}{R[\letrecm{Env'}{(s' \; t})]} & \\
\xrightarrow{(n, \emph{lll})^*} & \letrecm{Env}{\letrecm{Env'}{R[(s' \; t)]}} & \\
\xrightarrow{n, \emph{let-in}} & \letrecm{Env, Env'}{R[(s' \; t)]}] & \\
\end{array}
\]

Das zugehörige Gabeldiagramm ist
\begin{equation}
\label{eq:1}
\xymatrix@R=1cm@C=1cm{%Vierecke
\cdot \ar@{->}[d]_{(n,lll)^+} \ar@{->}[r]^{iS,\emph{llet-in}} & \cdot \ar@{.>}[dl]^{(n,lll)^+} \\
\cdot \\ %\ar@{.>}[r]^{iS,llet} & \cdot \\
}\end{equation}

Zum Schließen des Diagramms wird hier die Tatsache verwendet, dass
\letr-Ausdrücke in einem Reduktionskontext durch wiederholte Anwendung von 
$(n,lll)$-Reduktionen an die oberste Position gebracht werden
können. 
\begin{lemma}%[Letrec-Shifting]
\label{lem-letrecShifting}
\sloppy
Sei $t= \letrecm{Env}{t'}$ ein Ausdruck und $R$ ein Reduktionskontext.
%Es gilt
\begin{enumerate}
%\item $R^-[\letrecm{Env'}{t}] \xrightarrow{(n,lll)^*} \letrecm{Env'}{R^-[t]}$.
%\item 
\item Ist $R$ von der Form $R=\letrecm{Env'}{R'}$, wobei $R'$ ein schwacher
  Reduktionskontext ist, dann gilt $R[\letrecm{Env}{t'}]\xrightarrow{(n,lll)^+}
  \letrecm{Env',Env}{R'[t]}$.
\item Ist $R$ von der Form $R = \letrecm{Env',x=R'}{r}$, wobei $R'$ ein schwacher
  Reduktionskontext ist, dann gilt $R[\letrecm{Env}{t'}]
  \xrightarrow{(n,lll)^+} \letrecm{Env',Env,x=R'[t']}{r}$, wobei
  $\letrecm{Env',Env,x=R'\lochm}{r}$  ein Reduktionskontext ist. 
\item Ist $R$ kein \texttt{letrec}-Ausdruck, d.h. ein schwacher Reduktionskontext, 
  dann gilt $R[\letrecm{Env}{t'}] \xrightarrow{(n,lll)^*} \letrecm{Env}{R[t']}$, wobei
  $\letrecm{Env}{R\lochm}$ ein Reduktionskontext ist. 
\end{enumerate}
\end{lemma}
\begin{beweis}
Siehe \cite{schmidt-schauss_safety_2007}, Lemma 2.5. $\qed$
\end{beweis}

Das Diagramm für die Überlappung $R[(\saa \; t)]$ kann aber noch auf
eine andere Weise geschlossen werden: 
\[\begin{array}{rlr}
& R[(\saa \; t)] &  \\
\xrightarrow{iS, \emph{llet-in}} & R[(\taa \; t)] & \\
\xrightarrow{n, \emph{lapp}} & R[(\letrecm{Env, Env'}{(s' \; t)}] & \\ \hline
%\xrightarrow{(n, \emph{lll})^*} & \letrecm{Env, Env'}{R[(s' \; t)]} & \\ \hline
& R[(\saa \; t)] & \\
\xrightarrow{n, \emph{lapp}} & R[\letrecm{Env}{(\letrecm{Env'}{s'} \; t)}] & \\
\xrightarrow{iS \wedge n, \emph{lapp}} & R[\letrecm{Env}{\letrecm{Env'}{(s' \; t)}}] & \\
\xrightarrow{iS \wedge n, \emph{llet-in}} & R[\letrecm{Env,Env'}{(s' \; t)}] & \\

%\xrightarrow{(n, \emph{lll})^*} & \letrecm{Env}{R[(\letrecm{Env'}{s'} \; t)]} & \\
%\xrightarrow{n, \emph{lapp}} & \letrecm{Env}{R[\letrecm{Env'}{(s' \; t})]} & \\
%\xrightarrow{(n, \emph{lll})^*} & \letrecm{Env}{\letrecm{Env'}{R[(s' \; t)]}} & \\
%\xrightarrow{n, \emph{let-in}} & \letrecm{Env, Env'}{R[(s' \; t)]}] & \\
\end{array}
\]
Die beiden letzten Reduktionen sind no-Reduktionen falls $R =
\lochm$, sonst sind es interne Reduktionen. 
Die entsprechenden Gabeldiagramme sind 
\begin{equation}
\label{eq:2}
\xymatrix@R=1cm@C=1cm{%Vierecke
\cdot \ar@{->}[d]_{n,lapp} \ar@{->}[r]^{iS,\emph{llet-in}} & \cdot \ar@{.>}[d]_{n,lapp} \\
\cdot \ar@{.>}[r]^{(iS,lll)^+} & \cdot \\
} \quad
\xymatrix@R=1cm@C=1cm{%Vierecke
\cdot \ar@{->}[d]_{(n,lll)^+} \ar@{->}[r]^{iS,\emph{llet-in}} & \cdot \ar@{.>}[dl]^{n,lapp} \\
\cdot \\ %\ar@{.>}[r]^{iS,llet} & \cdot \\
}\end{equation}

Man hat die Wahl, das Diagramm (\ref{eq:1}) oder die beiden Diagramme
(\ref{eq:2}) in einen Satz vollständiger Gabeldiagramme aufzunehmen. 
%(für die Kontstruktion einer terminierenden no-Reduktionsfolge ist 
%das Diagramm (\ref{eq:2}) i.A. besser geeignet, da eine terminierende
%Reduktionsfolge direkt abgelesen )
Beide Diagramme sind auf den Suffix aller Transformationsfolgen der Form 
$\dots, \xleftarrow{n,a} \cdot \xleftarrow{n,lapp} \cdot
\xrightarrow{iS,\emph{llet-in}}$ anwendbar. 
\end{beispiel}

Um einen vollständigen Satz von Gabeldiagrammen für die 
interne \emph{llet-in}-Reduktion zu erhalten, muss das Vorgehen aus
Beispiel \ref{bsp:alle-gabeln} für alle weiteren no-Reduktionen 
wiederholt werden, was zu einer komplizierten Fallunterscheidung
%allein für die Bestimmung aller überlappungen 
führt. 

Sätze vollständiger Diagramme werden in einer Vielzahl von Arbeiten
zum Beweis der Korrektheit von Programmtransformationen verwendet. 
\cite{kutzner_ein_2000,schmidt-schauss_fundio:lambda-calculus_2003,sabel_realisierung_2003,schmidt-schauss_safety_2007,sabel_semantics_2008}.
Die Argumentation, dass es sich bei einer Menge von Gabel- oder
Vertauschungsdiagrammen um einen vollständigen Satz von Diagrammen handelt,
basiert in diesen Arbeiten auf Fallanalysen und wird durch typische
Beispiele (wie in Beispiel \ref{bsp:alle-gabeln} zu sehen) illustriert. 
%In der Regel wird für Vertauschungsdiagramme anhand von
%Fallunterscheidungen argumentiert, dass eine bestimmte Menge von
%Diagrammen einen vollständigen Satz von Vertauschungsdiagrammen
%repräsentiert. 
Die Vollständigkeitsbeweise variieren stark in ihrer
Ausführlichkeit und Abstraktion: Von sehr ausführlich, wie beispielsweise
in \citeA{sabel_realisierung_2003}, bis sehr knapp, bzw. ohne Beweis der
Vollständigkeit etwa in \citeA{schmidt-schauss_safety_2007}.
Das generelle Problem der Validierung eines vollständigen
Satzes von Gabeldiagrammen von Hand ist, dass im Prinzip  
alle Überlappungen zwischen einer internen Reduktion und allen
möglichen no-Reduktionen berücksichtigt werden müssen. Dies 
funktioniert nicht, da es unendlich viele Überlappungen gibt, weil der
interne Redex beliebig tief in einem Oberflächenkontext stehen kann.
Aus diesem Grund beschränkt man sich bei der Fallunterscheidung auf
typische Fälle, was dazu führen kann, dass andere vorkommende Fälle
übersehen werden.  

In dieser Arbeit wird anhand des
$\Lambda^{let}$-Kalküls untersucht, ob eine Berechnung von
vollständigen Sätzen von Gabeldiagrammen möglich ist. 
%Dazu konzentrieren wir uns auf Gabeldiagramme. 
Für die Berechnung eines Gabeldiagramms 
zu einer internen Reduktion $red$ müssen zunächst alle Gabelungen 
$\xleftarrow{n,a} \cdot \xrightarrow{iS,red}$ für alle no-Reduktionen
$a$ bestimmt werden. Dazu müssen alle Überlappungen zwischen der
no-Reduktion $a$ und der internen Reduktion $red$ berechnet werden. 
Wie wir in Beispiel \ref{bsp:alle-gabeln} gesehen haben, sind 
manche Überlappungen einfacher zu schließen als andere: 
Die Fälle, in denen die interne \emph{llet-in}-Reduktion 
innerhalb einer Meta- oder Kontextvariablen der no-Reduktion
auftaucht, 
%beispielsweise 
%$R[(\letrecm{Env}{s}\; \letrecm{Env_1}{\letrecm{Env_2}{t}})]$
sind alle durch das gleiche einfache Gabeldiagramm
schließbar. Der Grund hierfür ist, dass in solchen Fällen die
Reduktion eines Redex nicht mit der Reduktion des anderen Redex
interferiert. Außerdem verbleibt der no-Redex durch die Reduktion des
internen Redex in einem Reduktionskontext. 
Solche Fälle, bei denen der interne Redex innerhalb einer Metavariablen
oder einer Kontextvariablen des no-Redex auftaucht, werden als
\emph{Schachtelung} (und nicht als Überlappung) von Reduktionen
bezeichnet.  

\begin{lemma}
\label{lemma:schachtelung-von-redexen}
Für alle no-Reduktionen $a$ und alle Reduktionen $red$ gilt:
Wenn sich die Gabelung $\xleftarrow{n,a} \cdot \xrightarrow{iS,red}$
durch eine Schachtelung der no-Reduktionen $a$ mit der internen
Reduktion $red$ ergibt, dann kann das Diagramm geschlossen werden
durch $\xrightarrow{iS,red} \cdot \xleftarrow{n,a}$
oder $\xrightarrow{no,red} \cdot \xleftarrow{n,a}$.
\end{lemma}
\begin{beweis}
Die Reduktionen der beiden Redexe interferieren nicht miteinander,
was durch Fallunterscheidung über die möglichen no-Reduktionen $a$
gezeigt werden kann. 
Der zweite Fall $\xrightarrow{no,red} \cdot \xleftarrow{n,a}$ tritt
auf, wenn sich der iS-Redex nach der no-Reduktion in einem
Reduktionkontext befindet und dadurch zu einem no-Redex wird. 
$\qed$
\end{beweis}

Bei der Berechnung aller Überlappungen müssen also solche
Schachtelungen nicht mit berechnet werden, da sie immer durch  
Standarddiagramme der Form
\[\xymatrix@R=1cm@C=1cm{%Vierecke
\cdot \ar@{->}[d]_{n,a} \ar@{->}[r]^{iS,red} & \cdot \ar@{.>}[d]_{n,a} \\
\cdot \ar@{.>}[r]^{iS,red} & \cdot \\
}\quad 
\xymatrix{
\cdot \ar@{->}[rr]^{iS,red} \ar@{.>}[d]_{no,a} & & \cdot \ar@{.>}[ddll]^{no,a} \\
\cdot \ar@{.>}[d]_{no,red} & & \\
\cdot & & \\
}\]

geschlossen werden können. 
Wenn sich die no-Reduktion $a$ und die interne Reduktion $red$ ein
Symbol teilen, das keine Meta- oder Kontextvariable ist\footnote{Im
  Beispiel \ref{bsp:alle-gabeln} teilen sich der $(n,lapp)$-Redex und
  der $(iS,\emph{llet-in})$-Redex das \letr-Symbol in 
  \newcommand{\saa}{\letrecm{Env}{\letrecm{Env'}{s'}}} $R[(\saa \; t)]$.}, 
dann ist nicht direkt offensichtlich, wie das Gabeldiagramm geschlossen werden
kann. Bei der Berechnung von Überlappungen konzentrieren wir uns auf  
solche Fälle. 

Um alle Überlappungen einer internen Reduktion $red$ mit
no-Reduktionen $a$ zu berechnen, gehe folgendermaßen vor:
Die Form der internen Reduktion ist durch die Definition der
Reduktionsregeln gegeben. Sei $l(red)$ die linke Seite der entsprechenden
Reduktionsregel. Der interne Redex ist eine Instanz dieser linken
Seite. Der $(n,a)$-Redex besitzt keine direkte Entsprechung in der
linken Seite einer Reduktionsregel. Um die genaue Form des no-Redex zu
bestimmen, muss auf die Definition der Normalordnung und die Struktur
von Reduktionskontexten zurückgegriffen werden. Es ist möglich, dass
ein $(n,a)$-Redex mehrere verschiedene Formen hat. Beispielsweise
sind für eine $(n,lapp)$-Reduktion die Formen 
\begin{itemize}
\item $R^-[(\letrecm{Env}{s} \; t)]$, oder 
\item $\letrecm{E'}{R^-[(\letrecm{Env}{s} \; t)}]$, oder 
\item $\letrecms{x_1 = R^-_1[(\letrecm{Env}{s} \; t), x_2=R^-_2[x_1], \dots, x_{j}=R^-_j[x_{j-1}]}{R^-[x_j]}$ 
\end{itemize}
für den $(n,lapp)$-Redex möglich, (wobei $R^-,R^-_i$ jeweils schwache
Reduktionskontexte sind).  
Sei $ar$ eine mögliche Variante des $(no,a)$-Redex. Um alle 
Überlappungen mit dem internen Redex zu bestimmen, müssen alle 
Positionen in $ar$ bestimmt werden, an denen der interne Redex
vorkommen kann. Dies kann berechnet werden, indem alle Unterausdrücke
von $ar$, die keine Meta- oder Kontextvariablen sind, mit $l(red)$
unifiziert werden. Dabei beschränken wir uns auf Überlappungen in 
Oberflächenkontexten, d.h. $l(red)$ wird nicht mit einem
Unterausdruck von $ar$ unifiziert, der im Rumpf einer Abstraktion
vorkommt. Die zu \"uberlappenden Ausdr\"ucke werden vor der Unifikation
so umbenannt, dass sie variablendisjunkt sind.
Um alle Überlappungen mit der internen Reduktion
$red$ zu berechnen, muss dieses Vorgehen für alle no-Reduktionen $a$
und für alle spezifischen $(n,a)$-Redexe $ar$ durchgeführt
werden.\footnote{Das Vorgehen zur Berechnung von Überlappungen
  orientiert sich an der Berechnung kritischer Überlappungen in der Theorie
  der Termersetzungssysteme \cite{baader_term_1998}, \cite{bezem_term_2003}.}

Zur Realisierung dieses Vorgehens wird \emph{Unifikation} für 
$\Lambda^{let}$-Ausdrücke mit Meta-Notation benötigt. 
In der Literatur \cite{baader_unification_2001} wird Unifikation im
Rahmen von Termen behandelt, und nicht bezüglich Ausdrücken. 
Aus diesem Grund übersetzen wir $\Lambda^{let}$-Ausdrücke mit 
Metavariablen in ein Kalkül mit Termen, in dessen Rahmen die
Unifikation zur Berechnung der Überlappungen durchgeführt werden
kann. 
Bei der Unifikation sind eine Reihe von Problemen zu bewältigen:
\begin{enumerate}
\item Die Metavariablen in $\Lambda^{let}$ verfügen über Typen:
  In den Reduktionsregeln stehen $s,t$ für beliebige Ausdrücke, 
  $v$ symbolisiert nur Abstraktionen. 
  Wie diese bei der Unifikation berücksichtigt werden, wird in
  Kapitel \ref{cha:unif-fur-terme-mit-sorten} dargelegt. 
\item Bindungen innerhalb von \letr-Umgebungen sind vertauschbar. 
  Auf die Unifikationsmethoden dazu wird in Kapitel \ref{cha:ac-unifikation}
  eingegangen. 
\item Die (\emph{cp})-Reduktionsregeln enthalten Variablenketten
  beliebiger L\"angen und stellen somit Regelschemata f\"ur eine
  (abz\"ahlbar unendliche) Menge von Regeln dar. Wie das
  Ketten-Konstrukt bei der Unifikation behandelt werden kann, wird in
  Kapitel \ref{cha:unif-von-ketten} beschrieben.  
\item Die zu unifizierenden Ausdrücke enthalten Kontextvariablen. Was 
  zu deren Unifikation notwendig ist, wird in Kapitel \ref{cha:unif-von-kontexten}
  dargelegt. 
\end{enumerate}

\chapter{Unifikation für Terme mit Sorten}
\label{cha:unif-fur-terme-mit-sorten}
%\section{Unifikation für Terme mit Sortinformation}
Um kritische Überlappungen zwischen Ausdrücken des Ursprungskalküls
$\Lambda^{let}$, der \"uber die Konstrukte Abstraktion, Applikation und
\letr$\;$verf\"ugt, zu berechnen, müssen Ausdrücke des Kalküls syntaktisch
gleich gemacht werden. Die Methode, die man verwendet, um Ausdrücke
miteinander zu identifizieren, heißt \emph{syntaktische Unifikation}. 
Man betrachtet \emph{Terme}, die rekursiv
konstruiert werden aus Variablen und der Anwendung von
Funktionssymbolen auf Terme. 
Ein \emph{Unifikationsproblem} für zwei Terme
$s = f(a,x)$ und $t = f(y,b)$ stellt die Frage, ob es möglich ist, die
Variablen $x,y$ in $t$ und $s$ durch Terme zu ersetzen, so dass die
resultierenden Terme syntaktisch gleich sind. Im Beispiel 
$f(a,x) \ue f(y,b)$ ist $\set{x \mapsto b, y \mapsto a}$ eine
\emph{Lösung} -- eine \emph{Substitution}, die $s$ mit $t$
identifiziert, auch \emph{Unifikator} genannt -- für das
Unifikationsproblem. Der \emph{unifizierte} Term ist $f(a,b)$. 
Für ein Unifikationsproblem kann es mehrere Lösungen
geben. Betrachtet man beispielsweise $f(x,y) \ue f(y,x)$, dann
repräsentiert $\tau = \set{x \mapsto a, y \mapsto a}$ eine Lösung. Eine
\emph{allgemeinere Lösung} ist allerdings $\sigma = \set{x \mapsto y}$, da
$\set{x \mapsto a, y \mapsto a} = \set{y \mapsto a} \sigma$. Man sagt,
$\tau$ kann durch \emph{Instantiierung} von $\sigma$ gewonnen werden;
$\sigma$ ist in diesem Fall ein \emph{allgemeinster Unifikator} (mgu). 
Allgemeinste Unifikatoren vereinfachen die
Berechnung von Lösungen eines Unifikationsproblems, da alle Lösungen
eines Problems als Instanzen einer allgemeinsten Lösung gewonnen
werden können. Aus diesem Grund muss nicht die Menge aller Lösungen
eines Unifikationsproblems berechnet werden, sondern die Berechnung der
wesentlich kleineren Menge der allgemeinsten Lösungen ist ausreichend. 

Ausdrücke des $\Lambda^{let}$-Kalküls, 
%mit Abstraktion, Applikation und \letr, 
die
keine Kontextvariablen  enthalten (da diese Variablen
höherer Ordnung sind und in einem späteren Kapitel behandelt werden), können
als Terme aufgefasst werden. Beispielsweise kann der Ausdruck 
$\letrecm{E,x=v}{t}$ geschrieben werden als
$letrec(umg(E,bind(x,v)),t)$, wobei $letrec, umg$ und $bind$ jeweils
zweistellige Funktionssymbole, $E,x,v$ und $t$ Variablen sind. Der
Beispielterm unterliegt allerdings stärkeren Restriktionen als
normale Terme erster Ordnung, da die Funktionssymbole und Variablen
Typen besitzen. Das $letrec$-Funktionssymbol erwartet als erstes
Argument einen Term, der eine Umgebung repräsentiert. 
Für einen beliebigen anderen Term als erstes Argument, der keine
Umgebung darstellt, ist das $letrec$-Funktionssymbol nicht definiert. Auf 
syntaktischer Ebene bezeichnet man Typen als \emph{Sorten}. Mit Hilfe von
Sortensymbolen lässt sich der Definitions- und Wertebereich von
Funktionssymbolen syntaktisch beschreiben. Dem
$letrec$-Funktionssymbol ist beispielsweise die Sorte 
$letrec : Umgebung \rightarrow Term \rightarrow Term$ zugeordnet. 
Die Sortensymbole stehen in Relation zueinander, der sogenannten 
\emph{Subsortrelation}. Ist z.B. $Abstraktion$ (verkürzt geschrieben
als $A$) eine Subsorte von $Term$ ($T$), 
geschrieben als $A \sqsubset T$, so ist die intuitive
Bedeutung, dass alle Terme der Sorte $A$ auch Term der Sorte
$T$ sind. Diese Sorten- und Subsorteninformation gilt es bei der
Unifikation zu berücksichtigen. Für ein Unifikationsproblem
zwischen einer Variablen der Sorte $A$ und einer Variablen der Sorte
$T$, geschrieben als $x_A \ue t_T$, ist 
$\set{x_A \mapsto t_T}$ keine zu akzeptierende Lösung, da für eine
Abstraktionsvariable nur Terme der Sorte $R$ substituiert werden
dürfen, wobei $R$ entweder die Sorte $A$ oder eine Subsorte
desselben ist. Die Substitution $\set{t_T \mapsto x_A}$ ist eine
Lösung, für die diese Bedingung erfüllt ist, da  
$A \sqsubset T$ gilt. Eine Substitution, die diese Bedingung erfüllt, wird
als \emph{wohlsortiert} bezeichnet. 

Bei der Unifikation von Termen mit Sorten sollen
allgemeinste, wohlsortierte Unifikatoren berechnet werden. 
Ein Unifikationsalgorithmus wird gewöhnlich als eine Menge von
\emph{Transformationsregeln} präsentiert, die ein Unifikationsproblem
schrittweise in ein Problem in \emph{gelöster Form} transformieren, aus
dem eine allgemeinste, wohlsortierte Lösung direkt abgelesen werden
kann. 
Dabei sollen die Transformationsschritte die Menge der Lösungen des
Unifikationsproblems nicht verändern, was als \emph{Vollständigkeit}
bezeichnet wird. 
Eine wichtige Frage, die man sich im Bezug auf
den Transformationsprozess stellt ist, ob er für alle 
eingegebenen Unifikationsprobleme terminiert und 
wie effizient sich auf diese Art Lösungen berechnen lassen. 
Außerdem ist von Interesse, ob alle Unifikationsprobleme immer eine
eindeutige Lösung (d.h. einen einzelnen mgu), oder eine endliche Menge
von nicht vergleichbaren L\"osungen bzw. unendlich viele L\"osungen besitzen.  

%{\color{red}{
%Eigenschaften von $\Sigma$-Unifiktionsprolbem, bzw. Unifikationsalgos:
%Entscheidbarkeit, Unifikationtype, Effiziens, ...
%\\
%nochmal genau schreiben was hier gemacht wird:
%Unifikaionsprolbem \"uber $\Sigma^{let}$ l\"osen}}

Das vorliegende Kapitel beschäftigt sich mit den oben skizzierten
Themen, um einen Teil des Problems der Berechnung von \"Uberlappungen
zu l\"osen. Dabei ist es folgenderma"sen aufgebaut: 

Abschnitt \ref{sec:ordnungsrelationen} enthält einige wichtige
Definitionen für im Text häufig verwendete Begriffe aus dem Bereich
der Ordnungsrelationen. 

In Abschnitt \ref{sec:terme-und-subst-ohne-sorts} werden die Begriffe
Term und Substitution für den Fall, dass keine Sorten
vorliegen, eingeführt. 

Im daran anschließenden Teil \ref{sec:sig-terme-subs-mit-sorts}
wird zuerst beschrieben, wie Signaturen um Sorten bereichert werden
(\ref{sec:sign-mit-sorts}). Dabei wird auch angegeben, wie eine
Signatur $\Sigma^{let}$ aussieht, die Ausdrücke aus dem Kalkül
$\Lambda^{let}$ als Terme mit Sorten darstellen kann. 
%In diesem Abschnitt wird auch
%festgestellt, dass die definierte Signatur $\Sigma^{let}$ über eine
%besonder einfache Struktur verfügt, die dazu führt dass die
%Unifikation über gute Berechnenbarkeitseigenschaften verfügt. 
{Da\-rauf} folgt in Abschnitt \ref{sec:wohlsortierte-terme} die Definition
von Termen, die Sorten aus einer gegebenen Signatur mit Sorten
berücksichtigen. Außerdem wird beschrieben, wie man Ausdrücke
des $\Lambda^{let}$-Kalküls in entsprechende Terme mit Sorten
übersetzen kann. 
Abschließend wird in Teil
\ref{sec:wohlsortierte-subs} darauf eingegangen, was es für
Substitutionen bedeutet, einer gegebenen Struktur von Sorten zu entsprechen. 

Die Unifikation von Termen mit Sorten ist das Thema von Abschnitt
\ref{sec:syntaktische-uni-mit-sorts}. Zuerst werden grundlegende
Begriffe wie \emph{Instantiierungs-Quasiordnung} und
\emph{Unifikationsproblem} eingeführt. Anschließend wird beschrieben,
wie Unifikationsprobleme durch wiederholte Anwendung von
Transformationen gelöst werden können
(\ref{sec:uni-druch-transformation}).
Ein wichtiger Teil dieses Abschnittes beschäftigt sich mit den
Eigenschaften des Transformationsprozesses: Es wird gezeigt, dass er
vollständig ist und terminiert. Dass sich die Menge aller Lösungen
für eine bestimmt interessante Klasse von Unifikationsproblemen
(nämlich die Unifikationsprobleme über der Signatur $\Sigma^{let}$)
als Instanz eines einzelnen mgu repräsentieren lässt, wird in Teil
\ref{sec:unifkationstyp-von-endl-einfachen-sig} gezeigt. 
Im abschließenden Abschnitt \ref{sec:effizienz-der-unif} wird gezeigt,
dass für diese Klasse von Unifikationsproblemen ein mgu effizient  
berechnet werden kann (in Quasi-Linear-Zeit).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Ordnungsrelationen}
\label{sec:ordnungsrelationen}
In den folgenden Abschnitten werden an verschiedenen Stellen
\emph{Ordnungsrelationen} verwendet.
Die grundlegenden Definitionen werden hier kurz angegeben. 

\begin{definition}%[Eingenschaften binärer Relationen]
\label{def:eingensch-binaerer-relationen}
Sei $\triangleright \subseteq A \times A$ eine binäre Relation auf
einer Menge $A$. Die Relation $\triangleright$ ist
\begin{description}
\item [reflexiv], gdw.\  $\forall x \in A: x \triangleright x$,
\item [irreflexiv], gdw.\  $\forall x \in A: \neg (x \triangleright x)$,
\item [transitiv], gdw.\ $\forall x,y,z \in A : x \triangleright y \; \wedge \; y \triangleright z \Rightarrow x \triangleright z$,
\item [symmetrisch], gdw.\ $\forall x,y \in A : x \triangleright y \Rightarrow y \triangleright x$,
\item [antisymmetrisch], gdw.\ $\forall x,y \in A : x \triangleright y \; \wedge \; y \triangleright x \Rightarrow x = y$.
\end{description}
\end{definition}

\begin{definition}[Äquivalenzrelation]
\label{def:aequivalenzrelation}
Eine \emph{Äquivalenzrelation} ist eine reflexive, transitive und 
symmetrische Relation: $\sim \subseteq A \times A$. Eine
Äquivalenzrelation erzeugt Äquivalenzklassen auf der Menge $A$:
$[a]_{\sim}:=\set{a' \in A \; | \; a \sim a'}$ für alle $a \in A$ und
eine Faktormenge $A/_{\sim}:=\set{[a]_{\sim} \; | \; a \in A}$. 
Äquivalenzklassen partitionieren eine Menge $A$: Zwei
Äquivalenzklassen $[a]_{\sim}$ und $[b]_{\sim}$ sind entweder
identisch (wenn $a \sim b$ gilt) oder disjunkt (wenn $a \sim b$ nicht gilt).
\end{definition}

\begin{definition}[Quasiordnung]
\label{def:quasiordnung}
%{\color{red}{Präordnung statt Quasiordnung schreiben?}}
Eine reflexive, transitive Relation $\lesssim$ auf einer Menge $A$ wird
als \emph{Quasiordnung} bezeichnet. 
Das Paar $(A,\lesssim)$ 
%, bestehend aus einer Menge $A$ und einer Quasiordnung $\lesssim$ auf %$A$, 
wird quasi-geordnete Menge genannt. 
\end{definition}

\begin{definition}[Partialordnung]
\label{def:partialordnung}
Eine antisymmetrische Quasiordnung $\leq$ wird als \emph{Partialordnung}
bezeichnet. Das Paar $(A,\leq)$ 
%, bestehend aus einer Menge $A$ und einer Partialordung $\leq$ auf $A$, 
wird partiell geordnete Menge genannt. 
\end{definition}

\begin{definition}[Strikte Ordnung]
\label{def:strikte-ordnung}
Eine \emph{strikte Ordnung} $<$ ist eine transitive und irreflexive
Relation.
\end{definition}

Die Schreibweise $x \gtrsim y$ wird verwendet für $y \lesssim x$ 
und $x \not\lesssim y$ ist definiert als $\neg(x \lesssim y)$ 
(analoge Definitionen werden für $\leq$ und $<$ getroffen).

Es gelten folgende Beziehungen: 
\begin{itemize}
\item Jede Quasiordnung $\lesssim$ induziert eine strikte Ordnung
\[x < y :\Leftrightarrow x \lesssim y \; \wedge \; \neg(y \lesssim x),\]
der sogenannte \emph{strikte Anteil} von $\lesssim$.
\item Jede Quasiordnung $\lesssim$ induziert eine Äquivalenzrelation 
\[x \sim y :\Leftrightarrow x \lesssim y \; \wedge \; y \lesssim x.\]
\item Jede Quasiordnung $\lesssim$ induziert eine Partialordnung auf $A/_{\sim}$ 
\[[x]_{\sim} \leq [y]_{\sim} :\Leftrightarrow x \lesssim y.\]
\item Jede Partialordnung $\leq$ induziert eine strikte Ordnung 
\[x < y :\Leftrightarrow x \leq y \; \wedge \; y \neq x.\]
%der strikte Anteil von $\leq$.
\item Jede strikte Ordnung $<$ induziert eine Partialordnung 
\[x \leq y :\Leftrightarrow x < y \; \vee \; y = x.\]
%der reflexive Abschluss von $<$.
\end{itemize}

\begin{definition}%[min, max, ls, lbs, glb]
\label{def:min-max-glb}
Sei $(A,\leq)$ eine partiell geordnete Menge und $M \subseteq A$. Es wird definiert:
\begin{itemize}
\item $min(M):= \set{m \in M \; | \; n \not < m \; \forall n \in M}$,
  die Menge der \emph{minimalen} Elemente von $M$.
\item $max(M):= \set{m \in M \; | \; m \not < n \; \forall n \in M}$,
  die Menge der \emph{maximalen} Elemente von $M$.
%$m \in M$ ist \emph{minimales} Element aus $M$, wenn $\forall n \in M: n \leq m \Rightarrow n = m$.
\item $ls(M) := m \in M$, so dass $ m \leq n \; \forall n \in M$, das
  \emph{kleinste} Element von $M$. 
%$m \in M$ ist \emph{kleinstes} Element aus $M$, wenn $\forall n \in M: m \leq n$.
%\item $gr(M) := m \in M$, so dass $m \geq n \; \forall n \in M$, das
%  \emph{größte} Element von $M$. 
\item $lbs(M) := \set{l \in A \; | \; l \leq n \; \forall n \in M}$, die
  Menge der \emph{unteren Schranken} von $M$. 
%$l \in A$ ist \emph{untere Schranke} von $M$, wenn $\forall n \in M: l \leq n$.
\item $glb(M) := max(lbs(M))$, die Menge der \emph{größten unteren Schranken} von $M$.
%  $l \in A$ ist \emph{größte untere Schranke} (\emph{inf}) von $M$, wenn 
%  $l$ untere Schranke von $M$ ist 
%  und für alle anderen unteren Schranken $l' \in A$ von $M$ gilt: $l' \leq l$. 
%  $\forall n \in M: l \leq n$
%  und $\forall n \in M, \forall l' \in A: l' \leq n \Rightarrow l' \leq l$.
%  Eine größte untere Schranke von $M$ wird als \emph{Infimum} 
%  (kurz \emph{inf}) von $M$ bezeichnet. 
\end{itemize}
%Eine Menge kann mehere minimale Elemente besitzen, aber nur ein
%kleinstes Element (ein kleinstes Element ist eindeutig bestimmt und
%natürlich auch minimal).
Die Begriffe 
%\emph{maximales} Element, 
\emph{größtes} Element,
\emph{obere Schranken} und \emph{kleinste obere Schranken} (kurz \emph{lub})
%(\emph{Supremum}) 
werden dual definiert (durch Umkehren der Ordnungsrelation). 
Für die Menge der unteren Schranken zweier Elemente 
$m,n \in A$ schreiben wir $lbs(m,n)$ anstatt $lbs(\set{m,n})$ 
(ebenso f\"ur $glb(m,n)$). 

Wenn $glb(M)$ und $lub(M)$ für alle endlichen Teilmengen $M$ von $A$
existieren und genau ein Element enthalten, dann ist $(A,\leq)$ ein \emph{Verband}. 
Wenn $lub(M)$ (bzw. $glb(M)$) für alle endlichen Teilmengen $M$ von
$A$ existiert und immer einelementig ist, aber $glb(M)$ (bzw. $lub(M)$)
nicht immer, dann ist $(A,\leq)$ ein \emph{oberer} (bzw. \emph{unterer})
\emph{Halbverband}. Eine äquivalente Charakterisierung eines oberen
Halbverbandes für eine endliche Mengen $A$ ist:  
\begin{enumerate}
\item $\forall a,b \in A: \; |lbs(a,b)| \geq 1 \Rightarrow |glb(a,b)| = 1$.
%entspricht der maximal-sorts-condition mit Grad = 1 von Walther Abschnitt Unifikationstyp
D.h. alle $a,b \in A$, die gemeinsame untere
Schranken besitzen, haben eine eindeutige 
größte untere Schranke, und
\item $A$ besitzt ein größtes Element. 
\end{enumerate}
\end{definition}

\begin{definition}%[linear, fundiert]
\label{def:linear-fundiert-partialordnung}
Sei $(A,\leq)$ eine partiell geordnete Menge. Die Relation $\leq$ ist 
\begin{description}
\item [linear], gdw.\ $\forall x,y \in A: x \neq y \Rightarrow x \leq y \vee y \leq x$.
\item [fundiert], gdw.\ es keine unendlichen, echt absteigenden Ketten
  $x_1 \geq x_2 \geq x_2 \geq \dots$ gibt (d.h. jede nichtleere
  Teilmenge von $A$ ein minimales Element besitzt). 
\end{description}
\end{definition}

Für eine lineare Partialordnung stimmen minimales und kleinstes
Element überein.
Sei $\leq$ eine lineare, fundierte Partialordnung auf der Menge $A$,
dann besitzt $A$ ein kleinstes Element $ls(A)$. 

%{\color{red}{definition: Komposition von Relationen; 
%    reflexiv, transitiver Abschluss.}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Terme und Substitutionen ohne Sorten}
\label{sec:terme-und-subst-ohne-sorts}
Zunächst werden die Begriffe Signatur, Term und Substitution für
den Fall ohne Sorten eingeführt. 
Die Notation \textasciimacron (Überstrich) wird im weiteren Verlauf
verwendet, um zu kennzeichnen, dass es sich um Objekte
handelt, denen keine Sorten zugeordnet sind, 
speziell im Fall von Signaturen ohne Sorten
($\overline\Sigma$), die später zur Definition von Signaturen mit
Sorten herangezogen werden. 
Die Darstellung orientiert sich an \citeA{baader_term_1998} sowie
\citeA{baader_unification_2001}.

Um zu verdeutlichen, welche Funktionssymbole in einem bestimmten
Kontext zur {Ver\-fü\-gung} stehen und welche Stelligkeiten sie besitzen, 
wird eine Menge von Funktionssymbolen definiert. 

\begin{definition}[Signatur ohne Sorten]
\label{def.sig}
Eine \emph{Signatur} $\overline\Sigma$ ist eine Menge von \emph{Funktionssymbolen}. 
Jedem Funktionssymbol $f \in \overline\Sigma$ ist eine Zahl $n \in \mathbb{N}$
zugeordnet, die \emph{Stelligkeit} von $f$. Für $n \geq 0$ wird die Menge
der $n$-stelligen Elemente von $\overline\Sigma$ mit $\overline\Sigma^n$ bezeichnet. 
Die Elemente aus $\overline\Sigma^0$ werden als \emph{Konstanten} bezeichnet.
\end{definition}

%\begin{definition}[Unsorted Signatur]
%Eine unsorted Signatur $\overline{\Sigma} = (F_{\overline\Sigma},
%X_{\overline\Sigma})$ besteht aus zwei disjunkten Mengen. 
%\begin{itemize}
%\item [$\mathbf{F_{\overline\Sigma}}$] ist eine Menge von
%  Funktionssymbolen. Funktionen werden geschrieben als $f, g, h$.
%\item [$\mathbf{X_{\overline\Sigma}}$] ist eine abzählbar unendliche
%  Menge von Variablensymbolen. Variablen werden geschrieben als $x, y, z$.
%\end{itemize}
%\end{definition}
%
%Jedes Funktionssymbol $f \in F_{\overline\Sigma}$ hat eine natürliche
%Zahl als Stelligkeit: $ar(f)$. Die Menge der Funktionssymbole mit
%Stelligkeit $n$ wird geschrieben als $F_{\overline\Sigma}^n$. 
%Funktionssymbole der Stelligkeit 0 werden als Konstanten bezeichnet. 

Terme werden gebildet aus Variablen oder durch die Anwendung eines
Funktionssymbols auf Terme. 

\begin{definition}[$\overline\Sigma$-Term]
\label{def.term}
Sei $\overline\Sigma$ eine Signatur und $X$ eine 
(abzählbar unendliche) Menge von \emph{Variablen}, so dass 
$\overline\Sigma \cap X = \emptyset$. 
Die Menge $T(\overline\Sigma, X)$ aller \emph{$\overline\Sigma$-Terme}
über Variablen $X$ ist induktiv definiert durch 
\begin{enumerate}
\item $X \subseteq T(\overline\Sigma, X)$ (jede Variable ist ein Term), 
\item für alle $n \geq 0$, alle $f \in \overline\Sigma^n$ und
  alle $t_1, \dots, t_n \in T(\overline\Sigma, X)$ ist $f(t_1, \dots,
  t_n) \in T(\overline\Sigma, X)$ (die Anwendungen von Funktionssymbolen
  auf Terme ergibt Terme). 
\end{enumerate}
\end{definition}

%Ein Term heiss \emph{linear}, wenn in ihm jede Variable maximal einmal vorkommt. 
Die Struktur eines Terms kann in natürlicher Weise als Baum dargestellt werden, 
wobei Funktionssymbole als Knoten und Argumente einer Funktion als
Kinder des Funktionsknotens repräsentiert werden. 
Abbildung \ref{fig:term-als-baum} zeigt einen Beispielterm $t$ in seiner
Baumdarstellung. Dort ist zu sehen, wie die Knoten des
Baumes in einer Links-Rechts-Ordnung durchnummeriert werden können. 
Über diese Nummerierung ist es möglich, sich auf einzelne
Symbole an bestimmten Positionen eines Terms oder auf Subterme zu
beziehen. Im Beispiel steht an Position $\epsilon$ %(bezeichnet das leere Wort)
das Funktionssymbol $f$ und an Position 1 
das Konstantensymbol $e$, das erste Argument von $f$. 
Der Subterm von $t$ an Position 21 ist $g(y)$.
Formal können Begriffe wie die Positionen oder die Größe eines
Terms durch Induktion über die Struktur von Termen definiert werden.  

\begin{figure}[!htb]
\center
\includegraphics{pictures/Abb.Term.Pos.eps} % [width=0.5\textwidth]
\caption{Baumdarstellung von $t = f(e,f(g(y),e))$.
\label{fig:term-als-baum}}
\end{figure}

\begin{definition}
\label{def.term.pos}
Sei $\overline\Sigma$ eine Signatur, $X$ eine Menge von Variablen, die  
disjunkt ist zu $\overline\Sigma$ und $s,t \in T(\overline\Sigma,X)$.
\begin{enumerate}
\item Die Menge der \emph{Positionen} eines Term $s$ ist die Menge $Pos(s)$
  von Worten über dem Alphabet der natürlichen Zahlen induktiv
  definiert durch:
  \begin{itemize}
  \item Wenn $s=x \in X$, dann ist $Pos(s):= \set{\epsilon}$, wobei
  $\epsilon$ das leere Wort bezeichnet. 
  \item Wenn $s=f(t_1, \dots, t_n)$, dann 
    \[Pos(s):= \set{\epsilon} \cup \bigcup_{i=1}^n \set{ip \; | \; p \in Pos(s_i)}.\]    
  \end{itemize}
  Die Position $\epsilon$ wird \emph{Wurzelposition} des Terms $s$
  genannt und das Funktionssymbol oder die Variable an dieser
  Position heißt \emph{Wurzelsymbol}. 
  Die \emph{Präfix-Ordnung}, definiert durch
  \[p \leq q \; \text{gdw. es gibt} \; p' \; \text{so dass} \; pp' = q,\]
  ist eine partielle Ordnung auf Positionen. Positionen $p,q$ werden
  \emph{parallel} genannt $(p||q)$,, gdw.\ $p$ und $q$ nicht vergleichbar
  bezüglich $\leq$ sind. 
  Die Position $p$ befindet sich \emph{oberhalb} der Position $q$, wenn $p \leq q$
  und $p$ ist \emph{strikt oberhalb} von $q$, wenn gilt $p < q$ (\emph{unterhalb}
  wird analog definiert).

\item Die \emph{Größe} $|s|$ eines Term $s$ ist die Kardinalität
  von $Pos(s)$. 

\item Sei $p \in Pos(s)$, dann wird der \emph{Subterm} von $s$ \emph{an
  Position} $p$ bezeichnet durch $s|_p$, definiert durch Induktion
  über die Länge von $p$:
  \begin{itemize}
  \item $s|_{\epsilon} := s,$
  \item $f(s_1, \dots, s_n)|_{iq} := s_i|_q$.
  \end{itemize}
%  $p=iq$ $p \in Pos(s)$ impliziert, dass $s$ von der Form 
%  $s = f(s_1, \dots, s_n)$ ist, mit $i \leq n$. 

\item Sei $p \in Pos(s)$, dann wird mit $s[t]_p$ der Term bezeichnet,
  der aus $s$ entsteht, durch die \emph{Ersetzung des Subterms an Position} 
  $p$ durch t:
  \begin{itemize}
  \item $s[t]_{\epsilon} := t$
  \item $f(s_1, \dots, s_n)[t]_{iq} :=  f(s_1, \dots, s_i[t]_q, \dots, s_n)$
  \end{itemize}

\item Mit $\Var(s)$ wird die Menge der in Term $s$ \emph{vorkommenden Variablen}
  bezeichnet:
  \[\Var(s) := \set{x \in X \; | \; es \; gibt \; p \in Pos(s), \; so \; dass \; s|_p = x}\]
  Eine Position $p \in Pos(s)$ wird \emph{Variablen-Position} genannt,
  wenn $t|_p$ eine Variable ist. 
\end{enumerate}
\end{definition}

%{\color{red}{Kontexte}}
Für den Term $t$ aus obigem Beispiel haben wir 
$Pos(t) = \set{\epsilon,1,2,21,211,22}$, $t|_{21} = g(y)$, 
$t[e]_{2} = f(e,e)$, $\Var(t) = \set{y}$ und $|t| = 6$. Die Größe von
$t$ ist gleich der Anzahl der Knoten in der Baumdarstellung von $t$. 

Der Hauptunterschied zwischen Konstantensymbolen und Variablen
besteht darin, dass Variablen durch Substitutionen ersetzt werden
können. 

\begin{definition}[Substitution]
\label{def.sub}
Sei $\overline\Sigma$ eine Signatur und $X$ eine abzählbar unendliche Menge
von Variablen. Eine $T(\overline\Sigma,X)$-\emph{Substitution} (oder einfach nur
Substitution, wenn die Menge der Terme irrelevant ist oder aus dem
Kontext hervorgeht) ist eine Funktion 
\[\sigma : X \rightarrow T(\overline\Sigma,X),\]
so dass die Menge $\set{x \in X \; | \; \sigma(x) \neq x}$ endlich
ist. 
Diese endliche Menge von Variablen, die unter $\sigma$ nicht auf
sich selbst abgebildet werden, bezeichnet man als \emph{Domain} von $\sigma$:
\[\Dom(\sigma) := \set{x \in X \; | \; \sigma(x) \neq x}.\]
Die \emph{Range} von $\sigma$ ist
\[\Ran(\sigma) := \set{\sigma(x) \; | \; x \in \Dom(\sigma)}\]
 und die
\emph{Variablen-Range} von $\sigma$ enthält die in $\Ran(\sigma)$
vorkommenden Variablen: 
\[\VRan(\sigma) := \bigcup_{x \in \Dom(\sigma)} \Var(\sigma(x)).\]
Ist $\Dom(\sigma)= \set{x_1, \dots, x_n}$, kann man $\sigma$ schreiben,
indem man die Menge von Variablen-Termbindungen angibt, die $\sigma$
definieren (da $\Dom(\sigma)$ endlich ist). 
\[\sigma = \set{x_1 \mapsto \sigma(x_1), \dots, x_n \mapsto \sigma(x_n)}.\]
Man sagt $\sigma$ \emph{instantiiert} $x$, wenn $x \in \Dom(\sigma)$. 
Die Menge aller $T(\overline\Sigma, X)$-Substitutionen wird bezeichnet durch
$Sub(T(\overline\Sigma, X))$ oder einfach $Sub_{\overline\Sigma}$. 
\end{definition}

Jede $T(\overline\Sigma, X)$-Substitution kann folgendermaßen zu einer
Abbildung $\widehat{\sigma}: T(\overline\Sigma,X) \rightarrow T(\overline\Sigma,X)$ 
\emph{erweitert} werden: 
\begin{itemize}
\item Für $x \in X$, $\widehat{\sigma}(x) := \sigma(x)$ und
\item für jeden nicht Variablenterm $s=f(s_1, \dots, s_n)$ ist
  $\widehat{\sigma}(s) := f(\widehat{\sigma}(s_1), \dots, \widehat{\sigma}(s_n)).$
\end{itemize}

Die Anwendung einer Substitution $\sigma$ auf einen Term ersetzt
gleichzeitig alle Vorkommen von Variablen durch die jeweiligen
$\sigma$-Bilder. Sei beispielsweise $s=f(e,x)$ und $t=f(y,f(x,y))$
sowie $\sigma=\set{x \mapsto g(y), y \mapsto e}$, dann
ist $\widehat{\sigma}(s) = f(e,g(y))$ und $\widehat{\sigma}(t) = f(e,f(g(y),e))$.

Die \emph{Identitätssubstitution}, die alle Variablen auf sich selbst
abbildet (d.h. $\sigma(x) = x$ für alle $x \in X$), wird mit $Id$
bezeichnet. 

Zwei Substitutionen $\sigma$ und $\tau$ sind \emph{äquivalent}
bezüglich einer Menge von Variablen $W \subseteq X$, geschrieben als
$\sigma = \tau [W]$, wenn gilt $\sigma(x) = \tau(x)$ für alle $x \in W$. 
Ist $W=X$ dann schreibt man $\sigma = \tau$.

Die \emph{Einschränkung} einer Substitution $\sigma$ auf eine Menge
von Variablen $X$, geschrieben als $\sigma|_X$, ist definiert als 
$\sigma|_X(x) := \sigma(x)$, wenn $x \in X$, sonst $\sigma|_X x := x$.

Die \emph{Komposition} $\sigma \tau$ zweier Substitutionen $\sigma$
und $\tau$ ist definiert als 
\[\sigma \tau (x) := \widehat{\sigma}(\tau(x)).\]
%Da $\sigma \tau$ eine Abbildung von $X$ nach $T(\overline\Sigma,X)$ ist und
%$\sigma \tau(x) = x$ gilt für alle $x \in X - (\Dom(\sigma) \cup \Dom(\tau))$
%(d.h. $\Dom(\sigma \tau)$ ist endlich)
%ist $\sigma \tau$ eine Substitution. 
Sind zwei Substitutionen $\sigma = \set{x_1 \mapsto s_1, \dots, x_n \mapsto s_n}$ 
und $\tau = \set{y_1 \mapsto t_1, \dots, y_m \mapsto t_m}$ als
Mengen von Variablen-{Term\-bin\-dun\-gen} gegeben, kann ihre Komposition
$\sigma \tau$ folgendermaßen konstruiert werden: 
$\sigma \tau = \set{y_1 \mapsto \widehat{\sigma} t_1, \dots, y_m \mapsto \widehat{\sigma} t_m}
\cup \set{x_i \mapsto s_i \; | \; x_i \in \Dom(\sigma) - \Dom(\tau)}$.
Die Komposition von Substitutionen ergibt wieder eine Substitution und ist assoziativ, d.h. es gilt 
$\sigma (\tau \delta) = (\sigma \tau) \delta$.
%{\color{red}{Bew.?}}

%Die Erweiterung der Kompositionen
%von $\sigma$ und $\tau$ ist die Komposition der Erweiterungen von
%$\sigma$ und $\tau$: $\widehat{\sigma \tau} = \widehat{\sigma}\widehat{\tau}.$
Zur Vereinfachung der Notation wird üblicherweise nicht
unterschieden zwischen Substitutionen 
$\sigma: X \rightarrow T(\overline\Sigma,X)$ und ihrer Erweiterung
$\widehat{\sigma}: T(\overline\Sigma,X) \rightarrow T(\overline\Sigma,X)$. 
Im weiteren Verlauf wird $\sigma$ verwendet, um  die Substitution und
ihre Erweiterung auf Terme zu bezeichnen. Außerdem wird die Anwendung 
einer Substitution $\sigma$ auf einen Term $t$ häufig ohne Klammern
geschrieben, $\sigma t$ anstatt $\sigma(t)$.

Ein Term $t$ wird \emph{Instanz} eines Terms $s$ genannt, wenn es eine
Substitution $\sigma$ gibt, so dass $t = \sigma s$. Man schreibt 
$s \lesssim t$.

Eine Substitution $\sigma$ wird \emph{idempotent} genannt, wenn gilt
$\sigma \sigma = \sigma$, was genau dann der Fall ist, wenn 
$\Dom(\sigma) \cap \VRan(\sigma) = \emptyset$.
%{\color{red}{Bew.?}}
Eine idempotente Substitution bestehend aus $n$ Variablen-Termbindugen,
kann in Kompositionen von $n$ Substitutionen, jede aus
lediglich einer Bindung bestehend, zerlegt werden:
\[\sigma = \set{x_1 \mapsto t_1, x_2 \mapsto t_2, \dots, x_n \mapsto t_n} = 
  \set{x_1 \mapsto t_1} \set{x_2 \mapsto t_2} \dots \set{x_n \mapsto t_n}.\]
Eine solche Komposition wird als \emph{trianguläre Form} bezeichnet
und geschrieben als:
\[[x_1 \mapsto t_1; x_2 \mapsto t_2; \dots; x_n \mapsto t_n].\]

Eine \emph{Variablenumbenennung} ist eine Substitution 
$\rho \in Sub_{\overline\Sigma}$, so dass gilt 
\begin{enumerate}
\item $\rho$ ist injektiv auf $\Dom(\rho)$,
d.h. $\forall x_1,x_2 \in \Dom(\rho): \rho x_1 = \rho x_2 \Rightarrow x_1=x_2$ 
und 
\item $\Ran(\rho)$ besteht nur aus Variablen. 
\end{enumerate}
%D.h. $\rho$ ist eine Bijektion auf der Menge der Variablen $X$ (da,
%$\Dom(\rho)$ endlich ist). 

Sei $\rho = \set{x_1 \mapsto y_1, \dots, x_n \mapsto y_1}$ eine
Variablenumbenennung, dann ist die \emph{Umkehrung} von $\rho$
definiert als 
$\rho^- := \set{y_1 \mapsto x_1, \dots, y_n \mapsto x_n}$. 
Folgendes technisches Lemma über Variablenumbenennungen wird später
benötigt.
\begin{lemma}
\label{lem.renaming}
Sei $\rho$ eine Variablenumbenennung. Es gilt
\begin{enumerate}
\item $\rho^-$ ist eine Variablenumbenennung
\item $\Dom(\rho) = \Ran(\rho^-)$,
\item $\Dom(\rho^-) = \Ran(\rho)$,
\item $\rho \rho^- = \rho$,
\item $\rho^- \rho = \rho^-$,
\item $\rho^- \rho = Id [{\Dom(\rho)}]$,
\item $(\rho^-)^- = \rho$.
\end{enumerate}
\end{lemma}
\begin{beweis}
1, 2, 3, und 7 sind offensichtlich. Betrachte 5.
Sei $\rho = \set{x_1 \mapsto y_1, \dots, x_n \mapsto y_1}$ eine
Variablenumbenennung und deren Umkehrung sei
$\rho^- := \set{y_1 \mapsto x_1, \dots, y_n \mapsto x_n}$. 
Konstruiere $\rho^- \rho$ wie oben angegeben:
\[\begin{array}{rl}
\rho^- \rho = & \set{x_1 \mapsto \rho^- y_1, \dots, x_n \mapsto \rho^- y_n} \cup 
                \set{y_1 \mapsto x_1, \dots, y_n \mapsto x_n} \\
= & \set{x_1 \mapsto x_1, \dots, x_n \mapsto x_n} \cup 
    \set{y_1 \mapsto x_1, \dots, y_n \mapsto x_n} \\
= & Id \cup \set{y_1 \mapsto x_1, \dots, y_n \mapsto x_n} \\
= & \rho^-
\end{array}\]
Damit ist auch 6 einsichtig und 4 wird analog gezeigt. $\qed$
\end{beweis}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Signaturen, Terme und Substitutionen mit Sorten}
\label{sec:sig-terme-subs-mit-sorts}
Es wird nun der Fall betrachtet, dass Terme über Sorten
verfügen, die auf syntaktischer Ebene den Definitions- und
Wertebereich von Funktionssymbolen beschreiben. 
Dazu wird zu Signaturen eine Menge von Sortensymbolen hinzugefügt, 
zusammen mit Mechanismen, um die Sorten von Termen zu beschreiben. 
Die Darstellung orientiert sich an 
\citeA{schmidt-schauss_computational_1989}.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Signaturen mit Sorten}
\label{sec:sign-mit-sorts}
Signaturen mit Sorten benötigen eine zusätzliche Symbolmenge:
\begin{itemize}
\item $S_{\Sigma}$ ist die nicht leere Menge von \emph{Sortensymbolen}. 
  Elemente werden mit $R,S$ bezeichnet.
\end{itemize}

Funktionssymbole (und beliebige andere Terme) erhalten Sorten
durch Deklarationen. 
\begin{definition}[Deklarationen]
\label{def.dek}
Eine \emph{Termdeklaration} ist ein Paar $(t,S)$, geschrieben als $t:S$,
wobei $t$ kein Variablenterm $t \in T(\Sigma,X)$ und $S \in S_{\Sigma}$ ein
Sortensymbol ist. Ist $t$ von der Form $f(x_1, \dots, x_n)$ und $x_i \in X$
sind verschiedene Variablen, dann nennt man $t:S$ \emph{Funktionsdeklaration}. 
Ist $t$ eine Konstante, dann bezeichnet man
$t:S$ als \emph{Konstantendeklaration}. Sonst wird $t:S$ 
(ordnungsgemäße) Termdeklaration genannt. 
Eine \emph{Subsortendeklaration} hat die Form $R \sseq S$, wobei
$R$ und $S$ Sortensymbole sind. In diesem Fall wird $R$ als
\emph{Subsorte} von $S$ bezeichnet.
\end{definition}

Termdeklarationen werden verwendet, um Signaturen mit Sorten
zu definieren.   
\begin{definition}[Signatur mit Sorten]
%{\color{red}{evtl. doch noch Menge der Variablen in Signatur aufnehmen. \\
%$\Sigma = (\overline\Sigma,S_{\Sigma},\mathbb{S},TD,SD)$}}
\label{def.sort.sig}
Eine \emph{Signatur mit Sorten} $\Sigma$ besteht aus:
\begin{enumerate}
\item einer Signatur ohne Sorten $\overline\Sigma$,
\item einer Menge von Sortensymbolen $S_{\Sigma}$,
\item einer Funktion $\mathbb{S}: X \rightarrow S_{\Sigma}$, so dass
  für alle Sortensymbole $S \in S_{\Sigma}$ abzählbar unendlich viele
  Variablen $x \in X$ existieren mit $\mathbb{S}(x) = S$,
\item einer Menge von Term- und Subsortendeklarationen. 
\end{enumerate}
\end{definition}

Zur Definition einer Signatur mit Sorten ist es in der Regel ausreichend, 
Term- und Subsortendeklarationen zusammen mit Angaben zur Sorte der
Variablen, die in Termdeklarationen vorkommen, anzugeben. 
Funktionsdeklarationen $f(x_1, \dots, x_n):S$ werden abgekürzt
geschrieben als $f : S_1 \rightarrow \dots \rightarrow S_n \rightarrow S$,
wobei $S_i$ die Sorte der Variablen $x_i$ ist. 
Die Information, dass eine Variable $x$ oder Konstante $c$ die Sorte
$S$ hat, wird geschrieben als $x:S$, $c:S$ bzw. $x_S$, $c_S$.

Die Funktion $\mathbb{S}: X \rightarrow S_{\Sigma}$ partitioniert die
Menge der Variablen $X$ in Teilmengen $X_S$ von Variablen der Sorte
$S$. 

Die Subsortendeklarationen der Form $R \sseq S$ einer Signatur
bilden die Basis für eine Quasiordnung auf der Menge der Sorten, die
formal folgendermaßen definiert ist:
\begin{definition}[Subsorten-Quasiordnung]
\label{def.sub.sort.order}
Sei $\Sigma$ eine Signatur mit Sorten und sei
$\sseq$ die Relation, die definiert ist durch den 
reflexiven, transitiven Abschluss der Subsortendeklarationen aus $\Sigma$.
Dann ist $\sseq$ eine Quasiordnung auf der Menge der Sortensymbole
$S_{\Sigma}$. Die Quasiordnung wird als \emph{Subsorten-Quasiordnung}
bezeichnet. Das Paar $(S_{\Sigma},\sseq_{\Sigma})$ wird
\emph{Sortenstruktur} genannt.
% oder \emph{Sorthierarchie}
\end{definition}

Geht aus dem Kontext klar hervor, auf welche Signatur $\Sigma$ sich 
die Subsorten Quasiordnung $\sseq_{\Sigma}$ bezieht, wird ein einfach
$\sseq$ geschrieben. Der strikte Anteil von $\sseq_{\Sigma}$
wird durch $\sqsubset$ bezeichnet (siehe Abschnitt \ref{sec:ordnungsrelationen}).
Unter dem reflexiven, transitiven Abschluss $\sseq_{\Sigma}$ von
$\sseq$ gilt $S \sseq_{\Sigma} S$ für alle $S \in S_{\Sigma}$.
%Die von $\sseq_{\Sigma}$ induzierte Äquivalenzrelation
%ist $\sim_{\Sigma} := \sseq_{\Sigma} \cap \undertilde{\sqsupset}_{\Sigma}$

\begin{beispiel}
\label{bsp.sig.let}
Die Menge der Sortensymbole $S_{\Sigma}^{let}$, die verwendet werden, um
das Kalkül $\Lambda^{let}$ mit den Konstrukten Abstraktion, Applikation und \letr $\;$
in ein Kalkül erster Ordnung mit Sorten zu transformieren,
sei folgendermaßen definiert: 
\begin{enumerate}
\item [\bf{T}] repräsentiert die Sorte für Terme (Ausdrücke des Ursprungskalküls),
\item [\bf{A}] repräsentiert die Sorte für Abstraktionen,
\item [\bf{V}] repräsentiert die Sorte für Variablen,
\item [\bf{U}] repräsentiert die Sorte für \letr-Umgebungen,
\item [\bf{B}] repräsentiert die Sorte für \letr-Bindungen,
%\item [\bf{K}] repräsentiert den Sort für Ketten von \letr-Bindungen.
\end{enumerate}
Es werden keine Sortensymbole für die Konstrukte Applikation und \letr$\;$des
Ursprungskalküls definiert, da 
%zum jetzigen Zeitpunkt 
kein Bedarf besteht zwischen 
Applikationen (bzw. \letr-{Aus\-drü\-cken}) und beliebigen Ausdrücken zu
unterscheiden. 
Alle Variablen, die in linken Seiten von Reduktionsregeln des
$\Lambda^{let}$-Kalk\"uls auftauchen, lassen sich einer dieser Sorten
zuordnen. 

Die Signatur $\Sigma^{let}$ sei folgendermaßen definiert: 
\newcommand{\fktsort}[3]{#1 \rightarrow #2 \rightarrow #3}
\[\begin{array}{rllr}
\Sigma^{let} = \set{ 
& \multicolumn{2}{l}{\mathbf{Subsortendeklarationen:}} \\
& A \sqsubset T, \; V \sqsubset T, B \sqsubset U, & \\
%& B \sqsubset U,  & \\
& \multicolumn{2}{l}{\mathbf{Funktionsdeklarationen:}} \\
&  abs : \fktsort{V}{T}{A} & \mathsf{(Abstraktion)}, \\
&  app : \fktsort{T}{T}{T} & \mathsf{(Applikation)}, \\
&  letrec : \fktsort{U}{T}{T} & \mathsf{(\letr)}, \\
&  umg : \fktsort{B}{U}{U} & \mathsf{(\letr-Umgebung)}, \\
&  bind : \fktsort{V}{T}{B} & \mathsf{(\letr-Bindung)} & } \\
%&  kette : \fktsort{B}{B}{U} & \mathsf{(Kette \; von \; Bindugen)} \\
\end{array}\]

Zum jetzigen Zeitpunkt werden Kontextvariablen und Umgebungen
%Ketten von Bindungen 
aus der Betrachtung ausgeklammert, 
da diese Konstrukte des Ursprungskalküls $\Lambda^{let}$ bestimmte 
Unifikationsmethoden benötigen, auf die hier noch nicht eingegangen
wird ($E$-Unifikation und Unifikation höherer Ordnung).
Kontextvariablen und Umgebungen werden in späteren Kapiteln behandelt. 
Insbesondere das Funktionssymbol $umg$ dient hier nur als Platzhalter, 
und wird in Kapitel \ref{cha:ac-unifikation} ausf\"uhrlich behandelt. 
%{\color{red}{ref späteres Kapitel}}

In den Subsortendeklarationen wird die Variablen-Sorte $V$ als Subsorte
der Term-Sorte $T$ deklariert. Diese Subsortenbeziehung soll das
Verhalten des Ursprungskalküls nachbilden, in dem Variablen
Ausdrücke darstellen, aber ein beliebiger Ausdruck in der Regel keine
Variable ist. Ebenso handelt es sich bei Abstraktionen um Ausdrücke;
ein beliebiger Ausdruck muss aber im Allgemeinen keine Abstraktion
sein. Aus diesem Grund wird in der Subsortendeklaration auch der strikte
Anteil $\sqsubset$ von $\sseq$ verwendet, da Abstraktionen
(bzw. Variablen) eine echte Teilmenge der Ausdrücke darstellen.  

Auf den \letr-Umgebungsoperator $umg$ und $bind$ wird in einem späteren
Kapitel genauer eingegangen.
Hier sei nur darauf hingewiesen, dass die Sorten $B,U$ nicht
vergleichbar sind bezüglich $\sseq_{\Sigma}$ mit den Sorten
$V,A,T$. 
%{\color{red}{D.h. $\sseq_{\Sigma}$ ist keine lineare Ordnung,
%    insbesondere ist $(\Sigma^{let}, \sseq_{\Sigma})$ kein Teilverband.}}
Dieses
Verhalten ist erwünscht, da Terme der Sorte $B,U$ Bestandteile von
\letr-Umgebungen repräsentieren, die selbst keine eigenst\"andigen
Ausdr\"ucke des $\Lambda^{let}$-Kalküls sind. 
\end{beispiel}

Eine Signatur $\Sigma$ mit Sorten kann klassifiziert werden
in Abhängigkeit der Kardinalität der Menge der Sortensymbole
$|S_{\Sigma}|$ und der Art der Termdeklarationen, die sie enthält.

\begin{definition}%[eingenschaften sig mit sorts]
\label{def:eing-sig-sorts}
Sei $\Sigma$ eine Signatur mit Sorten. $\Sigma$ ist 
\begin{itemize}
\item \emph{endlich}, wenn ihre Beschreibung endlich ist, d.h. wenn die
  Menge der Sortensymbole, die Menge der Funktionssymbole, die Term-
  und Subsortendeklarationen endlich sind. 
\item \emph{one-sorted}, wenn $|S_{\Sigma}|=1$, d.h. es nur einen Sorte gibt. 
\item \emph{many-sorted}, wenn $|S_{\Sigma}| > 1$ und es keine
  Subsortendeklarationen gibt. 
\item \emph{order-sorted}, wenn $|S_{\Sigma}| > 1$ und es 
  Subsortendeklarationen gibt. 
%\item \emph{Linear}, wenn alle Termdeklarationen linear sind.
\item \emph{elementar}, wenn alle Termdeklarationen
  Funktionsdeklarationen sind. 
\item \emph{einfach}, wenn sie elementar ist und für
  alle Funktionssymbole existiert genau eine Funktionsdeklaration.  
\end{itemize}
\end{definition}

Diese Eigenschaften einer Signatur $\Sigma$ haben einen
erheblichen Einfluss auf die Unifikation für $\Sigma$-Terme,
wie wir im Abschnitt \ref{sec:uni-druch-transformation} sehen werden. 

\begin{korollar}
\label{kor.sig.let.einfach}
Die in Beispiel \ref{bsp.sig.let} definierte Signatur $\Sigma^{let}$
ist \emph{endlich}. Sie ist \emph{elementar}, da alle Term-Deklarationen
Funktionsdeklarationen sind. Außerdem ist sie \emph{einfach}, da sie
elementar  ist und für alle Funktionssymbole gibt es genau eine 
Funktionsdeklaration. 
\end{korollar}

Da wir vor allem daran interessiert sind Unifikationsprobleme für 
Terme über der speziellen Signatur $\Sigma^{let}$ zu lösen 
und es sich bei dieser um eine endliche und einfache Signatur handelt,
wird im weiteren Verlauf besonderes Augenmerk auf endliche und
einfache Signaturen gerichtet. 

%{\color{red}{\textasciimacron als Funktion, die sorted Objekten
%    unsorted Objekte zuordnet.}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Wohlsortierte Terme}
\label{sec:wohlsortierte-terme}
Signaturen mit Sorten werden verwendet, um Terme zu
definieren, die diese Sorten berücksichtigen. Für ein
Sortensymbol $S \in S_{\Sigma}$ definiert man die Menge der Terme mit
Sorte $S$. 

\begin{definition}[$\Sigma$-Term der Sorte $S$]
\label{def.sort.term}
Sei $\Sigma$ eine Signatur mit Sorten, $X$ eine Menge von Variablen, 
so dass $\Sigma \cap X = \emptyset$. Die Menge $T(\Sigma,S,X)$ aller
\emph{$\Sigma$-Terme der Sorte $S$} über $X$ ist induktiv definiert durch
\begin{enumerate}
\item $x \in T(\Sigma,S,X)$, wenn $\mathbb{S}(x) \sseq S$.
\item $t \in T(\Sigma,S,X)$, wenn $t:R \in \Sigma$ und $R \sseq S$.
\item $\set{x \mapsto r} t \in T(\Sigma,S,X)$, wenn 
  $t \in T(\Sigma,S,X)$, $r \in T(\Sigma,R,X)$ und $R \sseq \mathbb{S}(x)$.
\end{enumerate}
%{\color{red}{($\sseq$ sieht schlimm aus, evtl '\;'
%    einf\"ugen)}}
\end{definition}

D.h. alle Variablen der Sorte kleiner gleich $S$ sind Terme der
Sorte $S$ (1). Und alle Terme der Signatur mit Sorte kleiner gleich $S$,
die den Termdeklarationen von $\Sigma$ entnommen werden können,
sind Terme der Sorte $S$ (2). Ein neuer Term $t'$ der Sorte $S$ kann
konstruiert werden aus einem Term $t$ der Sorte $S$ durch gleichzeitiges
Ersetzen einer Variablen in $t$ durch einen Term der Sorte kleiner
gleich der Sorte der Variablen (3). 

Aus der Definition folgt sofort
\begin{korollar}
\label{kor.sort.term}
Sei $\Sigma$ eine Signatur mit Sorten.
\begin{enumerate}
\item Für alle Sorten $R,S \in S_{\Sigma}$ gilt: $R \sqsubset S$ impliziert
  $T(\Sigma,R,X) \subseteq T(\Sigma,S,X)$.
\item Für Variablen gilt: $x \in T(\Sigma,S,X) \Leftrightarrow \mathbb{S}(x) \sseq S$.
\end{enumerate}
\end{korollar}

\begin{beispiel}
\label{bsp:terme-sig-let}
Aus Definition \ref{def.sort.term} ergeben sich unter der in Beispiel
\ref{bsp.sig.let} definierten Signatur 
$\Sigma^{let}$ und der Variablenmenge $X$ folgende Terme: 
\begin{itemize}
\item Terme mit Sorte $V$: Da es keine Funktionsdeklaration der Sorte
  $V$ gibt, bestehen die Terme der Sorte $V$ lediglich aus Variablen
  der Sorte $V$: $x_V, y_V, z_V\dots$

\item Terme der Sorte $A$: Da es außer dem Funktionssymbol $abs$ kein
  Funktionssymbol der Sorte $A$ in der Signatur gibt, und $A$ keine
  Subsorts besitzt, sind alle Terme der Sorte $A$ von folgender Form:
  \begin{itemize}
  \item entweder Abstraktionsvariablen $v_A, w_A, \dots$,
  \item oder Terme bei denen das Funktionssymbol $abs$ an der
    Wurzelposition steht.
  \end{itemize}
%  Keine Terme der Sorte $A$ sind beispielsweise 
%  $app(abs(x_V,y_T),z_T)$ und $letrec(u_U,abs(x_V,y_T))$, da $T \not\sseq A$.
  
\item Terme der Sorte $T$: Aus $V,A \sqsubset T$ folgt nach Korollar
  \ref{kor.sort.term}, dass alle Terme der Sorte $V$ und Terme der
  Sorte $A$ auch Terme der Sorte $T$ sind. D.h. alle Variablen $x_V,
  y_V, \dots$ und $v_A, w_A, \dots$ und Terme mit $abs$ als
  Wurzelsymbol sind Terme der Sorte $T$. 
  Nach Definition \ref{def.sort.term} sind außerdem 
  Terme der Sorte $T$ von folgender Form:
  \begin{enumerate}
  \item 
    %Variablen der Sorte $R$ mit $R \sseq T$, d.h. 
    %aus den Subsortdeklaration 
    %$V \sqsubset T, A \sqsubset T$ folgt, dass Variablen der Sorte
    %$V$ und Abstraktionsvariablen der Sorte $A$ Terme der Sorte $T$
    %sind. 
    Termvariablen $s_T,t_T,u_T \dots$ sind Terme der Sorte $T$.
  \item Terme $t$ der Signatur mit $t:R$ und $R \sseq T$,
    d.h. $app(s_T,t_T)$ und $letrec(e_U,s_T)$ sind Terme
    der Sorte $T$. 
  \item Terme der Sorte $T$, deren Variablen durch Terme mit einer
    kleineren oder gleichen Sorte ersetzt werden. Beispiele dafür
    sind: $app(abs(x_V,s_t),t_T)$ und $letrec(d_U,letrec(e_U,s_T))$.
  \end{enumerate}
\end{itemize}
Terme der Sorte $B$ oder $U$ werden analog gebildet.

Die Abbildung $\transl{\;} : \Lambda^{let} \rightarrow
T(\Sigma^{let},X)$, die Ausdrücke (in Meta-Notation) 
des Ursprungskalküls $\Lambda^{let}$ 
(ausgenommen \letr-Umgebungen und Kontextvariablen) 
übersetzt in $\Sigma^{let}$-Terme erster Ordnung mit Sorten,
ist folgendermaßen definiert: 
%(Es wird noch einmal darauf
%hingewiesen, dass Kontextvariablen und Ketten  
%hier noch nicht behandelt werden.)
\[\begin{array}{rcl}
\transl{x}           & = & x_V \\
\transl{v}           & = & v_A \\
\transl{s}           & = & s_T \\
\transl{Env}         & = & e_U \\
\transl{\lambda x.s} & = & abs(\transl{x},\transl{s}) \\
\transl{(s \; t)}      & = & app(\transl{s},\transl{t}) \\
\transl{\letrecm{Env}{s}} & = & letrec(\transl{Env},\transl{s}) \\
%\transl{\set{E_1,E_2, \dots, x_1 = s_1, \dots, x_m = s_m}} & = &
%  umg(\transl{E_1}, \transl{\set{E_2, \dots, x_1=s_1, \dots}}) \\
%\transl{\set{x_1=s_1, x_2=s_1, \dots}} & = & umg(\transl{x_1=s_1},\transl{x_2=s_2, \dots}) \\
\transl{x=s} & = & bind(\transl{x},\transl{s}) \\
%\set{E,\set{x_i =x_{i-1}}^n_{i=m}}
\end{array}\]

Variablen des Kalküls $\Lambda^{let}$ werden in Variablen der
entsprechenden Sorte übersetzt. Z.B: 
$x,y,z \xrightarrow{\transl{\;}} x_V, y_V, z_V$, dabei geht i.A. aus
dem Kontext hervor, um welche Variablensorte es sich in einem
$\Lambda^{let}$-Ausdruck handelt. Alle anderen Konstrukte des
$\Lambda^{let}$-Kalküls werden auf natürliche Weise in
$\Sigma^{let}$-Terme übersetzt. 
Die \"Ubersetzung von \letr-Umgebungen lassen wir zun\"achst offen, 
sie wird in Kapitel \ref{cha:ac-unifikation} beschrieben. 
%\letr-Bindungen und
%Umgebungsvariablen werden durch die Umgebungsfunktion $umg$ in eine
%Struktur, vergleichbar mit einer Multimenge 
%gepackt \cite{bttner_unification_1986,livesey_unification_1976}, beispielsweise:
%\[\transl{\set{E, x=t, y=s}} = umg(e_U,umg(bind(x_V,t_T),bind(y_V,s_T))).\]

Durch Induktion über die Struktur von $\Lambda^{let}$-Ausdrücken
unter Verwendung von Definition \ref{def.sort.term} lässt sich zeigen: 
\begin{proposition}%[korrekt transl sig let]
\label{prop:korrekt-transl-sig-let}
Alle $\Lambda^{let}$-Ausdrücke (die keine Kontexte und
Ketten enthalten) werden durch $\transl{\;}$
auf wohlsortierte $\Sigma^{let}$-Terme abgebildet. 
\end{proposition}
\end{beispiel}

%Nach diesem kurzen Einschub, stellen wir uns die Frage, wie viel Sorts
%ein Term besitzen kann.   
Ein Term $t$ kann mehrere Sorten besitzen. 
Zum einen die direkt ablesbaren Sorten
aus den Termdeklarationen (für einen Term sind ja beliebig viele
Termdeklarationen erlaubt). Zum anderen besitzt $t$ alle Sorten $S$, für
die gilt $t \in T(\Sigma,S,X)$. Diese Sorten sind $t$ indirekt durch 
Subsortendeklarationen zugeordnet (\"uber $\sseq_{\Sigma}$).  
Formal wird die Menge der Sorten eines Terms
folgendermaßen definiert:
\begin{definition}
\label{def.wellsorted.term}
Die Menge $T(\Sigma,X)$ aller \emph{wohlsortierten} $\Sigma$-Terme ist definiert als 
\[\bigcup_{S \in S_{\Sigma}} \set{T(\Sigma,S,X)}.\] 

Die \emph{Sorte eines Terms} $t$ ist definiert als die Menge 
\[S_{\Sigma}(t):= \set{S \in S_{\Sigma} \; | \; t \in T(\Sigma,S,X)}.\]
 
Die \emph{Sorte einer Variablen} $x$ ist definiert als
\[S_{\Sigma}(x) = \set{S \in S_{\Sigma} \; | \; \mathbb{S}(x) \sseq S}.\]
Für jede Variable $x \in X$ besitzt die Menge $S_{\Sigma}(x)$ ein
kleinstes Element, nämlich $\mathbb{S}(x)$. 
%Für alle Term $t \in T(\Sigma,X)$ ist die Menge $S_{\Sigma}(t)$ ein nichtleeres
%{\color{red}{upper segment}} in $S_{\Sigma}$.
\end{definition}

Die Menge der Sorten eines Terms ist für endliche Signaturen effizient
berechenbar (siehe \citeNP{schmidt-schauss_computational_1989}, S. 22).
Wir sind hier nicht weiter interessiert an der Berechnung der Sorten
eines Terms $t$, sondern richten unser Augenmerk auf eine Bedingung,
für die $\ssigf{t}$ eine spezielle Struktur aufweist: Die Existenz
einer kleinsten Sorte für alle Terme $t$. Ist eine Signatur so
strukturiert, dass alle Terme eine kleinste Sorte besitzen, wird sie
als \emph{regulär} bezeichnet. Unter dieser Bedingung besitzt die
Unifikation wesentlich bessere Berechenbarkeitseigenschaften, als wenn
eine kleinste Sorte nicht für alle Terme existiert. 

\begin{definition}%[reguläre Signatur]
\label{def:regulaere-signatur}
Sei $\Sigma$ eine Signatur mit Sorten. 
$\Sigma$ ist \emph{regulär}, gdw.\ $(S_{\Sigma},\sseq_{\Sigma})$ eine
partiell geordnete Menge ist und für jeden Term $t$ die Menge $S_{\Sigma}(t)$
ein kleinstes Element besitzt (d.h. $ls(S_\Sigma(t))$ existiert bez\"uglich $\sseq_{\Sigma}$). 
Für eine reguläre Signatur $\Sigma$ wird diese eindeutige
kleinste Sorte des Terms $t$ mit $\ls{t}$ bezeichnet:
$\ls{t} := ls(S_\Sigma(t))$.
\end{definition}
F\"ur Regulari\"at wird gefordert, dass die Sortenstruktur eine partiell
geordnete Menge ist. Um dies zu verdeutlichen, wird ab jetzt
$\sqsubseteq_{\Sigma}$ geschrieben, wenn die Ordnung eine partielle
Ordnung ist; f\"ur die Quasiordnung wird wie bisher $\sseq_{\Sigma}$
geschrieben. 

Zwei einfache Bedingungen, unter denen eine Signatur regulär ist,
liefert folgende Proposition. 
\begin{proposition}
\label{prop.reg.sig.einfach}
Sei $\Sigma$ eine Signatur mit Sorten. 
\begin{enumerate}
\item Wenn $\sqsubseteq_{\Sigma}$ eine lineare, fundierte
  Partialordnung auf $S_{\Sigma}$ ist, dann ist $\Sigma$ regulär.  
\item Wenn $\Sigma$ endlich und einfach ist, dann ist $\Sigma$ regulär. 
\end{enumerate}
\end{proposition}
\begin{beweis}
1. ist klar, da jede fundierte, linear partiell geordnete Menge ein
   kleinstes Element besitzt. 

Zu 2: Sei $\sim_{\Sigma}$ die von $\sseq_{\Sigma}$
   induzierte Äquivalenzrelation 
   %(siehe Abschnitt \ref{sec:ordnungsrelationen}), 
   und sei $\sqsubseteq_{\Sigma}$ die von $\sseq_{\Sigma}$
   induzierte Partialordnung 
   auf der Faktormenge $S_{\Sigma}/_{\sim_{\Sigma}}$ (in der Faktormenge
   werden äquivalente Sortensymbole zu einer Äquivalenzklasse
   zusammengefasst); $\sqsubseteq_{\Sigma}$ ist fundiert, weil $\Sigma$ endlich ist. 
   Sei $t = f(t_1, \dots, t_n)$, dann folgt aus der Einfachheit von
   $\Sigma$, dass es genau eine Funktionsdeklaration gibt
   mit $f(x_1, \dots, x_n):R$. Für die Menge der Sorten von $t$ haben
   wir $\ssigf{t}= \set{S \in S_{\Sigma} \; | \; t \in T(\Sigma,S,X)}
   = \set{S \in S_{\Sigma}/_{\sim} \; | \; R \sqsubseteq_{\Sigma} S}$ (nach
   Definition \ref{def.sort.term} und Einfachheit von $\Sigma$) und
   auf dieser Menge $\ssigf{t}$ ist $\sqsubseteq$ eine lineare,
   fundierte Partialordnung mit $\ls{t} = R$. Sei $t = x$, dann gilt
   nach Definition \ref{def.wellsorted.term} $\ls{x} = \mathbb{S}(x)$.
%   folgt $\ls{x} = \mathbb{S}(x)$ weil $\sqsubseteq$ lineare, fundierte
%   Partialordnung auf 
%   $S_{\Sigma}(x) = \set{S \in S_{\Sigma}/_{\sim} \; | \; \mathbb{S}(x)\sqsubseteq S}$ ist. 
$\qed$ 
\end{beweis}

Der Beweis belegt, dass jede linear, fundierte Partialordnung ein
kleinstes Element besitzt,
was allerdings für eine lineare, fundierte Quasiordnung nicht gelten
muss, da sie nicht antisymmetrisch ist (für eine Quasiordnung ist das
kleinste Element sozusagen nur modulo der induzierten
Äquivalenzrelation eindeutig bestimmt). Dieser Umstand wird dadurch
behoben, dass äquivalente Sortensymbole zu Äquivalenzklassen
zusammengefasst werden können. Auf der Faktormenge der
Äquivalenzklassen induziert $\sseq_{\Sigma}$ eine Partialordnung
$\sqsubseteq_{\Sigma}$, bezüglich der das kleinste Element der
Sortenmenge eines Term eindeutig bestimmt  
ist, da $\sqsubseteq_{\Sigma}$ auf dieser Menge linear und fundiert ist. 

Aus Proposition \ref{prop.reg.sig.einfach} folgt, dass man in einer
einfachen Signatur, die kleinsten Sorten von Termen, die durch
Anwendung von Funktionssymbolen gebildet werden, direkt aus den 
Funktionsdeklarationen der Signatur ablesen kann. 

\begin{korollar}%[signatur einfach]
\label{kor:signatur-einfach}
Sei $\Sigma$ eine einfache Signatur mit Funktionsdeklarationen
\[f_1: S_{1_1} \rightarrow \dots \rightarrow S_{n_1} \rightarrow S_1, \dots, \\
 f_k: S_{1_k} \rightarrow \dots \rightarrow S_{n_k} \rightarrow S_k,\]
wobei alle $f_i,f_j$ paarweise verschieden sind. 
Dann gilt $\ls{f_i(t_1, \dots, t_{n_i})}= S_i$ für alle $i = 1, \dots, k$ 
und beliebige Terme $t_1, \dots t_n$.
\end{korollar}

In einfachen Signaturen haben wir die angenehme Situation, dass die
kleinste Sorte eines Terms $t$ nicht von dessen Subtermen abh\"angig ist,
sondern direkt abgelesen werden kann. Entweder aus den
Funktionsdeklarationen f\"ur $t = f(\dots)$, oder durch $\mathbb{S}(x)$
f\"ur $t = x$. 
%Das erleichtert sp\"ater die Unifikation, da wir

Wie wir gesehen haben, ist die Signatur $\Sigma^{let}$ eine einfache
Signatur (Korollar \ref{kor.sig.let.einfach}). 
Folglich ist $\Sigma^{let}$ auch eine reguläre Signatur
(nach Proposition \ref{prop.reg.sig.einfach}), was wir in folgendem Korollar
festhalten. 
\begin{korollar}%[sig let einfach]
\label{kor:sig-let-einfach}
Die Signatur $\Sigma^{let}$ (aus Beispiel \ref{bsp.sig.let})
ist \emph{regulär}, d.h. alle Terme $t \in T(\Sigma,S,X)$ haben eine
eindeutige kleinste Sorte $LS_{\Sigma}(t)$.  
\end{korollar}

Der Umgang mit wohlsortierten Substitutionen im nächsten Abschnitt 
wird durch folgende Beobachtung vereinfacht. 
\begin{proposition}
\label{prop.reg.sig}
Für alle regulären Signaturen $\Sigma$ gilt: 
\begin{enumerate}
\item $\ssigf{t} \subseteq \ssigf{s} \Leftrightarrow \ls{t} \sqsupseteq_{\Sigma} \ls{s}$.
\item $\ls{x} = \mathbb{S}(x)$. 
\end{enumerate}
\end{proposition}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Wohlsortierte Substitutionen}
\label{sec:wohlsortierte-subs}
Wir erweitern den Begriff der Substitutionen zu Substitutionen, die
Sorten berücksichtigen.
\begin{definition}[Wohlsortierte Substitution]
\label{def.sort.sub}
Die Menge der \emph{wohlsortierten Substitutionen} 
(auch $\Sigma$-Substitutionen genannt)
$Sub_{\Sigma}$ ist folgendermaßen definiert:
\[Sub_{\Sigma} := \set{\sigma \in Sub_{\overline\Sigma} \; | \;
  \ssigf{\sigma x} \supseteq \ssigf{x}}.\]
Für reguläre Signaturen ist dies nach Proposition \ref{prop.reg.sig}
gleichbedeutend mit
\[Sub_{\Sigma} := \set{\sigma \in Sub_{\overline\Sigma} \; | \;
  \ls{\sigma x} \sqsupseteq \ls{x}}.\]
\end{definition}

Wohlsortierte Substitutionen schwächen die Sorten, d.h. $\sigma x$ hat
eine kleinerer oder gleiche Sorte als $x$ für alle Variablen $x$. 
Aus obiger Definition folgt, dass $Sub_{\Sigma} \subseteq Sub_{\overline\Sigma}$ 
und dass die Identitätssubstitution $Id_{\Sigma}$ eine wohlsortierte
Substitution ist: $Id_{\Sigma} \in Sub_{\Sigma}$.

Eine \emph{$\Sigma$-Variablenumbenennung} $\rho \in Sub_{\Sigma}$ ist
eine Abbildung, die injektiv auf $\Dom(\rho)$ ist, und Variablen auf
Variablen abbildet, so dass Sorten erhalten bleiben, d.h. es gilt 
$\ssigf{\rho x} = \ssigf{x}$ für alle $x \in X$.
Eine Substitution $\rho \in Sub_{\Sigma}$ wird als
\emph{$\Sigma$-Permutation} bezeichnet, wenn $\rho$ eine
$\Sigma$-Variablenumbenennung ist, so dass $\Dom(\rho) = \Ran(\rho)$. 
Dann ist $\rho$ eine Bijektion (auf $\Dom(\rho)$) mit Inversem
$\rho^-$ und es gilt $\rho \rho^- = \rho^- \rho = Id_{\Sigma}$. 

Wohlsortierte Substitutionen sind kompatibel mit der Sortenstruktur auf
$T(\Sigma,X)$, d.h. wohlsortierte Substitutionen 
%(genauer gesagt deren Erweiterungen)
bilden $T(\Sigma,S,X)$ nach $T(\Sigma,S,X)$ ab für alle Sorten $S$.

\begin{proposition}
\label{prop.sub.sort.preserving}
Für alle wohlsortierten Terme $t \in T(\Sigma,S,X)$ und alle
wohlsortierten Substitutionen $\sigma \in Sub_{\Sigma}$ gilt 
$\sigma t \in T(\Sigma,S,X)$.
\end{proposition}
\begin{beweis}
Für $t = x \in X$ folgt die Behauptung direkt aus der
Wohlsortiertheit von $\sigma$. 

Sei $t = f(t_1, \dots, t_n) \in T(\Sigma,S,X)$ und sei 
$\sigma=\set{x_1 \mapsto s_1, \dots, x_m \mapsto s_m} \in Sub_{\Sigma}$. 
Wenn $\sigma$ eine idempotente $\Sigma$-Substitution ist, dann besitzt
sie die trianguläre Form $[x_1 \mapsto s_1; \dots; x_m \mapsto s_m]$
und die wiederholte Anwendung einzelner Komponenten von $\sigma$ auf
$t$ impliziert $t \in T(\Sigma,S,X)$ nach Definition \ref{def.sort.term}.

Ist $\sigma$ nicht idempotent, dann
%kann sie durch folgende überlegung idempotent gemacht werden:
sei $\rho \in Sub_{\Sigma}$ eine idempotente
$\Sigma$-Variablenumbenennung mit $\Dom(\rho)=\VRan(\sigma)$ und 
$\Ran(\rho) \cap (\cup_{i=1}^m \Var(s_i) \cup \Var(t)) = \emptyset$,
d.h. $\Ran(\rho)$ besteht aus Variablen, die nicht in $s_i$ oder $t$
vorkommen. Sei $\rho^-$ die Umkehrung von $\rho$. 
Nach Lemma \ref{lem.renaming} gilt $\rho^- \rho = \rho^-$ und, weil 
$\Dom(\rho^-) \cap (\cup_{i=1}^m \Var(s_i) \cup \Var(t)) = \emptyset$
nach Konstruktion von $\rho$ gilt, folgt $\sigma t = \rho^- \rho \sigma t$.
Die Substitution $\rho\sigma$ ist idempotent (wegen Konstruktion von
$\rho$ und Komposition von Substitutionen), und kann
folgendermaßen zerlegt werden: 
$\set{x_1 \mapsto \rho s_1, x_2 \mapsto \rho s_1, \dots, x_m \mapsto \rho s_m} = 
\set{x_1 \mapsto \rho s_1} \set{x_2 \mapsto \rho s_2} \dots \set{x_2 \mapsto \rho s_2}$.
Jede Komponente $\set{x_i \mapsto \rho s_i}$ ist wohlsortiert 
nach folgender \"Uberlegung:
$\rho$ ist eine $\Sigma$-Variablenumbenennung, die Sorten erh\"alt, d.h aus
$s_i \in T(\Sigma,R,X)$ folgt $\rho s_i \in T(\Sigma,R,X)$ für
alle Sorten $R$. Schrittweise Anwendung aller Komponenten
$\set{x_i \mapsto \rho s_i}$ auf $t$ nach Definition
\ref{def.sort.term} resultiert in $\rho \sigma t \in T(\Sigma,S,X)$
und aus $\sigma t = \rho^- \rho \sigma t$ folgt $\sigma t \in
T(\Sigma,S,X)$. $\qed$
\end{beweis}
%{\color{red}{Wo liegt hier der Trick?}}

\begin{korollar}
\label{kor.comp.sort.sub}
Seien $\sigma$ und $\tau$ wohlsortierte Substitutionen. Dann gilt:
deren Komposition $\sigma \tau$ ist eine wohlsortierte Substitution. 
\end{korollar}
\begin{beweis}
Sei $\tau = \set{x_1 \mapsto s_1, \dots, x_n \mapsto s_n} \in
Sub_{\Sigma}$ und $\sigma \in Sub_{\Sigma}$. 
Zu zeigen ist 
$\sigma \tau x \in T(\Sigma,\mathbb{S}(x),X)$ für alle $x \in X$. 
Nach Proposition \ref{prop.sub.sort.preserving} gilt 
$\sigma \tau x_i = \sigma s_i \in T(\Sigma,\mathbb{S}(x),X)$ 
für alle $x_i \in \Dom(\tau)$. Für alle anderen Variablen $x$ gilt
entweder $\sigma \tau x = \sigma x \in T(\Sigma,\mathbb{S}(x),X)$ oder
$\sigma \tau x = x \in T(\Sigma,\mathbb{S}(x),X)$. $\qed$
\end{beweis}

Die nächste Proposition zeigt, wie wohlsortierte Terme erzeugt werden
können durch die Anwendung von wohlsortierten Substitutionen auf Terme
aus Termdeklarationen. 

\begin{proposition}
\label{prop.gen.sort.term}
Für alle Sorten $S \in S_{\Sigma}$ und alle Terme $s\in T(\Sigma,S,X)$, 
die keine Variablen-Terme sind, 
gibt es eine Termdeklaration $t:R \in \Sigma$ mit
$R \sseq S$ und eine Substitution $\sigma \in Sub_{\Sigma}$, so
dass gilt $\sigma t =s$.
\end{proposition}
\begin{beweis}
%\color{red}
Durch strukturelle Induktion unter Verwendung von Definition
\ref{def.sort.term} und Korollar \ref{kor.comp.sort.sub}. $\qed$
\end{beweis}

%{\color{red}{Erzeugung der Terme mit Hilfe von Proposition \ref{prop.gen.sort.term}}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Syntaktische Unifikation von wohlsortierten Termen}
\label{sec:syntaktische-uni-mit-sorts}
Für zwei wohlsortierte Terme $s,t$ ist man daran interessiert, eine
wohlsortiert Substitution $\sigma$ zu finden, so dass die beiden Terme
$\sigma s$ und $\sigma t$ syntaktisch gleich sind: $\sigma s = \sigma t$. 
Die Berechnung einer solchen Substitution wird \emph{Unifikation}
genannt, $\sigma$ wird als \emph{Unifikator} von $s$ und $t$ bzw. als
\emph{Lösung} der Gleichung $s \ue t$ bezeichnet. 
Sei $\Sigma$ eine Signatur mit nur einem Sortensymbol und alle
Funktionssymbole $(f,g)$, Konstantensymbole $(a)$ und Variablen
$(x,y)$ seien von dieser Sorte, dann sind einige Beispiele für
Unifikationsprobleme und deren Lösungen:  

\begin{tabular}{rl}
$f(x) \ue f(a)$ & hat genau einen Unifikator $\set{x \mapsto a}$. \\
$x \ue f(y)$ & hat viele Unifikatoren $\set{x \mapsto f(y)}, \set{x \mapsto f(a), y \mapsto a}, \dots$ \\
$f(x) \ue g(y)$ & hat keinen Unifikator. \\
%$x_S \ue z_R$ & hat den (wohlsortierten) Unifikator $\set{x \mapsto z}$  
%  für $R \sseq S$, \\
%& für $R \undertilde{\not\sqsubset} S$ hat die Gleichung keine wohlsortierte Lösung. \\ 
\end{tabular}

Wie man sieht, kann ein Unifikationsproblem keine, eine oder mehrere
Lösungen besitzen. Im Falle der Existenz von mehreren Unifikatoren
unterscheiden diese sich jedoch im Grade ihrer
Allgemeinheit. Beispielsweise ist für das Problem $x \ue f(y)$ die
Substitution $\set{x \mapsto f(y)}$ ein \emph{allgemeinerer} Unifikator
als $\set{x \mapsto f(a), y \mapsto a}$. 

\begin{definition}[Instantiierungs-Quasiordnung]
\label{def.inst.rel}
Seien $\sigma, \tau \in Sub_{\Sigma}$ wohlsortierte
Substitutionen und $W \subseteq X$ eine Menge von Variablen. Die
Substitution $\sigma$ ist \emph{allgemeiner auf W} als  
die Substitution $\tau$, geschrieben als 
$\sigma \lesssim_{\Sigma} \tau [W]$,
wenn es eine Substitution $\delta \in Sub_{\Sigma}$ gibt, so dass gilt
$\tau = \delta \sigma[W]$. 
Die Substitution $\tau$ wird als \emph{Instanz} von $\sigma$ und die
Relation $\lesssim_{\Sigma}[W]$ als \emph{Instantiierungs-Quasiordnung} bezeichnet. 
%Seien $\sigma, \tau \in Sub_{\Sigma}$ und $W \subseteq X$. 
%Es wird definiert:
%\begin{enumerate}
%\item $\sigma = \tau [W]$, wenn $\sigma x = \tau x$ für alle $x \in W$.
%\item $\sigma \lesssim_{\Sigma} \tau [W]$, wenn es eine Substitution
%  $\delta \in Sub_{\Sigma}$ gibt, so dass $\delta \sigma = \tau [W]$.
%  Man sagt, dass $\sigma$ \emph{allgemeiner} als $\tau$ ist
%  (modulo $W$); $\tau$ wird als \emph{Instanz} von $\sigma$
%  bezeichnet.
%\item  $\equiv_{\Sigma} [W]$ ist definiert als
% $\lesssim_{\Sigma} [W] \cap \geq_{\Sigma} [W]$. 
  %$\sigma \equiv_{\Sigma} \tau [W]$ gilt, gdw.\  
  %$\sigma \lesssim_{\Sigma} \tau [W]$ und $\sigma \geq_{\Sigma} \tau [W]$. 
%\end{enumerate}
\end{definition}
F\"ur $W = X$ schreiben wir verk\"urzt $\lesssim_{\Sigma}$. 

%Ist die Menge $W$ die Menge aller Variablen $X$, dann wird
%$\lesssim_{\Sigma}$ anstatt $\lesssim_{\Sigma}[W]$ geschrieben. 
Für die Substitutionen $\sigma = \set{x \mapsto f(y)}$ und 
$\tau = \set{x \mapsto f(a), y \mapsto a}$ aus obigem Beispiel gilt
$\sigma \lesssim_{\Sigma} \tau$ nach folgender Überlegung: Sei 
$\delta = \set{y \mapsto a}$, dann folgt $\tau = \delta \sigma$, weil
$\tau(x) = f(a) = \delta(\sigma(x))$ und $\tau(y) = a = \delta(\sigma(y))$ 
und $\tau(z) = z = \delta(\sigma(z))$ für alle anderen Variablen $z$. 

%In manchen Fällen kann es sinnvoll sein, die
%Instantiierungs-Quasiordnung $\lesssim_{\Sigma}$ bezüglich einer Menge von
%Variablen zu betrachten. Man definiert die
%Instantiierungs-Quasiordnung modulo einer Menge von Variablen $W \subseteq X$ als 
%\[\sigma \lesssim_{\Sigma} \tau [W] : \Leftrightarrow \exists \delta\in Sub_{\Sigma}: 
%  \tau (x) = \delta (\sigma(x)) [W] \; \text{f\"ur alle} \; x \in W.\]
%{\color{red}{Bsp.?}}

\begin{lemma}
\label{lem.inst.rel}
Die Relation $\lesssim_{\Sigma}$ ist eine Quasiordnung auf der Menge
der wohlsortierten Substitutionen $Sub_{\Sigma}$
\end{lemma}
\begin{beweis} 
Reflexivität ist offensichtlich für $\delta = Id$. 
Zur Transitivität sei $\sigma_2 = \delta_1 \sigma_1$ und 
$\sigma_3 = \delta_2 \sigma_2$. Folglich 
$\sigma_3 = \delta_2 \sigma_2 = \delta_2 (\delta_1 \sigma_1) = 
(\delta_2 \delta_1) \sigma_1$, weil die Komposition von (wohlsortierten)
Substitutionen assoziativ ist. $\qed$
\end{beweis}

Die Relation $\lesssim_{\Sigma}$ ist antisymmetrisch, d.h. beispielsweise 
für $\sigma = \set{x_S \mapsto y_S}$ und $\tau = \set{y_S \mapsto x_S}$
gilt $\sigma \lesssim_{\Sigma} \tau$ wegen $\tau = \tau \sigma$ und 
$\tau \lesssim_{\Sigma} \sigma$ wegen $\sigma = \sigma \tau$. Allerdings
gilt nicht $\sigma = \tau$; trotzdem sind die beiden Substitutionen
äquivalent bezüglich der von $\lesssim_{\Sigma}$ induzierten Äquivalenzrelation
$\sim_{\Sigma} \; := \; \lesssim_{\Sigma} \cap \geq_{\Sigma}$.
Bzw. die allgemeine Definition bez\"uglich einer Menge von Variablen:
$\sigma \sim_{\Sigma} \tau [W] \; := \; \sigma \lesssim_{\Sigma} \tau [W] \wedge \tau \lesssim_{\Sigma} \sigma [W]$.
Man sagt, dass die beiden Substitutionen äquivalent
modulo Komposition mit einer $\Sigma$-Variablenpermutation sind. 
%Diese Beziehung wird in folgendem Lemma verdeutlicht. 

%Die Relation $\lesssim_{\Sigma}$ heißt Instanzierungs (partial) Ordnung. 
%Aus obigem Lemma folgt, dass $\equiv_{\Sigma}$
%eine äquivalenzrelation auf $Sub_{\Sigma}$ ist.
\begin{lemma}
\label{lem.inst.equiv}
Seien $\sigma, \tau \in Sub_{\Sigma}$ und $W \subseteq X$ eine Menge von Variablen. 
Dann gilt:
$\sigma \sim_{\Sigma} \tau [W]$, gdw.\ es eine 
$\Sigma$-Permutation $\rho$ gibt, so dass $\sigma = \rho \tau [W]$.
\end{lemma}
\begin{beweis}
$\Leftarrow$: Sei $\rho$ eine $\Sigma$-Permutation. 
  $\sigma = \rho \tau [W]$ impliziert $\tau \lesssim_{\Sigma} \sigma [W]$. 
  Sei $\rho^-$ die inverse $\Sigma$-Permutation zu $\rho$, 
  dann gilt $\rho^- \sigma = \rho^- \rho \tau [W]$ und wegen 
  $\rho^- \rho = Id_{\Sigma}$ folgt $\rho^- \sigma = \tau [W]$ und damit auch
  $\sigma \lesssim_{\Sigma} \tau [W]$ und letztlich $\sigma \sim_{\Sigma} \tau [W]$.

$\Rightarrow$: Es gelte $\sigma \sim_{\Sigma} \tau [W]$, d.h. es gibt
  Substitutionen $\delta_1, \delta_2 \in Sub_{\Sigma}$, so dass
  $\tau = \delta_1 \sigma [W]$ und $\sigma = \delta_2 \tau [W]$. 
  Einsetzen ergibt $\sigma = \delta_2 \delta_1 \sigma [W]$, woraus 
  $\delta_2 \delta_1 = Id[\Dom(\sigma)]$ folgt. Andererseits gilt 
  aber auch $\tau = \delta_1 \delta_2 \tau [W]$, d.h. wir haben analog 
  $\delta_1 \delta_2 = Id[\Dom(\tau)]$, woraus f\"ur
  $\rho = \delta_2 \delta_1 [W]$ folgt $\Dom(\rho) = Ran(\rho)$, 
  also ist $\rho$ eine $\Sigma$-Permutation mit $\sigma = \rho \tau [W]$. $\qed$
%{\color{red}{Beweis ist in \cite{lassez_unification_1988}}}
\end{beweis}

Die Instantiierungs-Quasiordnung wird verwendet, um zu begründen,
warum für ein gegebenes Unifikationsproblem nicht alle Unifikatoren
berechnet werden müssen: Die Berechnung eines kleinsten
Unifikators $\sigma$ bezüglich $\lesssim_{\Sigma}$ ist ausreichend, da
alle anderen Unifikatoren durch Instantiierung aus $\sigma$ gewonnen
werden können. Allerdings reicht es für Terme mit Sorten
im Allgemeinen nicht aus, nur einen kleinsten Unifikator bez\"uglich $\lesssim_{\Sigma}$
zu berechnen. Zur Begründung betrachte folgendes Beispiel:
\begin{beispiel}%[finitary unifiying]
\label{bsp:finitary-unifing}
Sei $\set{A,B \sqsupset C,D}$ eine Signatur mit Sorten. Für das
Unifikationsproblem $x_A \ue y_B$ existieren zwei allgemeinste
Lösungen $\sigma_1 = \set{x_A \mapsto w_C, y_B \mapsto w_C}$ und
$\sigma_2 = \set{x_A \mapsto z_D, y_B \mapsto z_D}$, die bezüglich
$\lesssim_{\Sigma}$ nicht miteinander vergleichbar sind.
Die Ursache hierfür liegt darin, dass die größte untere Schranke
von $A$ und $B$ nicht eindeutig ist: $glb(A,B) = \set{C,D}$,
d.h. die Sortenstruktur ist kein unterer Halbverband. 
%\footnote{Zu Folgerungen daraus siehe
%Definition \ref{def.unifikationsregeln} der Unifikationsregeln und
%deren Vollständigkeitsbeweis \ref{lem.vollst.sorted.unifikation}).
\end{beispiel}

Folglich muss für ein Unifikationsproblem, das Terme mit Sorten
enthält, eine Menge von allgemeinsten Unifikatoren betrachtet werden. 

\begin{definition}[Unifikationsproblem]
\label{def:unifikatiosproblem}
Ein \emph{$\Sigma$-Unifikationsproblem} (oder einfach
Unifikationsproblem, wenn der Bezug zu $\Sigma$ klar ist)
ist eine endliche Menge von Gleichungen
$P=\set{s_1 \ue t_1, \dots, s_n \ue t_n}$ mit $s_i,t_i \in T(\Sigma,X)$. 
Eine \emph{Lösung} von $P$ (auch \emph{Unifikator} von $P$ genannt) ist eine
Substitution $\sigma \in Sub_{\Sigma}$, so dass 
$\sigma t_1 = \sigma s_i$ für $i= 1, \dots, n$. Die Menge aller
(wohlsortierten)
Lösungen von $P$ wird als $U_{\Sigma}(P)$ bezeichnet
\[ U_{\Sigma}(P) := \set{\sigma \in Sub_{\Sigma} \; | \; \sigma s_i = \sigma t_i \; \text{f\"ur} \; i = 1,\dots, n}.\]
$P$ ist \emph{lösbar} wenn $U_{\Sigma}(P) \neq \emptyset$. 
Das spezielle Unifikationsproblem $\bot$ besitzt keine Lösung. 
Mit $\Var(P)$ wird die Menge der in $P$ auftauchenden Variablen
bezeichnet: $\Var(P):= \cup^{n}_{i=1} (\Var(s_i) \cup \Var(t_i))$.
\end{definition}

\begin{definition}%[vollst min mgu menge]
\label{def:vollst-min-mgu-menge}
Eine \emph{vollständige Menge von Unifikatoren} (oder \emph{Lösungen}) für
ein Unifikationsproblem $P$ ist eine Menge von wohlsortierten Substitutionen
$CU_{\Sigma}(P)$, so dass 
\begin{itemize}
\item $CU_{\Sigma}(P) \subseteq U_{\Sigma}(P)$ und 
\item für alle $\tau \in U_{\Sigma}(P)$ gibt es $\sigma \in CU_{\Sigma}(P)$,
  so dass $\sigma \lesssim_{\Sigma} \tau [\Var(P)]$. 
\end{itemize}

Eine \emph{minimale vollständige Menge von Unifikatoren}
(bzw. \emph{L\"osungen}) für ein
Unifikationsproblem $P$ ist eine vollständige Menge von Unifikatoren
$MU_{\Sigma}(P)$, so dass die Substitutionen in $MU_{\Sigma}(P)$
bezüglich $\lesssim_{\Sigma} [\Var(P)]$ nicht vergleichbar sind: 
\begin{itemize}
\item Für alle $\sigma, \tau \in MU_{\Sigma}(P)$ gilt: 
  $\sigma \lesssim_{\Sigma} \tau [\Var(P)]$ impliziert $\sigma = \tau [\Var(P)]$
\end{itemize}
Eine Substitution $\sigma$ ist ein \emph{mgu} (most general unifier
oder \emph{allgemeinste L\"osung}) von $P$
gdw. $\set{\sigma}$ eine minimale vollst\"andige Menge von
L\"osungen f\"ur $P$ ist.
%Eine vollständige, minimale Menge von Unifikatoren wird kurz als
%Menge von \emph{mgus} bezeichnet.
\end{definition}

Die Einschränkung von $\lesssim_{\Sigma}$ auf die in $P$
vorkommenden Variablen wird in Definition
\ref{def:vollst-min-mgu-menge} getroffen, weil durch  
$\lesssim_{\Sigma} [\Var(P)]$ mehr Substitutionen miteinander vergleichbar
sind als durch die restriktivere Relation $\lesssim_{\Sigma}$, die
Gleichheit für alle Variablen verlangt. Dadurch wird in manchen
Fällen vermieden, dass die Menge der minimalen, vollständigen
Unifikatoren unnötig groß wird  
(für ein Beispiel siehe \citeA{baader_unification_1991}).
Außerdem ist diese Beschränkung sinnvoll, da zur Berechnung aller
Überlappungen die komplette Menge der vollständigen, minimalen
Unifikatoren bestimmt werden muss. Hier ist es von Vorteil, eine
Quasiordnung zu verwenden, die alternative Lösungen nur in Bezug auf
die kleinere Variablenmenge vergleicht. Wie wir weiter unten sehen, 
werden (allgemeinste) Lösungen für ein Unifikationsproblem $P$
berechnet, indem es schrittweise zu einem Problem $S$ transformiert
wird, aus dem eine Lösung direkt ablesbar ist. Bei der Transformation 
können neue Variablen 
%(das sind Variablen, die bisher nicht in dem Problem vorkommen) 
in das Problem eingeführt werden. Eine Lösung für das
Ausgangsproblem $P$ erhält man durch Einschr\"ankung der Lösung des
Endproblems $S$ auf die in $P$ vorkommenden Variablen. 

Eine vollständige, minimale Menge von Unifikatoren muss nicht immer
existieren, da sich Vollständigkeit und Minimalität widersprechen
können. Wenn eine vollständige und minimale Menge $MU_{\Sigma}(P)$ von Lösungen
f\"ur ein Problem $P$ existiert, ist diese eindeutig, bis auf die von $\lesssim_{\Sigma} [\Var(P)]$
induzierte Äquivalenzrelation $\sim_{\Sigma}[\Var(P)]$. D.h. seien $M_1$ und
$M_2$ minimale, vollständige Mengen von Unifikatoren eines
Unifikationsproblems $P$, dann gibt es eine Bijektion 
$B : M_1 \rightarrow M_2$, so dass 
$\sigma_1 \sim_{\Sigma} B(\sigma_1) [\Var(P)]$ für alle $\sigma_1 \in M_1$ 
gilt \cite{fages_complete_1986}. 
Folglich haben alle vollständigen, minimalen Mengen von Unifikatoren
eines gegebenen Problems $P$ dieselbe Kardinalität. Ein Umstand, der
zur Definition des Begriffs des \emph{Unifikationstyps}\footnote{In
  der Literatur (z.B. \citeA{baader_unification_2001}) wird der Begriff
  Unifikationstyp bezüglich einer Gleichungstheorie 
  $E$ definiert. Da Gleichungstheorien erst in 
  Kapitel \ref{cha:ac-unifikation} eingeführt werden, wird
  der Begriff hier (leicht missbräuchlich) verwendet, um die
  Kardinalität von minimalen, vollst\"andigen Menge von Unifikatoren bezüglich 
  einer gegebenen Signatur zu charakterisieren. Streng genommen, wird hier
  $|MU_{\Sigma,E}(P)|$ für die leere Theorie $E=\emptyset$
  betrachtet.} 
herangezogen wird.

\begin{definition}[Unifikationstyp]
\label{def:unification-type}
%{\color{red}{Die Def. aus \cite{baader_unification_2001} verwenden.}}
Eine Signatur $\Sigma$ mit Sorten besitzt den
\emph{Unifikationstyp} 
\begin{description}
\item [eindeutig,] gdw.\ $MU_{\Sigma}(P)$ existiert und 
  $|MU_{\Sigma}(P)| \leq 1$ für alle $\Sigma$-Unifikationsprobleme $P$ gilt. 
\item [endlich,] gdw.\ $MU_{\Sigma}(P)$ existiert und 
  $|MU_{\Sigma}(P)| \leq \infty$ für alle $\Sigma$-Unifikationsprobleme $P$ gilt. 
\item [unendlich,] gdw.\ $MU_{\Sigma}(P)$ existiert für alle
  $\Sigma$-Unifikationsprobleme $P$ und es ein
  $\Sigma$-Unifikationsproblem $P$ mit $|MU_{\Sigma}(P)|=\infty$ gibt. 
\item [null,] gdw.\ es ein $\Sigma$-Unifikationsproblem $P$ gibt, für
  das $MU_{\Sigma}(P)$ nicht existiert. 
%  eine vollständige, minmale Menge von
%  Unifikatoren für alle Unifikationsproblem existiert und deren
%  Kardinalität immer $\leq 1$ ist.
\end{description}
\end{definition}

Eine Signatur $\Sigma$ ist vom Unifikationstyp \emph{eindeutig},
wenn alle l\"osbaren $\Sigma$-{Uni\-fi\-ka\-ti\-ons\-pro\-bleme} einen
% (einzelne) allgemeinste Lösung 
mgu besitzen. Ist eine Signatur $\Sigma$ vom Unifikationstyp
\emph{endlich}, dann lassen sich alle Lösungen für ein gegebenes
$\Sigma$-Unifikationsproblem repräsentieren, als Instanzen einer
endlichen Menge von Lösungen. 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Unifikation durch Transformation}
\label{sec:uni-druch-transformation}
Ein Unifikationsproblem kann gelöst werden, indem wiederholt
Transformationen auf die Menge der Unifikationsgleichungen des
Problems angewendet werden, bis die Lösung direkt abgelesen werden
kann. 
%Ein solches Unifikatiosproblem, aus dem ein Unifikator
%unmittelbar ersichtlich ist, bezeichnet man als \emph{gelöst}.

\begin{definition}
\label{def.solved.form}
Ein Unifikationsproblem $S = \set{x_1 \ue t_1, \dots, x_n \ue t_n}$ ist
in \emph{gelöster Form}, wenn alle Variablen $x_i$ paarweise
verschieden sind und nicht in $t_i$ vorkommen
und $\ls{x_i} \in S_{\Sigma}(t_i)$\footnote{D.h. $\ls{x_i} \sqsubseteq \ls{t_i}$ für reguläre Signaturen.}
für alle $i = 1, \dots, n$. 
Für diesen Fall definiert man die Lösung von $S$ als
\[\sigma_S:= \set{x_1 \mapsto t_1, \dots, x_n \mapsto t_n}.\]
\end{definition}

Ein Unifikationsproblem in gelöster Form repräsentiert einen
mgu f\"ur dieses Problem, wie folgende Lemmata zeigen. 
\begin{lemma}
\label{lem.solved.form}
Sei $S$ ein Unifikationsproblem in gelöster Form. Dann gilt
$\tau = \tau \sigma_S$   für alle $\tau \in U_{\Sigma}(S)$.
\end{lemma}
\begin{beweis}
Sei $S = \set{x_1 \ue t_1, \dots x_n \ue t_n}$. 
Es wird durch Fallunterscheidung gezeigt, dass $\tau$ und $\tau \sigma_S$ für alle Variablen 
denselben Wert ergeben, d.h. $\tau x = \tau \sigma_S x$ für alle 
$x \in X$.
\begin{itemize}
\item $x_i \in \set{x_1, \dots, x_n}$: Wegen $\tau \in U_{\Sigma}(S)$ gilt 
  $\tau{x_i} = t_i$ und damit $\tau \sigma_S x_i = \tau t_i = \tau  x_i$. 
\item $x \notin \set{x_1, \dots, x_n}$: $\tau x = \tau \sigma_S x$
  (weil $\sigma_S x = x$). $\qed$
\end{itemize}
%{\color{red}{Beweis unterscheidet sich nicht für $\tau = \tau \sigma_S [\Var(s)]$}}
\end{beweis}

\begin{lemma}
\label{lem.solved.mgu}
Sei $S$ in gelöster Form und $\sigma_S$ die zugehörige Lösung. 
Dann gilt: $\sigma_S$ ist ein idempotenter mgu von $S$.
\end{lemma}
\begin{beweis}
Nach Definition \ref{def.solved.form} ist $\sigma_S \in U_{\Sigma}(S)$
eine Lösung von $S$ (wegen $\sigma_S x_i = t_i = \sigma_S t_i$). Nach
Lemma \ref{lem.solved.form} gilt $\sigma_S \lesssim_{\Sigma} \tau$ für
alle $\tau \in U_{\Sigma}(S)$, mit Definition \ref{def:vollst-min-mgu-menge}, 
folgt, dass $\sigma_S$ ein mgu von $S$ ist. 
%folgt $\sigma_S \in CU_{\Sigma}(S)$. 
Gelöste Formen sind so definiert (Def. \ref{def.solved.form}), dass
keine Variable $x_i$ in einem $t_i$ auftaucht, also gilt 
$\Dom(\sigma_S) \cap \VRan(\sigma_S) = \emptyset$, d.h. $\sigma_S$ ist
idempotent. $\qed$
\end{beweis}

Ein Unifikationsproblem in gelöster Form repräsentiert also eine
allgemeinste, idempotente Lösung für das Unifikationsproblem. 
Die Unifikation geht so vor, dass ein Ausgangsproblem $P_1$ durch
eine Folge von Transformationen in ein gelöstes Unifikationsproblem
$P_n$ transformiert wird
\[P_1 \Rightarrow P_2 \Rightarrow \dots \Rightarrow P_n.\]
Dabei soll gelten, dass die Transformationsschritte
die Menge der Lösungen nicht {ver\-än\-dert}, so dass die Lösung für das
Endproblem auch eine Lösung für alle vorhergehenden, insbesondere
für das Ausgangsproblem repräsentiert. 
D.h. für $P_1 \Rightarrow P_2$ 
soll gelten $U_{\Sigma}(P_1) = U_{\Sigma}(P_2)|_{\Var(P_1)}$. 
Da ein Transformationsschritt
$P_1 \Rightarrow P_2$ neue Variablen (Variablen die nicht in $P_1$
vorkommen) in das Unifikationsproblem $P_2$ einführen kann, 
wird die Menge der Lösungen des Endproblems auf die im
Ausgangsproblem vorkommenden Variablen $\Var(P_1)$ beschränkt.  
Formal definiert man:

\begin{definition}%[complet transformation]
\label{def:complete-transformation}
Sei $P_1 \Rightarrow P_2$ die Transformation eines Unifikationsproblems.
\begin{enumerate}
\item $P_1 \Rightarrow P_2$ ist \emph{korrekt}, gdw.\ $U_{\Sigma}(P_1) \supseteq U_{\Sigma}(P_2)$.
\item $P_1 \Rightarrow P_2$ ist \emph{vollständig}, gdw.\ $P_1 \Rightarrow P_2$ korrekt ist und 
  $U_{\Sigma}(P_1) \subseteq U_{\Sigma}(P_2)|_{\Var(P_1)}$, 
  d.h. $U_{\Sigma}(P_1) = U_{\Sigma}(P_2)|_{\Var(P_1)}$. 
\item Eine Menge korrekter Transformationen $P \Rightarrow P_1, \dots, P \Rightarrow P_n$
  ist eine \emph{vollständige Menge von Alternativen}, gdw.\ 
  $U_{\Sigma}(P) = U_{\Sigma}(P_1)|_{\Var(P)} \cup \dots \cup U_{\Sigma}(P_n)|_{\Var(P)}$.
%  $U_{\Sigma}(P_1)|_{\Var(P_1)} \subseteq U_{\Sigma}(P_2)|_{\Var(P_1)}$, 
%  d.h. $U_{\Sigma}(P_1)|_{\Var(P_1)} = U_{\Sigma}(P_2)|_{\Var(P_1)}$.
\end{enumerate}
\end{definition}

Für eine Signatur mit endlichem (oder unendlichem) Unifikationstyp ist
Folgendes im Bezug auf den Begriff der Vollständigkeit zu bedenken. 
%Nach dem oben beschriebenen Vorgehen, 
%der Transformation eines Unifikationsproblems zu einer gelösten Form, 
%gehen 
Bei der Transformation
eines Problems, das eine vollst\"andige Menge von L\"osungen besitzt,
gehen zwangsläufig Lösungen verloren, da die gelöste Form jeweils
nur eine Lösung repräsentiert. D.h.  
$U_{\Sigma}(P_1) \subseteq U_{\Sigma}(P_2)|_{\Var(P_1)}$ wird
nicht von allen Transformationsschritten erfüllt. 
Betrachte zur Erläuterung das Beispiel
\ref{bsp:finitary-unifing}. Dort wird das Unifikationsproblem 
$P:=\set{x_A \ue y_B}$ transformiert zu \\
\begin{tabular}{ll}
$\Rightarrow \set{x_A \ue w_C, y_B \ue w_C} := P_1$ & oder zu \\
$\Rightarrow \set{x_A \ue z_D, y_B \ue z_D} := P_2$ & \\
\end{tabular} \\
Da $P_1,P_2$ beides Lösungen von $P$ sind, $P_2$ aber keine Lösung
von $P_1$ (und umgekehrt), ist der Transformationsschritt 
$P \Rightarrow P_i, i \in \set{1,2}$ nicht vollständig.
Man schafft Abhilfe, indem man definiert:

\begin{definition}%[vollstaendige unifikationsprozedur]
\label{def:vollstaendige-unifikationsprozedur}
Eine Menge von Transformationsregeln für
Unifikationsprobleme\footnote{Diese Regeln definieren die
  Transformationsrelation  
  $\Rightarrow$ und deren reflexiven, transitiven Abschluss
  $\Rightarrow^*$ auf der Menge der Unifikationsprobleme.}
stellt eine \emph{vollständige Unifikationsprozedur} dar, wenn für
jedes Unifikationsproblem $P$ und jede Substitution 
$\tau \in U_{\Sigma}(P)$ ein Unifikationsproblem $S$ in gelöster Form
existiert, so dass $P \Rightarrow^* S$ und $\sigma_{S} \lesssim_{\Sigma} \tau [\Var(P)]$.
\end{definition}

In der Definition wird die Tatsache verwendet, dass die durch Transformationsregeln
beschriebenen 
Transformationsrelation $\Rightarrow$ auf der Menge der
Unifikationsprobleme \emph{nichtdeterministisch} ist. D.h. wenn auf
ein Unifikationsproblem mehrere Transformationen angewendet werden
können, wird eine beliebige ausgewählt. Außerdem spielt die
Reihenfolge der Anwendung von Transformationsschritten keine Rolle. Die
Vollständigkeit einer Unifikationsprozedur kann dann so verstanden
werden: Wenn für ein Unifikationsproblem $P$ der Baum aller
möglichen Transformationsfolgen (mit den nichtdeterministischen
Verzweigungen) aufgespannt wird, dann bilden die Blätter die
vollst\"andige Menge der Lösungen
$CU_{\Sigma}(P)$, wie in folgender
Abbildung beispielhaft zu sehen ist:
\[\xymatrix@C=0.15cm@R=0.5cm{
                   &                               & P \ar@{=>}[dl] \ar@{=>}[dr]      &         \\
                   & P_1 \ar@{=>}[dl] \ar@{=>}[dr] &                                  & S_2     \\
P_{11} \ar@{=>}[d] &                               & P_{12} \ar@{=>}[dl] \ar@{=>}[dr] &         \\
\bot               & S_{121}                       &                                  & S_{122} \\
& & & & & CU_{\Sigma}(P) \ar@/^/[ullll] \ar@{->}[ull] \ar@/_/[uuull]\\
}\]
Durch die Entfernung redundanter Substitutionen (d.h. durch die
Betrachtung der Faktormenge $CU_{\Sigma}(P)/_{\sim_{\Sigma}}$) kann
$CU_{\Sigma}(P)$ zu einer minimalen, vollständigen Menge von
Lösungen $MU_{\Sigma}(P)$ gemacht werden, wenn $\lesssim_{\Sigma}$
entscheidbar ist.  

%\section{Manipulation und Lösung von Gleichungssytemen}
%Unifikation als Prozess der ein ursprüngliches System von
%Unifikationsgleichungen $\Gamma$ durch Anwendung von
%Transformationsreglen manipuliert.   
%
%Es werden Transformationen auf Unifikationsproblemen betrachtet. 
%Die Transformation eines Unifikationsproblems $P_1$ zu einem
%Unifikationsproblem $P_2$ wird geschrieben als $P_1 \Rightarrow P_2$. 
%Von besonderem Interesse sind dabei Ketten $C$ von Transfromationen 
%\[P_1 \Rightarrow P_2 \dots \Rightarrow P_n.\] 
%Jedem Unifikationsproblem $P_i$ ist bezüglich der Kette $C$ von
%Transformationen eine Menge von bereits 
%\emph{verwendeten Variablen} zugeordent: $UV_K(P_i)$. 
%Im weiteren Verlauf wird der Zusatz $C$ als implizit gegeben
%betrachtet und nicht mehr aufgeschrieben. 
%Zu Beginn einer Kette von Transformationen gilt $UV(P_1) = \Var(P_1)$. 
%Für jeden Transformationsschritt $P_1 \Rightarrow P_2$ soll gelten 
%$(\Var(P_2) - \Var(P_1)) \cap UV(P_1) = \emptyset$, was bedeuten soll,
%dass verwendete Variablen in der Kette von Transfromationen nicht
%erneut eingeführt werden. Das kann dadurch erreicht werden, dass
%bei der Einführung eines neuen Terms durch einen
%Transformationsschritt in diesem Term nur Variablen verwendet werden,
%die nirgendwo sonst in der Kette von Transformaitonen vorkommen, sog
%neue Variablen. Diese Einschränkung erlaubt die Berechnung einer
%Lösung eine ursprünglichen Problems $P_1$ als Einschränkung einer
%Lösung eines transformierten Systems $P_i$ auf die Variablen aus
%$\Var(P_1)$. 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Wir betrachten nun die Transformationsregeln (auch \emph{Unifikationsregeln} genannt), 
die verwendet werden, um ein $\Sigma$-{Uni\-fi\-ka\-tions\-pro\-blem}
schrittweise in gelöste Form (oder $\bot$, wenn das Problem keine
Lösung besitzt) zu überführen. Es werden die Unifikationsregeln aus
\citeA{schmidt-schauss_computational_1989} für endliche, reguläre
Signaturen vorgestellt. Die Beschränkung auf Unifikationsregeln für
reguläre Signaturen erfolgt, weil es sich nach Korollar 
\ref{kor.sig.let.einfach} und \ref{kor:sig-let-einfach} bei der
Signatur $\Sigma^{let}$ um eine endliche und reguläre Signatur
handelt und wir vorrangig daran interessiert sind, Unifikationsprobleme 
mit $\Sigma^{let}$-Termen zu lösen, um kritische Überlappungen zu
berechnen. 
Für Unifikationsregeln in beliebigen Signaturen siehe
\citeA{schmidt-schauss_computational_1989}, S. 98.

\begin{definition}[Unifikationsregeln]% für Terme über endlichen regülaren Signaturen mit Sorten]
\label{def.unifikationsregeln}
Sei $\Sigma$ eine endliche, reguläre Signatur mit Sorten. 
Die Regeln zur Transformation von $\Sigma$-Unifikationsproblemen sind
in Abbildung \ref{fig:sorted-unifikationsreglen} definiert.

Zur Vereinfachung der Regeln und des Vollständigkeitsbeweises wird
die Annahme getroffen, dass die größte untere Schranke (glb) zweier
Sortensymbole (wenn sie existiert) eindeutig ist,
d.h. die Sortenstruktur ist ein oberer Halbverband.
Andernfalls muss die Regel \emph{Common Subsort} auf
eine Menge von glbs anstatt auf eine eindeutige glb angepasst werden.
%(zur näheren Erläuterung siehe Abschnitt \ref{sec:unifkationstyp-von-endl-einfachen-sig}
%insbesondere Definition \ref{def:maximal-sort-condtion}).

Wird eine Variable (\emph{Common Subsort}) oder eine
Termdeklaration (\emph{Weakening}) durch eine Transformation in ein
Unifikationsproblem eingeführt, darf der eingeführte Term nur
Variablen enthalten, die bisher nicht im Unifikationsproblem
vorkommen, sogenannte neue Variablen.  
\end{definition}

\begin{figure}[!htp]
\fbox{
\begin{minipage}{0.98\textwidth}
$\begin{array}{lll}
\multicolumn{3}{l}{\mathbf{Tautology}} \\
\set{s \ue s} \uplus P \Rightarrow P \\

\multicolumn{3}{l}{\mathbf{Orientation}} \\
\set{t \ue x} \uplus P \Rightarrow \set{x \ue t} \cup P \\
\quad \text{wenn} \; t \; \text{keine Variable ist.} \\

\multicolumn{3}{l}{\mathbf{Decomposition}} \\
\set{f(s_1, \dots, s_n) \ue f(t_1, \dots, t_n)} \uplus P \Rightarrow \set{s_1\ue t_1, \dots s_n \ue t_n} \cup P \\

%\multicolumn{3}{l}{\mathbf{Variable \; Elimination \; (unsorted)}} \\
%\set{x \ue t} \uplus P \Rightarrow \set{x \ue t} \cup \set{x \mapsto t} P \\
%\quad \text{wenn}\; x \notin \Var(t). \\

\multicolumn{3}{l}{\mathbf{Variable \; Elimination \; (sorted) }} \\
%{\color{red}{oder besser unsorted?}} 
\set{x \ue t} \uplus P \Rightarrow \set{x \ue t} \cup \set{x \mapsto t} P \\
\quad \text{wenn}\; x \notin \Var(t) \; \text{und} \; \ls{t} \sqsubseteq \ls{x}. \\

\multicolumn{3}{l}{\mathbf{Symbol \; Clash}} \\
\set{f(s_1, \dots, s_n) \ue g(t_1, \dots, t_m)} \uplus P \Rightarrow \bot \\

\multicolumn{3}{l}{\mathbf{Occurs \; Check}} \\
\set{x \ue t} \uplus P \Rightarrow \bot \\
\quad \text{wenn} \; x \in \Var(t) \; \text{und} \; x \neq t. \\ 

\multicolumn{3}{l}{\mathbf{Subsort}} \\
\set{x \ue y} \uplus P \Rightarrow \set{y \ue x} \cup P \\ 
\quad \text{wenn} \; \ls{x} \sqsubseteq \ls{y} \\

\multicolumn{3}{l}{\mathbf{Common \; Subsort}} \\
\set{x \ue y} \uplus P \Rightarrow \set{x \ue z, y \ue z} \cup P \\
\quad \text{wenn} \; \ls{x} \not\sqsubseteq \ls{y},  \ls{y} \not\sqsubseteq \ls{x} \; \text{und}\\
\quad z:S \; \text{ist neue Variable der Sorte}\; S=glb(\ls{x},\ls{y}). \\

\multicolumn{3}{l}{\mathbf{Sorted \; Fail \; Var}} \\
\set{x \ue y} \uplus P \Rightarrow \bot \\
\quad \text{wenn} \; \ls{x} \not\sqsubseteq \ls{y} \; \text{und} \; \ls{y} \not\sqsubseteq \ls{x} \\ 
\quad \text{und} \; glb(\ls{x},\ls{y}) \; \text{existiert nicht.} \\

\multicolumn{3}{l}{\mathbf{Weakening}} \\
\set{x \ue f(t_1, \dots, t_n)} \uplus P \Rightarrow \set{x \ue f(s_1,\dots,s_n), t_1 \ue s_1, \dots, t_n \ue s_n} \cup P \\
\quad \text{wenn} \; x \notin \Var(f(t_1, \dots, t_n)) \; \text{und} \;
\ls{f(t_1,\dots,t_n)} \not\sqsubseteq \ls{x} \; \text{und} \; \\
\quad f(s_1, \dots, s_n):S \; \text{ist Termdeklaration mit} \; S=glb(\ls{x},\ls{f(s_1, \dots, s_n)}). \\

\multicolumn{3}{l}{\mathbf{Sorted \; Fail \; Fun}} \\
\set{x \ue f(t_1, \dots, t_n)} \uplus P \Rightarrow \bot \\
\quad \text{wenn} \; x \notin \Var(f(t_1, \dots, t_n)) \; \text{und} \;
\ls{f(t_1,\dots,t_n)} \not\sqsubseteq \ls{x} \; \text{und} \\
\quad \text{es gibt keine Termdeklaration} \; f(s_1, \dots,s_n):S \; \\
\quad \text{mit} \; S=glb(\ls{x},\ls{f(s_1, \dots, s_n)}). \\ 

%\multicolumn{3}{l}{\mathbf{Sorted \; Fail \; Var}} \\
%\set{x \ue y} \uplus P \Rightarrow \bot \\
%\quad \mathsf{wenn} \; \ls{x} \not\sqsubseteq \ls{y},  \ls{y} \not\sqsubseteq \ls{x} 
%\; \mathsf{und} \; glb(\ls{x},\ls{y}) \; \mathsf{existiert \; nicht.} \\
%
%
%\multicolumn{3}{l}{\mathbf{Sorted \; Fail \; Fun}} \\
%\set{x \ue f(t_1, \dots, t_n)} \uplus P \Rightarrow \bot \\
%\quad \mathsf{wenn} \; x \notin \Var(f(t_1, \dots, t_n)) \; \mathsf{und} \\
%\quad \ls{f(t_1,\dots,t_n)} \not\sqsubseteq \ls{x} \; \mathsf{und} \; \\
%\quad S=glb(\ls{x},\ls{f(s_1, \dots, s_n)}) \; \mathsf{existiert \; nicht.} \\ \hline

%\multicolumn{3}{l}{\mathbf{Lazy \; Paramodulation}} \\
%\set{s[t]} \uplus P \Rightarrow \set{l \ue t, s[r]} \cup P \\
%\quad \mathsf{wobei}\; l = r \in E \cup E^{-} \; \mathsf{mit \; neuen \; Variablen. \; Und} \; t \; \mathsf{ist \; keine \; Variable \; und} \\
%\quad \mathsf{wenn} \;l\; \mathsf{keine \; Variable \; ist, \; dann \; sind \; Top \;Symbole \; von} \; l \; \mathsf{und} \; t \; \mathsf{gleich \; und} \\
%\quad \mathsf{auf} \; l \ue t \; \mathsf{muss \; als \; nächstes \; Dekomposition \; angewendet \; werden} \\
\end{array}$
\end{minipage}}
\caption{Unifikationsregeln für Terme mit Sorten nach Schmidt-Schauß (1989).
\label{fig:sorted-unifikationsreglen}}
\end{figure}

Die Anwendung einer Substitution $\sigma$ auf ein Unifikationsproblem 
$P = \set{s_i \ue t_i \;|\; i = 1, \dots n }$ ist definiert als
$\sigma P := \set{\sigma s_i \ue \sigma t_i \; | \; i = 1, \dots n}$.
Das Symbol $\uplus$ bezeichnet die disjunkte Vereinigung. Dadurch wird
die von einer Unifikationsregel ausgewählte Gleichung aus dem
Unifikationsproblem entfernt (die Regel \emph{Variable Elimination}
fügt die Gleichung wieder ein, da sie in gelöster Form ist
und ein Teil der Lösung des Problems darstellt).

\begin{bemerkung}%[weakening einfache sig]
\label{bem:weakening-einfache-sig}
Wenn $\Sigma$ eine einfache Signatur ist, wird die Regel
\emph{Weakening} nicht zur Unifikation benötigt. 
%Nach Korollar \ref{kor:signatur-einfach} ist in einer einfachen
%Signatur für alle $f \in \Sigma$ der Sorte von $f$ direkt aus $\Sigma$
%ablesbar. 
Zur Begründung
sei ein Unifikationsproblem $x \ue f(t_1, \dots, t_n)$ gegeben mit 
$x \notin \Var(f(t_1, \dots, t_n))$ und 
$\ls{f(t_1, \dots, t_n)} = R \not \sqsubseteq \ls{x}$. Dann existiert
wegen der Einfachheit von $\Sigma$ keine weitere Termdeklaration
$f(s_1, \dots, s_n):S$.
D.h. es kommt in diesem Fall immer zur Anwendung der Regel
\emph{Sorted Fail Fun}: Die Gleichung besitzt keine Lösung
in einer einfachen Signatur. 
\end{bemerkung}

Aus diesem Grund wird die \emph{Weakening} Regel hier beim Beweis der
Vollständigkeit nicht berücksichtigt. Der Beweis wird dadurch
vereinfacht. Für beliebige Sortenstrukturen ist \emph{Weakening} im Allgemeinen
keine vollständige Unifikationsregel und deshalb muss bei deren Vollst\"andigkeitsbeweis
%beim Beweis der Vollständigkeit 
auf Definition \ref{def:vollstaendige-unifikationsprozedur} 
zurückgegriffen werden. Aus dem gleichen Grund wird die
Vereinfachung der Regel \emph{Common Subsort} in Definition
\ref{def.unifikationsregeln} festgelegt. 
Für den kompletten Beweis siehe
\citeA{schmidt-schauss_computational_1989}, S. 102.  

\begin{lemma}
\label{lem.vollst.sorted.unifikation}
Die Unifikationsregeln aus Definition \ref{def.unifikationsregeln},
ausgenommen die Regel \emph{Weakening}, sind vollständige
Transformationsregeln für $\Sigma$-Unifikationsprobleme. 
\end{lemma}
\begin{beweis}
Für \emph{Tautology}, \emph{Orientation}, \emph{Decomposition} und
\emph{Subsort} ist offensichtlich, dass ihre Anwendung die Menge der
Lösungen nicht verändert. Wir betrachten die verbleibenden Regeln.

\emph{Variable Elimination}: 
%Sei $x \ue t$ eine Unifikationsgleichung gelöster Form. 
%Die  Anwendung von Lemma \ref{lem.solved.form} ergibt, dass gilt $\sigma = \sigma \set{x \mapsto t}$ 
%gdw. $\sigma x = \sigma t$. Verwende dies in folgenden äquivalenzumformungen 
%\[\begin{array}{lcl}
%\sigma \in U_{\Sigma}(\set{x \ue t} \uplus P) & \Leftrightarrow & \sigma x = \sigma t \wedge \sigma \in U_{\Sigma}(P) \\
%& \Leftrightarrow & \sigma x = \sigma t \wedge \sigma \set{x \mapsto t} \in U_{\Sigma}(P) \\
%& \Leftrightarrow & \sigma x = \sigma t \wedge \sigma \in U_{\Sigma}(\set{x \mapsto t}P) \\
%& \Leftrightarrow & \sigma \in U_{\Sigma}(\set{x \ue t} \cup \set{x \mapsto t}P) \\
%\end{array}\]
Zur Korrektheit sei $\sigma \in U_{\Sigma}(\set{x \ue t} \uplus P)$,
d.h. $\sigma$ unifiziert $x$ mit $t$, also haben wir $\sigma x = \sigma t$
%da $x \ue t$ in gelöster Form ist, folgt mit Lemma \ref{lem.solved.form}:
und damit auch $\sigma = \sigma \set{x \mapsto t}$ (vgl. Lemma \ref{lem.solved.form}),
woraus 
$\sigma \set{x \mapsto t} \in U_{\Sigma}(\set{x \ue t} \cup P)$ folgt,
was äquivalent zu 
$\sigma \in U_{\Sigma}(\set{x \ue t} \cup \set{x \mapsto t}P)$ ist.
Für den noch fehlenden Teil der Vollständigkeit sei 
$\sigma \in U_{\Sigma}(\set{x \ue t} \cup \set{x \mapsto t} P)$. 
Wieder wird $x$ mit $t$ unifiziert: $\sigma x = \sigma t$ 
und deswegen $\sigma = \sigma \set{x \mapsto t}$, womit 
$\sigma \in U_{\Sigma}(\set{x \ue t} \uplus P)$ folgt.
An dieser Stelle macht es keinen Unterschied, ob $\set{x \mapsto t}$
wohlsortiert ist oder nicht. 

\emph{Symbol Clash}:
Eine Gleichung $f(s_1, \dots, s_n) \ue g(t_1, \dots, t_m)$ besitzt
keine Lösung: \\
$\sigma f(s_1, \dots, s_n) = f(\sigma s_1, \dots, \sigma s_n)\neq 
g(\sigma t_1, \dots, \sigma t_m) = \sigma g(t_1, \dots, t_m)$.

\emph{Occurs Check}:
Eine Gleichung der Form $x \ue t$ mit $x \in \Var(t)$ und $x \neq t$
besitzt keine Lösung: Wegen $x \neq t$ hat $t$ die Form 
$f(t_1, \dots, t_n)$ mit $x \in \Var(t_i)$ für ein $i$. 
Dann kann es keine Substitution geben, so dass 
$\sigma(x) = \sigma(t)$, weil sich die Größen der Lösungsterme
unterscheiden: $|\sigma(x)| \leq |\sigma(t_i)| < |\sigma(t)|$.

\emph{Common Subsort}: Sei $\sigma \in U_{\Sigma}(\set{x \ue y} \uplus P)$, 
d.h. es gilt $\sigma x = \sigma y$; da $\sigma$ wohlsortiert ist
haben wir $\ls{\sigma x} \sqsubseteq glb(\ls{x},\ls{y})$. Sei au"serdem $z:S$
eine neue Variable mit $S = glb(\ls{x},\ls{y})$\footnote{Hier wird die Annahme
verwendet, dass die $glb$ eindeutig ist. Ist sie das nicht, muss ein
Element ausgewählt werden. \emph{Common Subsort} ist für diesen
Fall nicht mehr vollständig.} 
und $X = \Var(\set{x \ue y} \cup P)$. Betrachte folgende
Äquivalenzumformungen:
\[\begin{array}{lcl}
\sigma \in U_{\Sigma}(\set{x \ue y} \uplus P) & \Leftrightarrow & \sigma x = \sigma y \wedge \sigma \in U_{\Sigma}(P) \\
& \Leftrightarrow & \sigma x = \sigma z \wedge \sigma y = \sigma z \wedge \sigma \in U_{\Sigma}(P)|_X \\
& \Leftrightarrow & \sigma \in U_{\Sigma}(\set{x \ue z, y \ue z} \cup P)|_X  \\
\end{array}\]

\emph{Sorted Fail}:
Existiert $glb(\ls{x},\ls{y})$ nicht, hat die Gleichung $x \ue y$ für 
$\ls{x} \not\sqsubseteq \ls{y}$ und $\ls{y} \not\sqsubseteq \ls{x}$ keine
wohlsortierte Lösung.
%d.h. Sorted Fail Var ist eine vollständige
%Transformationsregeln für Unifikationsproblem. 

\emph{Sorted Fail Fun}:  
$\sigma \in U_{\Sigma}(\set{x \ue f(t_1, \dots, t_n)} \uplus P)$
impliziert $\sigma x = \sigma f(t_1, \dots, t_n)$ und weil $\sigma$
wohlsortiert ist, muss gelten 
$\ls{\sigma x} \sqsubseteq glb(\ls{x},\ls{f(t_1, \dots, t_n)})$ bzw. 
$\ls{\sigma f(t_1,\dots, t_n)} \sqsubseteq glb(\ls{x},\ls{f(t_1,\dots, t_n)})$. 
Nach Proposition \ref{prop.gen.sort.term} existiert dann eine
Termdeklaration $f(s_1, \dots, s_n):S$, so dass 
$S \sqsubseteq glb(\ls{x},\ls{f$ $(t_1,\dots, t_n)})$. Existiert keine
solche Termdeklaration, besitzt die Gleichung keine Lösung. 
$\qed$
\end{beweis}

%{\color{red}{vollständigkeit von Common Subsort, wenn 
%    $(S_{\Sigma},\sqsubseteq)$ kein Teilverband ist.}}

Der Algorithmus \emph{Unify} in Abbildung \ref{fig:unify} verwendet die definierten
Unifikationsregeln, um rekursiv eine Lösung für ein gegebenes  
Unifikationsproblem $P$ zu berechnen.  

%\begin{algorithm}[H]
%%\nocaptionofalgo
%\dontprintsemicolon
%%\SetKwFunction{Unify}{Unify}
%$Unify(P)$ = \;
%{\Indp \Indp 
%\uIf{es gibt ein $P'$, so dass $P \Rightarrow P'$}{$Unify(P')$}
%\uElse{\uIf{$P$ ist in gelöster Form}{Gebe $\sigma_P$ als Lösung zurück.}
%       \uElse{Stoppe mit Antwort: $P$ besitzt keine Lösung.}}}
%%             & $\quad \quad$ Ja: Gebe $\sigma_P$ als Lösung zurück. \\
%%             & $\quad \quad$ Nein: Stoppe, mit Antwort: $P$ besitzt keine Lösung.\\
%\caption{\color{red}{$Unify(P)$}}
%\end{algorithm}

\begin{figure}[ht]
\center
\fbox{
\begin{minipage}{0.98\textwidth}
\begin{tabbing}
%\qquad\=\hspace{\lwidth}\=\hspace{\cwidth}\=\+\kill
${\Conid{\Unify}\;(\Conid{P})\mathrel{=}\mathbf{if}\;\Varid{es}\;\Varid{gibt}\;\Varid{ein}\;\Conid{P'},\Varid{so}\;\Varid{dass}\;\Conid{P} \Conid{\Rightarrow}\;\Conid{P'}}$\\
${\phantom{\Conid{\Unify}\;(\Conid{P})\mathrel{=}\mbox{}}\mathbf{then}\;\Conid{\Unify}\;(\Conid{P'})}$\\
${\phantom{\Conid{\Unify}\;(\Conid{P})\mathrel{=}\mbox{}}\mathbf{else}\;\mathbf{if}\;
  \Conid{P}\;\Varid{ist}\;\Varid{in}\;\Varid{geloester}\;\Conid{Form}\;\mathbf{then}\;
  \mathbf{return}\; \Varid{\sigma_P}}$\\
${\phantom{\Conid{\Unify}\;(\Conid{P})\mathrel{=}\mbox{}}\phantom{\mathbf{else}\;\mbox{}}\mathbf{else}\;\mathbf{return}\;
  \Conid{P}\;\Varid{ist}\;\Varid{nicht}\;\Varid{loesbar}}$
\end{tabbing}
\end{minipage}}
\caption{Der \emph{Unify} Algorithmus zur Unifikation von Termen mit
  Sorten. \label{fig:unify}}
\end{figure}

Weil alle von \emph{Unify} zur Unifikation verwendeten Regeln nach
Lemma \ref{lem.vollst.sorted.unifikation} {voll\-stän\-dig} sind, folgt direkt:
\begin{korollar}%[vollst unify]
\label{kor:vollst-unify}
\emph{Unify} ist ein vollständiger
Unifikationsalgorithmus für endliche und einfache Signaturen.
\end{korollar}

%\begin{tabular}{ll}
%$Unify(P)$ = & Wenn eine $SOUP$-Unifikationsregel auf $P$ anwendbar ist, \\
%             & $\quad$ dann: $P \Rightarrow P'$ und rekursiv weiter mit $Unify(P')$. \\
%             & $\quad$ Sonst: Ist $P$ in gelöster Form? \\
%             & $\quad \quad$ Ja: Gebe $\sigma_P$ als Lösung zurück. \\
%             & $\quad \quad$ Nein: Stoppe, mit Antwort: $P$ besitzt keine Lösung.\\
%\end{tabular} 

Der Unifikationsalgorithmus ist nicht deterministisch. Wenn mehr als
eine Unifikationsregel anwendbar ist, wählt der Algorithmus eine
beliebige aus. Die Terminierung von $\Unify$ hängt davon ab, ob die
Anwendung der Transformationsschritte $\Rightarrow$ terminiert. 
\citeA{schmidt-schauss_computational_1989} zeigt, dass für reguläre,
elementare Signaturen, deren Sortenstruktur ein oberer Halbverband ist,
%und die einen Topsort besitzen
die Anwendung der Transformationsschritte
terminiert. In Anlehnung daran soll hier kurz erläutert werden,
weshalb $\Unify$ für endliche, einfache Signaturen terminiert. 
Eine Schwierigkeit des Beweises liegt darin, dass sich durch Anwendung
der Regeln \emph{Variable Elimination} und \emph{Common Subsort} ein
Unifikationsproblem vergrößern kann, wie z.B. 
$\set{x \ue f(a,b), g(x) \ue y} \Rightarrow \set{x \ue f(a,b), g(f(a,b)) \ue y}$.
Die Lösung besteht darin, ein Komplexitätsmaß zu finden, das zeigt,
dass trotz einer möglichen Vergrößerung des Problems, die
Transformationen das Problem näher an eine gelöste Form bringen. 

Für endliche und einfache Signaturen muss die Regel  
\emph{Weakening} für die Terminierung nicht betrachtet werden, 
weil sie in solchen Signaturen zur Unifikation nicht benötigt wird 
(Bemerkung \ref{bem:weakening-einfache-sig}).
Die Regeln \emph{Subsort} und \emph{Common Subsort} werden leicht
angepasst:

$\begin{array}{lll}
\multicolumn{3}{l}{\mathbf{Subsort^*}} \\
\set{x \ue y} \uplus P \Rightarrow \set{y \ue x} \cup \set{y \mapsto x} P \\ 
\quad \mathsf{wenn} \; \ls{x} \sqsubset \ls{y} \\

\multicolumn{3}{l}{\mathbf{Common \; Subsort^*}} \\
\set{x \ue y} \uplus P \Rightarrow \set{x \ue z, y \ue z} \cup \set{x \mapsto z, y \mapsto z} P\\
\quad \mathsf{wenn} \; \ls{x} \not\sqsubseteq \ls{y},  \ls{y} \not\sqsubseteq \ls{x} \; \mathsf{und}\\
\quad z:S \; \mathsf{ist \; neue \; Variable \; der \; Sorte}\; S=glb(\ls{x},\ls{y}). \\
\end{array}$

\begin{lemma}%[Terminierung von Unify]
\label{lemma:terminierung-von-unify}
Sei $\Sigma$ eine endliche, einfache Signatur. Dann terminiert $\Unify(P)$
für alle $\Sigma$-Unifikationsprobleme $P$. 
\end{lemma}
\begin{beweis}
Zuerst halten wir fest: Wird eine der Regeln \emph{Symbol Clash}, 
\emph{Occurs Check}, \emph{Sorted Fail Var} oder \emph{Sorted Fail Fun} 
auf $P$ angewendet, dann terminiert $\Unify$ mit der Antwort: $P$
besitzt keine Lösung. 

Für alle anderen Regeln wird gezeigt, dass ihre Anwendung ein
Unifikationsproblemen zugeordnetes Komplexitätsmaß verkleinert. 

Eine Variable $x$ wird als gelöst bezeichnet, wenn sie genau einmal
in $P$ vorkommt und zwar auf der linken Seite einer Gleichung $x \ue t$, so
dass $x \notin \Var(t)$.
% und $\ls{x} \sqsupseteq \ls{t}$ 
Einem Unifikationsproblem $P$ wird das Komplexitätsmaß $(n_1,n_2,n_3)$
zugeordnet, so dass 
\begin{itemize}
\item [$n_1$] die Anzahl der Variablen in $P$ ist, die nicht gelöst sind,
\item [$n_2$] die Größe von $P$ ist: $\sum_{(s \ue t) \in P} (|s| +  |t|)$, und
\item [$n_3$] die Anzahl der Gleichungen der Form $t = x$ in $P$ ist,
  wobei $t$ keine Variable ist. 
\end{itemize}
Folgende Tabelle zeigt, dass jede Anwendung einer Unifikationsregel
die Tripel bezüglich der lexikographischen
Ordnung\footnote{Die lexikographische Ordnung ist für Tripel natürlicher Zahlen durch \\ 
$(a,b,c) > (a',b',c') : \Leftrightarrow (a > a') \vee (a = a' \vee b > b') \vee (a=a', b=b', c > c')$ definiert.}
verkleinert: 

\begin{longtable}{lccc}
                  & $ n_1 $  & $ n_2 $ & $ n_3$ \endhead 
\emph{Tautology}  & $ \geq $ & $ > $   & \\
\emph{Orientation} & $ \geq $ & $ = $ & $ > $ \\
\emph{Decomposition} & $ \geq $ & $ > $ & \\
\emph{Elimination} & $ > $ & $ $ & \\
\emph{$Subsort^*$} & $ > $ & $ $ & \\
\emph{Common $Subsort^*$} & $ > $ & $ $ & \\
\end{longtable}

\emph{Tautology} und \emph{Decomposition} verkleinern $n_2$.
\emph{Orientation} verändert $n_2$ nicht, verkleinert aber $n_3$.
\emph{Elimination}, $Subsort^*$ und $Common \;Subsort^*$ verkleinern
$n_1$, das durch keine andere Regel vergrößert wird. $\qed$
\end{beweis}

Der Beweis verdeutlicht noch einmal, dass die Reihenfolge, in der
Unifikationsregeln auf ein Unifikationsproblem angewendet werden, keine
Rolle spielen. Sind mehrere Regeln auf ein Problem anwendbar, kann
eine beliebige ausgewählt werden, um das Problem zu transformieren,
ohne etwas am Terminierungsverhalten des Algorithmus
zu verändern. 
%{\color{red}{Determinisierung des Algos: Vollst. Menge von Alternativen}}

\begin{satz}%[completeness of unify]
\label{satz:completeness-unify}
Sei $\Sigma$ eine endliche und einfache Signatur. 
Für alle $\Sigma$-{Uni\-fi\-ka\-ti\-ons\-pro\-bleme} $P$ gilt:
\begin{itemize}
\item Wenn $P$ lösbar ist, dann terminiert $\Unify(P)$ mit einer
   L\"osung $\sigma$ aus der vollst\"andigen Menge der L\"osungen
   $CU_{\Sigma}(P)$ von $P$.  
\item Wenn $P$ nicht lösbar ist, dann terminiert $\Unify(P)$ mit der
  Antwort: $P$ ist nicht lösbar. 
\end{itemize}
\end{satz}
\begin{beweis}
$\Unify$ ist vollständig (Korollar \ref{kor:vollst-unify}) und
terminiert (Lemma \ref{lemma:terminierung-von-unify}), deswegen reicht
es zu zeigen: Wenn das Unifikationsproblem $P$ lösbar ist, dann wird
es von $\Unify$ in eine gelöste Form $S$ überführt.
Nach Lemma \ref{lem.solved.mgu} repräsentiert $\sigma_{S}$ dann einen
Unifikator aus der vollst\"andigen Menge der Unifikatoren von $P$.  
%{\color{red}{Wenn $P$ nicht lösbar, dann ist Resultat von Unify $\bot$.}}

Sei $S \neq \bot$ das Unifikationsproblem mit dem $\Unify(P)$
terminiert. $S$ enthält keine Gleichungen der Form
$x \ue x$ (wegen \emph{Tautology}),
$t \ue x$ (wegen \emph{Orientation}),
$f(\dots) \ue f(\dots)$ (wegen \emph{Decomposition}),
$f(\dots) \ue g(\dots)$ (wegen \emph{Symbol Clash}).
Also sind alle in $S$ enthaltenen Gleichungen von der Form $x \ue t$, 
mit $x \notin \Var(t)$ (wegen \emph{Occurs Check}) und 
$\ls{x} \sqsupseteq \ls{t}$, d.h. $\sigma_{S}$ ist wohlsortiert (wegen
\emph{Subsort}, \emph{Common Subsort}, \emph{Sorted Fail Var} und
\emph{Sorted Fail Fun}). Wegen \emph{Variable Elimination} kommt kein $x$ mehr
als einmal in $S$ vor. Folglich ist $S$ in gelöster Form. $\qed$
\end{beweis}

%\begin{beispiel}
%Betrachte folgendes Unifikationsproblem mit $\Sigma^{let}$-Termen:
%
%$\begin{array}{rl}
%& \set{app(abs(x_V,s_T), y_V) \ue app(t_T, s_T)} \\
%\mathsf{Decomposition} \Rightarrow & \set{abs(x_V,s_T) \ue t_T, y_V \ue s_T} \\
%\mathsf{Subsort} \Rightarrow & \set{t_T \ue abs(x_V,s_T), y_V \ue s_T} \\
%\mathsf{Subsort} \Rightarrow & \set{t_T \ue abs(x_V,s_T), s_T \ue y_V} \\
%\mathsf{Variable \; Elimination} \Rightarrow & \set{t_T \ue abs(x_V,y_V), s_T \ue y_V} \\
%\end{array}$
%
%Nach der letzten Transformation ist das Problem in gelöster Form.
%Der berechnete allgemeinste Unifikator ist $\set{t_T \mapsto abs(x_V,y_V), s_T \mapsto y_V}$. 
%\end{beispiel}
%
% Entwicklung der Komplexitätsmaßes aus Lemma \ref{lemma:terminierung-von-unify}:
% (4,8,0) > (4,6,0) > (3,6,0) > (2,6,0)
%
%Am Beispiel sieht man, dass die Wahl der Transformation
%nichtdeterministisch ist. Die beiden \emph{Subsort}-Schritte sind
%vertauschbar. 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Der Unifikationstyp von endlichen und einfachen Signaturen}
\label{sec:unifkationstyp-von-endl-einfachen-sig}

Zur Berechnung aller Überlappungen zwischen zwei Termen $s,t$ muss
die (minimale) {voll\-stän\-dige} Menge der Unifikatoren 
f\"ur alle Subterme (die keine Variablen sind) $s_i$ und $t_i$ von $s$ und $t$
%und aller Subterme (die keine Variablen sind) von $s$ und $t$ 
%($MU_{\Sigma}(\set{s \ue t})$) 
bestimmt werden. Da wir vor allem 
an der Signatur $\Sigma^{let}$ interessiert sind, stellt sich die
Frage nach dem Unifikationstyp von endlichen, einfachen Signaturen. 
Das Vorhaben der Berechnung aller Überlappungen würde scheitern,
wenn der Unifikationstyp hier \emph{unendlich} w\"are. Aus der
Terminierung von $\Unify$ (Lemma \ref{lemma:terminierung-von-unify}) 
kann man allerdings direkt schließen:
\begin{korollar}%[unifikationstyp fuer endliche einfache Signaturen]
\label{kor:unifkationstyp-end-einf-sig}
Endliche und einfache Signaturen sind vom Unifikationstyp \emph{endlich}.
%{\color{red}{endliche, regul\"are, elementare Signaturen haben den
%    Unifikationstyp \emph{endlich}. \\ Folgt aus Terminierung}}
\end{korollar}

Die Tatsache, dass die Regel \emph{Weakening} zur Unifikation in
einfachen Signaturen nicht benötigt wird (siehe Bemerkung
\ref{bem:weakening-einfache-sig}), sowie der im Vollständigkeitsbeweis 
der Unifikationsregeln (Lemma \ref{lem.vollst.sorted.unifikation} sowie
Beispiel \ref{bsp:finitary-unifing})
gegebenen Hinweise, dass die Regel \emph{Common Subsort} nicht
vollständig ist, wenn für zwei Sorten eine Menge größter unterer
Schranken existiert, sind Indizien 
dafür, dass in einfachen Signaturen der Unifikationstyp komplett von
der Sortenstruktur determiniert wird. 
Im Folgenden wird ein Resultat von 
%Information über die Sort-Struktur (auch Sort-Hierarchie genannt) können 
%verwendet werden, um Aussagen die Eigenschaften von
%Unifikationsalgorithmen für sorted Terme zu machen. 
\citeA{walther_many-sorted_1988} verwendet, der zeigt, 
dass für einfache Signaturen der Unifikationstyp
als Funktion der Sortenstruktur charakterisiert werden kann. 

%Sei $(S_{\Sigma},\sqsubseteq)$ eine partielle Ordnungrelation,
%$\mathscr{S} \subset S_{\Sigma}$ eine nichtleere Teilmenge. Dann definiert
%man $max(\mathscr{S}):= \set{S_0 \in \mathscr{S} \; | \; S_0 \not\sqsubset S \; \forall S \in \mathscr{S}}$
%und $lbs(\mathscr{S}):= \set{S_0 \in S_{\Sigma} \; | \; S_0 %\sqsubseteq S \; \forall S \in \mathscr{S}}$
Sei $\Sigma$ eine endliche und einfache Signatur. Die zugehörige
Sortenstruktur $(S_{\Sigma},\sqsubseteq_{\Sigma})$\footnote{Es wird hier
  verlangt, dass $\sqsubseteq_{\Sigma}$ eine Partialordnung auf
  $S_{\Sigma}$ ist.}  
wird durch eine sogenannte \emph{maximal-sorts-condition} klassifiziert.
\begin{definition}%[maximal sort condition]
\label{def:maximal-sort-condtion}
Eine partiell geordnete Menge $(S_{\Sigma}, \sqsubseteq_{\Sigma})$ erfüllt die
\emph{maximal-sorts-condition}, gdw.\ für alle nichtleeren Teilmengen 
$M \subset S_{\Sigma}$ gilt
\[\forall S \in lbs(M) \; \exists S_m \in max(lbs(M)), \; \text{so dass} \; S \sqsubseteq_{\Sigma} S_m.\]
$(S_{\Sigma},\sqsubseteq_{\Sigma})$ hat den \emph{Grad} 1, gdw.\ 
$|max(lbs(M))| \leq 1$ oder den \emph{Grad} $\omega$ (endlich), gdw.\ 
$|max(lbs(M))| < \infty$ für alle nichtleeren Teilmengen $M \subset S_{\Sigma}$.
%$(S_{\Sigma},\sqsubseteq_{\Sigma})$ hat den \emph{Grad} $infty$, wenn
%$(S_{\Sigma},\sqsubseteq_{\Sigma})$ keinen Grad $\omega$ hat. 
\end{definition}

Einer Sortenstruktur, in der jede endliche Teilmenge eine eindeutige 
(oder gar keine)
größte untere Schranke besitzt, wird der Grad 1 zugeordnet. 
Dieser Fall entspricht der ersten Bedingung der Definition eines
oberen Halbverbandes (siehe Definition \ref{def:min-max-glb}). 
Gibt es in der Sortenstruktur eine Teilmenge, die mehr als eine größte
untere Schranke besitzt, erhält sie den Grad $\omega$ (für endlich). 
Der Satz von Walther stellt ein Verbindung zwischen dem Grad einer
Sortenstruktur und dem Unifikationstyp der zugrundeliegenden Signatur her.

\begin{satz}[\citeNP{walther_many-sorted_1988}]
\label{satz.walther}
Sei $\Sigma$ eine endliche und einfache Signatur, 
$(S_{\Sigma},\sqsubseteq_{\Sigma})$ die zugehörige Sortenstruktur, die 
die maximal-sorts-condition erfüllt. Dann gilt:
\begin{itemize}
\item $(S_{\Sigma},\sqsubseteq_{\Sigma})$ hat den Grad 1, gdw.\ $\Sigma$
   den Unifikationstyp \emph{eindeutig} hat.
\item $(S_{\Sigma},\sqsubseteq_{\Sigma})$ hat den Grad $\omega$, gdw.\ $\Sigma$
   den Unifikationstyp \emph{endlich} hat.
\end{itemize}
\end{satz}

Es ist einfach zu zeigen, dass die durch $\Sigma^{let}$ definierte
Sortenstruktur die maximal-sorts-condition erfüllt und einen Grad von 1 hat. 

\begin{proposition}
\label{prop.grad.sigma-let}
Die durch $\Sigma^{let}$ (in Beispiel \ref{bsp.sig.let}) definierte
Sortenstruktur \mbox{$(S_{\Sigma^{let}},\sqsubseteq_{\Sigma^{let}})$} 
erfüllt die maximal-sorts-condition und hat den Grad 1. 
\end{proposition}
\begin{beweis}
\sloppy
%{\color{red}{Die folgende Bemerkung evtl. vorziehen zu Bsp}}
Die Ordnungsrelation $\sqsubseteq_{\Sigma^{let}}$ ist eine
Partialordnung, weil für alle Sortensymbole $S,R \in S_{\Sigma^{let}}$
gilt $S \sqsubseteq R \; \wedge \; R \sqsubseteq S \Rightarrow S = R$ 
(Antisymmetrie). 

Seien $S \subseteq \set{V,A,T}$ und $R \subseteq \set{B,U}$
nichtleere Teilmengen.
Dann gilt $lbs(S \cup R) = \emptyset$, weil es kein Sortensymbol 
$T \in S_{\Sigma^{let}}$ gibt, das mit Elementen aus $S$ und
gleichzeitig mit Elementen aus $R$ vergleichbar ist. 
Deswegen gilt auch $|max(lbs(S \cup R))| = 0$.  
Ebensowenig existieren $lbs(\set{V,A,T})$, und $lbs(V,A)$.

Betrachte die Teilmenge $\set{V,T} \subset S_{\Sigma^{let}}$, hier gilt
$lbs(V,T) = \set{V}$ und $max(\set{V}) = \set{V}$ 
(wegen $V \not\sqsubset V$) sowie $V \sqsubseteq V$ (wegen
Reflexivit\"at) und deshalb $|max(lbs(V,T))|=1$. 
Die Argumentation ist analog für 
die Teilmengen $\set{A,T}, \set{B,U} \subset S_{\Sigma^{let}}$. 

Sei $\set{R} \subset S_{\Sigma^{let}}$ eine einelementige Teilmenge. 
Dann gilt $lbs(\set{R}) = max(lbs(\set{R}))$, wegen $R
\sqsubseteq R$ und  $R \not\sqsubset R$ für alle $R$ und außerdem
$|max(lbs(\set{R}))| = 1$.  

Folglich erfüllt $(S_{\Sigma^{let}}, \sqsubseteq_{\Sigma^{let}})$ die
maximal-sorts-condition und weil $|max(lbs(S))| \leq 1$ für alle
nichtleeren Teilmengen $M \subset S_{\Sigma^{let}}$ gilt, hat die durch 
$\Sigma^{let}$ definierte Sortenstruktur den Grad 1. $\qed$ 
\end{beweis}

Aus dieser Proposition und dem Satz von Walther folgt sofort:
\begin{korollar}
\label{kor.walther}
Die Signatur $\Sigma^{let}$ hat den Unifikationstyp \emph{eindeutig}.
\end{korollar}
%\begin{beweis}
%Folgt direkt aus dem Satz von Walther und Proposition
%\ref{prop.sort.hierarchie}. $\qed$
%\end{beweis}

Nun wird auch klar, weshalb bei der Definition der Unifikationsregeln
(\ref{def.unifikationsregeln}) die Annahme getroffen wurde, dass in
den betrachteten Sortenstrukturen die glb zweier Elemente eindeutig
bestimmt ist und nicht weiter auf den Fall eingegangen wurde, dass eine 
Menge gr\"o"ster unterer Schranken existiert:
In der Signatur $\Sigma^{let}$ haben wir es
mit dem angenehmen Fall zu tun, dass eine eindeutige (oder gar keine)
größte untere Schranke existiert, weshalb nach dem Satz von Walther
der Unifikationstyp dieser Signatur \emph{eindeutig} ist.

Als Endresultat können wir für die endliche und einfache Signatur
$\Sigma^{let}$ festhalten: 
\begin{satz}%[eigenschaften der sigma-let unifikation]
\label{satz:eigensch-der-sigma-let-uni}
Für alle $\Sigma^{let}$-Unifikationsprobleme $P$ gilt:
Wenn $P$ lösbar ist, dann besitzt $P$ einen mgu, der
durch den Unifikationsalgorithmus $\Unify(P)$ berechnet wird.  
Ist $P$ nicht lösbar, stoppt $\Unify(P)$ mit der Antwort: $P$ besitzt
keine Lösung. 
\end{satz}
\begin{beweis}
Folgt direkt aus Satz \ref{satz:completeness-unify} und
Korollar \ref{kor.walther}. $\qed$
\end{beweis}

Dieses Resultat ist sehr erfreulich, vor allem wenn man bedenkt, dass es
endliche und einfache Signaturen gibt, deren Unifikationstyp
\emph{endlich} ist. Betrachtet man allgemeine Signaturen (die keinen
Beschränkungen wie Regularität oder Endlichkeit unterliegen), dann
gilt, dass $\Sigma$-Unifikation unentscheidbar ist 
(siehe \citeA{schmidt-schauss_computational_1989}). 

\subsection{Effizienz der Unifikation in endlichen und einfachen Signaturen}
\label{sec:effizienz-der-unif}
Der nichtdeterministische Algorithmus $\Unify$ benötigt
exponentiell viel Zeit und Platz, was an folgendem Beispiel
verdeutlicht werden soll.
\begin{beispiel}%[unify exp zeit platz]
\label{bsp:unify-exp-zeit-platz}
Sei $\Sigma$ eine Signatur mit nur einer Sorte
und alle Symbole seien von dieser Sorte. Betrachte folgendes
$\Sigma$-Unifikationsproblem
\[\set{x_1 \ue f(x_0,x_0), x_2 \ue f(x_1,x_1), \dots, x_n \ue f(x_{n-1},x_{n-1}}.\]
Der idempotente mgu, den man durch wiederholte Anwendung von
\emph{Variable Elimination} erhält ist 
\[\set{x_1 \mapsto f(x_0,x_0), x_2 \mapsto f(f(x_0,x_0),f(x_0,x_0)), \dots}.\]
Hier wird jeder Variable $x_i$ ein vollständiger binärer Baum der
Höhe $i$ zugeordnet. Folglich ist die Größe des mgu exponentiell
in der Größe des zu lösenden Unifikationsproblems. Das gilt
auch für alle anderen mgu des Unifikationsproblems, da diese zum oben
angegebenen äquivalent modulo Variablenumbenennung sind. 
\end{beispiel}

Das Problem in obigem Beispiel ist, dass durch 
\emph{Variable Elimination} Terme kopiert
werden. Unifikationsalgorithmen, die das Kopieren von Termen vermeiden,
weisen einen besseren Zeit- und Platzbedarf
auf. \citeA{paterson_linear_1976} beschreiben eine Methode, mit der
in linearer Zeit entschieden werden kann, ob Terme ohne Sorten
unifizierbar sind. An dieser Stelle soll
(in Anlehnung an \citeA{schmidt-schauss_computational_1989})
kurz beschrieben werden, wie
der Unifikationsalgorithmus von 
%, für Terme ohne Sorts, von
\citeA{martelli_efficient_1982}, der eine quasi-lineare Laufzeit besitzt,  
%der das Kopieren von Termen ebenfalls vermeidet,
verwendet werden kann, um Terme über einer einfachen Signatur 
effizient zu unifizieren.  
Dieser Algorithmus verwendet Multigleichungen. Die Multigleichung 
$t_1 \ue t_2 \ue t_3$ entspricht den beiden Gleichungen $t_1 \ue t_2$
und $t_2 \ue t_3$. Wenn ein gegebenes Unifikationsproblem eine
Lösung besitzt, dann stoppt der Algorithmus mit einer Menge von
Multigleichungen in gelöster Form: $x_1 \ue x_2 \dots \ue x_n \ue t$,
wobei alle Variablen paarweise verschieden sind
(über die Menge aller Multigleichungen), und maximal ein Term, 
der keine Variable ist, pro Multigleichung vorkommt. Diese gelöste
Form stellt eine Repräsentation der Lösung dar und noch nicht die
Substitution, die das Problem löst. Um die Substitution aus
der Repräsentation zu gewinnen, muss diese voll instantiiert werden. 

\begin{proposition}%[quasi linear uni einfach]
\label{prop:quasi-linear-uni-einfach}
Unifikation für einfache Signaturen benötigt höchstens
quasi-lineare Zeit. 
\end{proposition}
\begin{beweis}
Sei $\Sigma$ eine einfache Signatur und $P$ ein einfaches
$\Sigma$-Unifikationsproblem. Dann gehe zur Unifikation von $P$
folgendermaßen vor:
Berechne mit dem Unifikationsalgorithmus von
\citeauthor{martelli_efficient_1982} eine Menge von Multigleichungen in
gelöster Form $\set{M_1, \dots, M_n}$. Ignoriere dabei alle
Sorten, d.h. die Multigleichungen sind i.A. nicht
wohlsortiert. Dies geht in quasi-linearer Zeit. Außerdem werden
keine neuen Variablen eingeführt. 
Dann verfahre folgendermaßen mit allen Multigleichungen $M_i$:
\begin{enumerate}
\item $M_i$ besteht nur aus Variablen. Sei $X$ die Menge der in
  $M_i$ vorkommenden Variablen. Berechne die Menge der
  (kleinsten) Sorten dieser Variablen 
  $SX:=glb(\set{\ls{x} \; | \; x \in X})$, was in linearer Zeit geht, da 
  für endliche Signaturen $\ls{x} = \mathbb{S}(x)$
  (nach Proposition \ref{prop.reg.sig}) gilt. Folgende Fälle werden
  unterschieden: 
  \begin{itemize}
    \sloppy
  \item $SX=\emptyset$, dann besitzt das Unifikationsproblem keine
    wohlsortierte Lösung.
  \item $SX = \set{S}$, dann repräsentiert $M_i$ eine
    wohlsortierte Komponente der gelösten Form.
  \item $SX = \set{S_1, \dots, S_m}$, dann sind die 
    Elemente der Menge 
    $\set{\set{x_1 \ue y_{S_i}, \dots, x_{|X|} \ue y_{S_i}} \;
    | \; i = 1, \dots m}$\footnote{Dabei ist $y_{S_i}$ jeweils eine
    neue Variable, die nicht im ursprünglichen Unifikationsproblem vorkommt.}
    %eingeschränkt auf die Variablen in $X$, 
    jeweils wohlsortierte Komponenten einer gelösten Form.
  \end{itemize}
\item $M_i$ besteht aus Variablen und einem Term $t$. Sei $X$ die
  Menge der in $M_i$ vorkommenden Variablen. Berechne
  $SX:=glb(\set{\ls{x} \; | \; x \in X})$ und unterscheide:
  \begin{itemize}
    \sloppy
  \item $SX=\emptyset$, dann besitzt das Unifikationsproblem keine
    wohlsortierte Lösung.
  \item $SX = \set{S}$, und es gilt $S \sqsupseteq \ls{t}$, dann
    repräsentiert $M_i$ eine wohlsortierte Komponente der gelösten Form.
    Außerdem kann $\ls{t}$ in einfachen Signaturen in Linear-Zeit
    bestimmt werden (siehe Korollar \ref{kor:signatur-einfach}).
  \item $SX = \set{S_1, \dots, S_m}$, dann sind die 
    Elemente der Menge
    $\set{\set{x_1 \ue y_{S_i}, \dots, x_{|X|} \ue y_{S_i},
     y_{S_i} \ue t} \;| \; i = 1, \dots m}$
    %eingeschränkt auf die Variablen in $X$, 
    jeweils wohlsortierte Komponenten einer gelösten Form.  
  \end{itemize}
\end{enumerate}
Die komplette Menge der gelösten Formen, die eine vollständige Menge
von wohlsortierten Lösungen repräsentiert,\footnote{Da durch den
  Algorithmus neue Variablen eingeführt werden, ist die aus den
  Repräsentationen zu gewinnende vollständigen Menge der Lösungen
  einzuschränken, auf die in $P$ vorkommenden Variablen, $CU_{\Sigma}(P)|_{\Var(P)}$.} 
erhält man durch die Vereinigung der jeweiligen Komponenten. $\qed$ 
\end{beweis}

Verdeutlichen wir uns die Arbeitsweise des Algorithmus anhand des
Unifikationsproblems aus Beispiel \ref{bsp:finitary-unifing}: 
Zur Signatur $\Sigma = \set{A,B \sqsupset C,D}$ ist das
Unifikationsproblem $x_A \ue y_B$ bereits in gelöster Form, wenn die
Sorten nicht berücksichtigt werden. 
Die Gleichung besteht nur aus Variablen und $glb(A,B) = \set{C,D}$. 
Als Menge von wohlsortierten gelösten Formen (die Repräsentationen
der Lösungen) erhält man somit 
$\set{\set{x_A \ue z_C, y_B \ue z_C}, \set{x_A \ue z_D, y_B \ue z_D}}$.

Der Nachteil des Algorithmus von \citeauthor{martelli_efficient_1982}
besteht darin, dass nur die Repräsentation eines allgemeinsten
Unifikators in quasi-linearer Zeit berechnet wird. Wird die
zugehörige Substitution benötigt, muss instantiiert werden, wobei
wieder Terme kopiert werden, was zu exponentiellem Zeit und
Platzbedarf führen kann. In Beispiel \ref{bsp:unify-exp-zeit-platz} 
repräsentiert das Unifikationsproblem bereits eine Lösung. Wird
die Substitution benötigt, muss voll eingesetzt werden, was in
exponentiellem Zeit- und Platzbedarf resultiert. 

Unifikatoren k\"onnen durch gerichtete azyklische
Graphen (so genannte DAGs) in polynomieller Zeit dargestellt werden 
\cite{corbin_rehabilitation_1983}.

\chapter{Unifikation von \letr-Umgebungen}
\label{cha:ac-unifikation}
%Variablenbenennungen sind nicht konsisten, 
%und ob man congruence closed und sort preserving 
%f\"ur \emph{Unify-Cl} tats\"achlich ben\"otigt (wohl eher nicht)
%evtl. \"uberall Gleichungstheorie durch Gleichheitstheorie ersetzen}

%Die Syntaxdefinition von $\Lambda^{let}$ legt fest, dass Bindungen in
%\letr-Umgebungen kommutativ sind. D.h zwei \letr-Ausdrücke, die
%gleich sind, bis auf die Reihenfolge der Bindungen, werden als
%syntaktisch äquivalent angesehen. beispielsweise:
%\[\letrecm{x_1=s_1,x_2=s_2,x_3=s_3}{t} \equiv\footnote{$\equiv$ bezeichnet hier syntaktische Gleichheit} \letrecm{x_3=s_3,x_1=s_1,x_2=s_2}{t}.\]
%Diese Bedingung muss auch für \letr-Umgebungen in $T(\Sigma^{let},X)$
%gelten. In diesem Kalkül werden \letr-Umgebungen dargestellt durch
%das zweistellige Funktionssymbol \emph{umg}, das vergleichbar ist mit
%einem Mulitmengenkonstruktor. Damit die Kommutativität von Bindungen
%auch dort erhalten beleibt, muss das \emph{umg}-Funktionssymbol 
%\emph{kommutativ} und \emph{assoziativ} sein, d.h. für beliebige
%Umgebungsvariablen $c,d,e$ des Sorts $U$ soll gelten: 
%\[\begin{array}{cl}
%umg(d_U,e_U) = umg(e_U,d_U) & \mathsf{Kommutativität} \\
%umg(c_U,umg(d_U,e_U)) = umg(umg(c_U,d_U),e_U) & \mathsf{Assoziativität} \\
%\end{array}\]
%Unter diesen Bedingungen gilt die Kommutativität der Bindungen auch
%in $T(\Sigma^{let},X)$, da die Kommutativität und Assoziativität des
%\emph{umg}-Funktionssymbols verwendet werden kann, um Terme
%äquivalent umzuformen, wie an folgendem Beispiel zu sehen:
%\[\xymatrix@C=0.15cm@R=.85cm{
%\set{x_1=s_1,x_2=s_2,x_3=s_3} \ar@{->}[d]^{\transl{\;}-Übersetzung} & \equiv & \set{x_3=s_3,x_1=s_1,x_2=s_2} \ar@{->}[d]^{\transl{\;}-Übersetzung} \\
%umg(b(x_1,s_1),umg(b(x_2,s_2),b(x_3,s_3))) \ar@{->}[d]^{Assoziativität} & & umg(b(x_3,s_3),umg(b(x_1,s_1),b(x_2,s_2))) \ar@{->}[d]^{Kommutativität}\\
%umg(umg(b(x_1,s_1),(b(x_2,s_2)),b(x_3,s_3)) & \equiv & umg(umg(b(x_1,s_1),b(x_2,s_2)),b(x_3,s_3))\\
%}\]
%Man schreibt auch 
%\[umg(b(x_1,s_1),umg(b(x_2,s_2),b(x_3,s_3))) =_{AC} umg(b(x_3,s_3),umg(b(x_1,s_1),b(x_2,s_2)))\]
%um zu verdeutlichen, dass die beiden Terme gleich sind unter
%Berücksichtigung der Assoziativität und Kommutativität des
%\emph{umg}-Funktionssymbols. 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Eine \letr-Umgebung des $\Lambda^{let}$ Kalküls
besteht im Allgemeinen aus einer 
%beliebigen endlichen Menge von 
Umgebungsvariablen
(der Sorte $U$) und einer beliebigen endlichen Menge von Bindungen
$\set{E, x_1=s_1, \dots x_m = s_m}$. Dabei ist in der
Syntaxdefinition von $\Lambda^{let}$ festgelegt, dass die Elemente der
\letr-Umgebung \emph{kommutativ} sind. D.h zwei \letr-Ausdrücke, die 
bis auf die Reihenfolge der Bindungen
gleich sind, werden als
syntaktisch äquivalent angesehen, wie beispielsweise
\[\letrecm{x_1=s_1,x_2=s_2,x_3=s_3}{t} \equiv\footnote{$\equiv$
  bezeichnet hier die syntaktische Gleichheit von $\Lambda^{let}$-Ausdr\"ucken.}
  \letrecm{x_3=s_3,x_1=s_1,x_2=s_2}{t}.\] 
Diese Bedingung muss auch für \letr-Umgebungen in $T(\Sigma^{let},X)$
gelten. Beliebige Vertauschbarkeit von Elementen kann
in $T(\Sigma^{let},X)$ modelliert werden durch ein
Funktionssymbol, das sich wie ein Multimengenkonstruktor verhält, 
da in einer Menge die Reihenfolge der Elemente ebenfalls keine Rolle
spielt. 
%Eine Multimenge wird hier aus dem Grund gewählt, da 
%\letr-Umgebungen nicht idempotent sind. Es gilt zwar die syntaktische
%Nebenbedingung, dass alle Variablen auf linken Seiten von Bindungen
%verschieden sind. Allerdings kann es durch die Unifikation (von Ketten)
%dazu kommen, dass eine Varialben mehrmals auf der linken Seite einer
%Bindung auftaucht. Die lösende Substituion wird aber nicht weiter
%betrachtet, da sie die syntaktischen Nebenbeding der
%Variablendistinktheit verletzt.  
Dabei sind zwei verschiedene Vorgehensweisen möglich,
\letr-Umgebungen aus $\Lambda^{let}$ in $\Sigma^{let}$-Terme zu
übersetzen: 
\begin{enumerate}
\item \letr-Umgebungen werden dargestellt durch ein einstelliges
  Funktionssymbol $\set{\cdot}: B \rightarrow U$, das Umgebungen aus
  einer einzelnen Bindung konstruiert. 
  Beliebige Umgebungen, mit mehr als einem
  Element, werden durch die Vereinigung von Umgebungen erzeugt mit dem
  Funktionssymbol $\cup : U \rightarrow U \rightarrow U$. Ein Beispiel 
  für eine Übersetzung ist
  \[\transl{\set{x_1=s_1,x_2=s_2,x_3=s_3}} = \set{b(x_1,s_1)} \cup (\set{b(x_2,s_2)} \cup \set{b(x_3,s_3)}),\]
  wobei $\set{e}$ anstelle von $\set{\cdot}(e)$,
  $d \cup e$ anstatt $\cup(d,e)$ geschrieben wird und 
  $bind$ als $b$ abgek\"urzt wird. 
  Um die Kommutativität der Elemente zu gewährleisten, muss für das
  Funktionssymbol $\cup$ gelten: 
  \[\begin{array}{cl}
  d_U \cup e_U \approx e_U \cup d_U & \mathsf{Kommutativitaet}, \\
  c_U \cup (d_U \cup e_U) \approx (c_U \cup d_U) \cup e_U & \mathsf{Assoziativitaet}. \\
  \end{array}\]
\item Oder Umgebungen werden dargestellt durch ein zweistelliges Funktionssymbol
  $\setf{\cdot | \cdot}: B \rightarrow U \rightarrow U$, das,
  vergleichbar mit einem Listenkonstruktor, eine Umgebung 
  aus einem Term der Sorte $B$ (einer Bindung) und einer Umgebung konstruiert. 
  Wir schreiben $\set{d|e}$ anstatt $\set{\cdot|\cdot}(d,e)$. 
  Als zusätzliches Konstantensymbol wird die leere Umgebung $\emptyset : U$ benötigt.  
  Eine beispielhafte Übersetzung ist 
  \[\transl{\set{x_1=s_1,x_2=s_2,x_3=s_3}} = \setf{(b(x_1,s_1)|
  \setf{b(x_2,s_2)| \setf{b(x_3,s_3)| \emptyset}}}.\]
  Das Axiom, das die Irrelevanz der Reihenfolge der Elemente zusichert, ist: 
  \[\begin{array}{cl}
  \setf{c_B|\setf{d_B|e_U}} \approx \setf{d_B|\setf{c_B|e_U}} & \mathsf{Links\text{-}Kommutativitaet}. \\
  \end{array}\]
\end{enumerate}
Die beiden Darstellungsmöglichkeiten modellieren die
Kommutativitätsbedingung von \letr-Umgebungen in $T(\Sigma^{let},X)$,
weil die Axiome (das sind die $\approx$ Gleichungen) verwendet werden 
können, um Terme äquivalent umzuformen. 
Betrachte etwa die Übersetzung, die Umgebungen durch das assoziative 
und kommutative Funktionssymbol $\cup$ darstellt: 
\[\xymatrix@C=0.15cm@R=.85cm{
\set{x_1=s_1,x_2=s_2,x_3=s_3} \ar@{->}[d]^{Uebersetzung} & \equiv & \set{x_3=s_3,x_1=s_1,x_2=s_2} \ar@{->}[d]^{Uebersetzung} \\
\set{b(x_1,s_1)}\cup (\set{b(x_2,s_2)} \cup \set{b(x_3,s_3)})
  \ar@{->}[d]^{Assoziativitaet} & & \set{b(x_3,s_3)} \cup (\set{b(x_1,s_1)} \cup \set{b(x_2,s_2)}) \ar@{->}[d]^{Kommutativitaet}\\
(\set{b(x_1,s_1)} \cup \set{b(x_2,s_2)}) \cup \set{b(x_3,s_3)} & = & (\set{b(x_1,s_1)} \cup \set{b(x_2,s_2)}) \cup \set{b(x_3,s_3)}\\
}\]
Unter Berücksichtigung der Assoziativität und der Kommutativität
des Funktionssymbols $\cup$ sind die beiden Umgebungen gleich. Man
schreibt dafür 
\[\set{b(x_1,s_1)} \cup (\set{b(x_2,s_2)} \cup \set{b(x_3,s_3)})
=_{AC} \set{b(x_3,s_3)} \cup (\set{b(x_1,s_1)} \cup \set{b(x_2,s_2)}).\]

Betrachtet man die Darstellung mit dem links-kommutativen Funktionssymbol
$\setf{\cdot|\cdot}$, dann kann dessen Eigenschaft zum Umformen von
Termen verwendet werden: 
\[\xymatrix@C=0.15cm@R=.85cm{
\set{x_1=s_1,x_2=s_2,x_3=s_3} \ar@{->}[d]^{Uebersetzung} & \equiv & \set{x_3=s_3,x_1=s_1,x_2=s_2} \ar@{->}[d]^{Uebersetzung} \\
\setf{b(x_1,s_1)|\setf{b(x_2,s_2)|\setf{b(x_3,s_3)|\emptyset}}}
  \ar@{->}[d]^{Links-Kommutativitaet} & & \setf{b(x_3,s_3)|\setf{b(x_1,s_1)|\setf{b(x_2,s_2)|\emptyset}}} \ar@{->}[d]^{Links-Kommutativitaet}\\
\setf{b(x_1,s_1)|\setf{b(x_3,s_3)|\setf{b(x_2,s_2)|\emptyset}}} & = & \setf{b(x_1,s_1)|\setf{b(x_3,s_3)|\setf{b(x_2,s_2)|\emptyset}}} \\
}\]

Unabhängig davon, welche der beiden Übersetzungen zur Darstellung
von \letr-{Um\-ge\-bun\-gen} verwendet wird, müssen
bei der Unifikation die durch Gleichungen $(\approx)$ definierten
semantischen Eigenschaften von Funktionssymbolen berücksichtigt
werden. Beispielsweise hat das Unifikationsproblem 
\[\setf{c_B|\setf{b(x_V,s_T)| \emptyset}} \ue \setf{b(y_V,t_T)|\setf{d_B| \emptyset}},\] 
für die in Kapitel \ref{cha:unif-fur-terme-mit-sorten}
beschriebene Methode der
syntaktischen Unifikation, einen mgu
$\sigma = \set{c \mapsto b(y,t), d \mapsto b(x,s)}$. Wird berücksichtigt, dass 
das Funktionssymbol $\setf{\cdot, \cdot}$ links-kommutativ ist, dann
hat das Problem einen weiteren Unifikator
%eine minimale, vollständige Menge von Unifikatoren 
$\tau = \set{c \mapsto d, x \mapsto y, s \mapsto t}$,
für den $\sigma \not\lesssim_{\Sigma} \tau$ und
$\tau \not\lesssim_{\Sigma} \sigma$ gilt.

Die Unifikationsmethode, die durch Gleichungen definierte Eigenschaften von
Funktionssymbolen berücksichtigt, wird als 
\emph{Gleichungsunifikation} (kurz \emph{E-Unifikation} 
aus dem Englischen f\"ur \emph{Equational Unification}) bezeichnet.
Gegeben zwei Terme $s,t$ und eine Menge  $E$ von \emph{Gleichungen} 
(auch \emph{Identitäten} genannt), 
%definiert über einer Signatur $\Sigma$ mit Sorts, 
versucht die $E$-Unifikation eine 
Substitution $\sigma$ zu finden, so dass $\sigma s$ und $\sigma t$
gleich sind \emph{modulo der durch $E$ definierten Identitäten}:
$\sigma s =_{E} \sigma t$. 

Dieses Kapitel beschäftigt sich mit dem oben skizzierten Problem, wie
\letr-{Um\-ge\-bung\-en} mit vertauschbaren Elementen unifiziert werden
können. Es ist folgendermaßen strukturiert:

In Abschnitt \ref{sec:ac-basic-def} werden \emph{Gleichungstheorien}
(informell) eingeführt, die den theoretischen Rahmen bereitstellen, um Unifikation
von Funktionssymbolen mit vertauschbaren Argumenten zu behandeln. 
Die Definitionen verschiedener Begriffe wie Unifikationsproblem,
{In\-stan\-ti\-ier\-ungs-Quasiordnung} und Unifikationstyp
werden auf die Situation angepasst, dass bei der Unifikation eine 
Gleichungstheorie zu berücksichtigen ist. 
Außerdem werden die beiden Gleichungstheorien \eletcl und \eletac
vorgestellt, die 
Vertauschbarkeit von Bindungen in \letr-Umgebungen darstellen k\"onnen. 

Im darauf folgenden Abschnitt \ref{sec:synt-unif-fur} wird kurz eine
vollständige Unifikationsprozedur vorgestellt, die zur Unifikation in
beliebigen Gleichungstheorien verwendet werden kann. Die Nachteile
dieser Prozedur werden diskutiert und es wird erläutert, warum sie
für die Unifikation von \letr-Umgebungen nicht geeignet ist. 

Abschnitt \ref{sec:unif-congr-clos} charakterisiert das
Verhältnis von Sorten zu den Identitäten, die eine Gleichungstheorie
definieren. Gelten bestimmte Bedingungen für dieses Verhältnis, so
können Unifikatoren auf besonders einfache Weise berechnet werden. 
In Unterabschnitt \ref{sec:eigensch-von-e_ac-und-e_p} wird dargelegt, dass die beiden   
Gleichungstheorien, %\eletcl und \eletac 
die Vertauschbarkeit von Elementen in
\letr-Umgebungen axiomatisieren, diese Bedingungen erfüllen. 
Weitere Eigenschaften der beiden Theorien werden kurz diskutiert. 
Außerdem wird begründet, weshalb der Theorie \eletcln, zur
Darstellung und Unifikation von \letr-Umgebungen in dieser 
Arbeit der Vorzug vor \eletac gegeben wird. 

Abschnitt \ref{sec:unifikationsalgo} beschäftigt sich mit der
Unifikation von Termen in der Theorie $\mathpzc{E}^{let}_{Cl}$.
%über einer endlichen und regulären Signatur
%$(\Sigma^{let})$ mit einem Permutativen Umgebungs-Funktionssymbol
%$\setf{\cdot|\cdot}$. 
Es wird ein Unifikationsalgorithmus vorgestellt,
der terminiert (Abschnitt \ref{sec:terminierung}) und vollständig ist
(Abschnitt \ref{sec:vollstaendigkeit}). Der abschließende Teil
\ref{sec:unifikationstyp-berechnung-vollst-komplexitaet} geht kurz auf den
Unifikationstyp der Theorie \eletcl und die Komplexität der Unifikation
in dieser Theorie ein. Außerdem wird erklärt,
wie die komplette vollständige Menge von Unifikatoren
berechnet werden kann, die zur Berechnung aller \"Uberlappungen 
ben\"otigt wird.  

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Grundlegende Definitionen}
\label{sec:ac-basic-def}

\begin{definition}[$\Sigma$-Identitäten]
\label{def:identitaeten}
Sei $\Sigma$ eine Signatur (mit Sorten) und $X$ eine abzählbar
unendliche Menge von Variablen, die disjunkt ist zur Menge der
Funktionssymbole. Eine \emph{$\Sigma$-Identität} (oder einfach
Identität) ist ein Paar $(s,t) \in T(\Sigma,X) \times T(\Sigma,X)$. 
Identitäten werden geschrieben als $s \approx t$, wobei $s$ linke
Seite (\emph{lhs}) und $r$ rechte Seite (\emph{rhs}) heißt.
\end{definition}
Identitäten können verwendet werden, um Terme zu anderen
äquivalenten Termen zu transformieren, indem die Instanz einer linken
Seite durch die entsprechende Instanz der rechten Seite ersetzt
werden (und umgekehrt). Eine Identität wird auch \emph{Axiom} genannt.
Auf das Verh\"altnis von Identit\"aten zu Sorten wird im Abschnitt
\ref{sec:unif-congr-clos} n\"aher eingegangen. 

Beispiele für Identitäten, die Eigenschaften von
Funktionssymbolen axiomatisieren 
%und in Anwendung und Forschung eine Rolle spielen 
sind:
\begin{longtable}{llll}
$A_f$ & = & $\set{f(x,f(y,z)) \approx f(f(x,y),z)}$ & Assoziativität,\\
$C_f$ & = & $\set{f(x,y) \approx f(y,x)}$ & Kommutativität, \\
$AC_f$ & = & $A_f \cup C_f$ & Assoziativität und Kommutativität, \\ 
$U_f$ & = & $\set{f(x,e) \approx x, f(e,x) \approx x}$ & Einheitselement, \\
$I_f$ & = & $\set{f(x,x) \approx x}$ & Idempotenz, \\ 
$Cl_f$ & = & $\set{f(x,f(y,z)) \approx f(y,f(x,z))}$ & Links-Kommutativit\"at. \\
\end{longtable}
Ein assoziatives und kommutatives Funktionssymbol wird als
$AC$-Funktionssymbol, ein links-kommutatives Symbol als
$Cl$-Funktionssymbol, bezeichnet.
%Für weitere Theorien siehe \citeA{baader_unification_2001}.

Eine \emph{Gleichungstheorie} wird definiert durch eine Menge von
Identitäten $E$. Sie ist die kleinste Kongruenzrelation auf der
Termalgebra $\mathcal{T}(\Sigma,X)$,
die $E$ enthält und abgeschlossen ist unter
Substitution und wird durch $=_{\Sigma,E}$ bezeichnet.\footnote{Für
  eine ausf\"uhrlichere Definition von Gleichungstheorien siehe  
\citeA{baader_term_1998}, bzw. für den Fall mit Sorten
\citeA{schmidt-schauss_computational_1989}.} 
Gilt $s =_{\Sigma,E} t$, dann sagt man $s$ und $t$ sind \emph{gleich modulo E}.
%unter $\Sigma$.
Der Begriff "`Gleichungstheorie"' wird hier (leicht missbräuchlich)
folgendermaßen verwendet: Wir sprechen von $\mathpzc{E}=(\Sigma,E)$ als der
Gleichungstheorie $\mathpzc{E}$, die durch die Identitäten in $E$
über der Signatur $\Sigma$ definiert ist.
Für eine gegebene
Gleichungstheorie schreiben wir verkürzt $s =_{\mathpzc{E}} t$, für
die Kongruenzrelation $s =_{\Sigma,E} t$.
Gleichungstheorien dienen dazu, semantische Eigenschaften von
Funktionssymbolen darzustellen und bei der Unifikation zu
berücksichtigen. Außerdem bilden sie die Basis f\"ur die Theorie 
der Termersetzung \cite{baader_term_1998,bezem_term_2003}.

\begin{definition}
\label{def:eletac-eletcl}
Die beiden Gleichungstheorien, die Vertauschbarkeit von \letr-Umgebungen
in $T(\Sigma^{let},X)$ darstellen, sind folgenderma"sen definiert:
\begin{description}
\item [\eletac] besteht aus der Signatur $\Sigma^{let}_{\cup}$, die
  folgenderma"sen definiert ist:
  \[\Sigma^{let} \cup \set{\;\set{\cdot}: B \rightarrow U, \quad \cup: U \rightarrow U \rightarrow U\;}\]
  zusammen mit folgender Menge von Identit\"aten:
  \[\begin{array}{rrrll}
   & \set{ & c_U \cup (d_U \cup e_U) \approx (c_U \cup d_U) \cup e_U & (A)& \\
   & &  d_U \cup e_U \approx e_U \cup d_U  & (C)& }\\
  \end{array}\]
\item [\eletcl] besteht aus der Signatur $\Sigma^{let}_{\setf{\cdot|\cdot}}$, die
  folgenderma"sen definiert ist:
   \[\Sigma^{let} \cup \set{\;\setf{\cdot|\cdot}: B \rightarrow U \rightarrow U, \quad \emptyset : U\;}\]
   und der Identit\"at
   \[\begin{array}{rrrll}
   & \set{ & \setf{c_B|\setf{d_B|e_U}} \approx \setf{d_B|\setf{c_B|e_U}} & (Cl) &}\\
   \end{array}\]
\end{description}
\end{definition}

\begin{bemerkung}
\label{bem:eletcl-ist-einschraenukug-von-eletac}
Die \eletac Theorie und die \eletcl Theorie axiomatisieren beide die
Vertauschbarkeit von Elementen in \letr-Umgebungen.
Trotzdem gibt es Unterschiede zwischen den beiden Theorien, 
insbesondere bez\"uglich der Ausdruckskraft der zugrunde liegenden Signaturen.
Ein Unterschied besteht darin, dass Umgebungen, die
mehr als eine Variable der Sorte $U$ enthalten, durch die Signatur  
$\Sigma^{let}_{\cup}$ aber nicht durch $\Sigma^{let}_{\setf{\cdot|\cdot}}$
dargestellt werden k\"onnen. Beispielsweise kann $\set{d_U} \cup \set{e_U}$
durch $\Sigma^{let}_{\cup}$ aber nicht durch $\Sigma^{let}_{\setf{\cdot|\cdot}}$
repräsentiert werden. Der Grund hierfür
ist, dass das
Funktionssymbol $\setf{\cdot|\cdot}:B \rightarrow U \rightarrow U$
eingeschränkt ist, weil es als erstes Argument einen Term der Sorte
$B$ erwartet. 
In $\Sigma^{let}_{\setf{\cdot|\cdot}}$  können deshalb nur Umgebungen 
mit maximal einer Variablen der Sorte $U$ 
%pro Umgebung 
dargestellt werden. Dies ist
allerdings ausreichend zur Berechnung aller \"Uberlappungen f\"ur Gabeldiagramme, 
da für alle linken Seiten der Reduktionsregeln des 
$\Lambda^{let}$-Kalküls gilt, 
%(die überlappt werden sollen)
dass sie maximal über eine Umgebungsvariable verfügen.
In der Signatur $\Sigma^{let}_{\cup}$ unterliegt das Funktionssymbol 
$\cup : U \rightarrow U \rightarrow U$ diesen Beschränkungen nicht. 
D.h. die \eletcl Theorie stellt eine "`Einschränkung"' der
allgemeineren Theorie \eletac dar. 
\end{bemerkung}
Eine Entscheidung, welche der beiden Theorien in dieser Arbeit zur
Darstellung von \letr-Umgebungen verwendet wird, wird erst sp\"ater 
getroffen (in Abschnitt \ref{sec:eigensch-von-e_ac-und-e_p}). 
Zuvor werden Themen behandelt, die für beliebige Gleichungstheorien
gelten.      

Wir passen die im Kapitel \"uber syntaktische Unifikation von Termen
mit Sorten 
definierten Begriffe auf die Situation an, dass eine
Gleichungstheorie $\mathpzc{E}$ gegeben ist. 
%Die definierenden Identitäten sollen in den Unifikationsprozess
%einbezogen werden. 
\begin{definition}[$\mathpzc{E}$-Unifikationsproblem]
\label{def:e-unif}
Sei $\mathpzc{E}=(\Sigma,E)$ eine Gleichungstheorie.
%und $\Sigma$ eine Signatur (mit Sorts). 
Ein \emph{$\mathpzc{E}$-Unifikationsproblem} 
%über $\Sigma$ 
ist eine endliche Menge von Gleichungen 
\[P = \set{s_1 =_{\mathpzc{E}}^? t_1, \dots, s_n =_{\mathpzc{E}}^? t_n}\]
zwischen $\Sigma$-Termen. Ein \emph{$\mathpzc{E}$-Unifikator} (bzw. eine
\emph{$\mathpzc{E}$-Lösung}) ist eine Substitution $\sigma \in Sub_{\Sigma}$, so
dass $\sigma s_1 \gee \sigma t_1, \dots, \sigma s_n \gee \sigma t_n$.
Die Menge aller $\mathpzc{E}$-Unifikatoren von $P$ wird mit $U_{\mathpzc{E}}(P)$
bezeichnet; $P$ ist \emph{lösbar}, gdw.\ $U_{\mathpzc{E}}(P) \neq \emptyset$.
\end{definition}
Ist der Bezug zu $\mathpzc{E}$ klar, wird verk\"urzt $\ue$ anstatt 
$\ue_{\mathpzc{E}}$ geschrieben. 

Syntaktische $\Sigma$-Unifikation (wie in Kapitel \ref{cha:unif-fur-terme-mit-sorten}
behandelt) ist ein Spezialfall der  
$\mathpzc{E}$-Unifikation mit $E= \emptyset$. Jeder syntaktische $\mathpzc{E}$-Unifikator
ist auch ein $\mathpzc{E}$-Unifikator, aber für $E \neq \emptyset$ kann die
Menge $U_{\mathpzc{E}}(P)$ zusätzliche Elemente besitzen. 

$\mathpzc{E}$-Gleichheit wird auf wohlsortierte Substitutionen 
$\sigma, \tau \in Sub_{\Sigma}$ ausgeweitet:
\[\sigma \gee \tau \;, gdw.\ \; \sigma x \gee \tau x \;\; \text{für alle Variablen} x \in \; X.\]
Ist man nur am Verhalten auf einer speziellen Menge von Variablen $W \subseteq X$
interessiert, schreibt man wie gewohnt:
\[\sigma \gee \tau [W] \;, gdw.\ \; \sigma x \gee \tau x \;\; \forall x \in W.\]
Die Instantiierungs-Quasiordnung auf der Menge der wohlsortierten
Substitutionen wird ebenfalls angepasst.
\begin{definition}%[Instantiierungs Quasiordnung E]
\label{def:inst-quas-e}
Sei 
%$\Sigma$ eine Signatur, 
$\mathpzc{E}$ eine Gleichungstheorie, $W \subseteq X$ 
eine Menge von Variablen und $\sigma, \tau \in Sub_{\Sigma}$
wohlsortierte Substitutionen. 

Die Substitution $\sigma$ ist \emph{allgemeiner modulo E auf W} als die
Substitution $\tau$, gdw.\ es eine Substitution $\delta$ gibt, so dass 
$\tau \gee \delta \sigma [W]$. In diesem Fall schreibt man 
$\sigma \lesssim_{\mathpzc{E}} \tau [W]$ und bezeichnet $\tau$ als
\emph{$\mathpzc{E}$-Instanz} von $\sigma$ auf $W$. 
\end{definition}
Werden $\mathpzc{E}$-Unifikatoren eines Unifikationsproblems $P$ verglichen,
dann ist die Menge der Variablen $W$, die Menge der in $P$ vorkommenden
Variablen $\Var(P)$. 
Die Relation $\iqse$ ist eine Quasiordnung auf der Menge der 
wohlsortierten Substitutionen, die zugehörige
Äquivalenzrelation ist $\eqse \; := \; \iqse \cap \gtrsim_{\mathpzc{E}}$.

Die Situation, dass im Allgemeinen kein einzelner mgu, sondern eine
vollständige Menge von $\mathpzc{E}$-Unifikatoren betrachtet werden muss,
bleibt bestehen. 
\begin{definition}%[vollst min mgu menge]
\label{def:vollst-min-mgu-menge-E}
Eine \emph{vollständige Menge von E-Unifikatoren} für
ein $\mathpzc{E}$-{Uni\-fi\-ka\-ti\-ons\-pro\-blem} $P$ ist 
eine Menge von (wohlsortierten) Substitutionen $CU_{\mathpzc{E}}(P)$, so dass 
\begin{itemize}
\item $CU_{\mathpzc{E}}(P) \subseteq U_{\mathpzc{E}}(P)$ und 
\item für alle $\tau \in U_{\mathpzc{E}}(P)$ gibt es $\sigma \in CU_{\mathpzc{E}}(P)$,
  so dass $\sigma \iqse \tau [\Var(P)]$. 
\end{itemize}

Eine \emph{minimale vollständige Menge von $\mathpzc{E}$-Unifikatoren} für ein
$\mathpzc{E}$-Unifikationsproblem $P$ ist eine vollständige Menge von Unifikatoren
$MU_{\mathpzc{E}}(P)$, so dass die Substitutionen in $MU_{\mathpzc{E}}(P)$
bezüglich $\iqse [\Var(P)]$ nicht vergleichbar sind: 
\begin{itemize}
\item Für alle $\sigma, \tau \in MU_{\mathpzc{E}}(P)$ gilt: 
  $\sigma \iqse \tau [\Var(P)]$ impliziert $\sigma =_{\mathpzc{E}} \tau [\Var(P)]$
\end{itemize}
Eine Substitution $\sigma$ ist ein \emph{allgemeinster $\mathpzc{E}$-Unifikator} von $P$
(kurz \emph{$\mathpzc{E}$-mgu}),
gdw. $\set{\sigma}$ eine minimale vollständige Menge von
Lösungen für $P$ ist.
%Eine vollständige, minimale Menge von Unifikatoren wird kurz als
%Menge von \emph{mgus} bezeichnet.
\end{definition}
Ist ein $\mathpzc{E}$-Unifikationsproblem nicht unifizierbar, dann ist die leere
Menge eine minimale, vollständige Menge von $\mathpzc{E}$-Unifikatoren von
$P$. Die minimale vollständige Menge von $\mathpzc{E}$-Unifikatoren eines
$\mathpzc{E}$-Unifikationsproblems ist eindeutig bestimmt, bis auf die
Äquivalenzrelation $\eqse [\Var(P)]$.
%(siehe Abschnitt XXXX \"uber syntaktische Unifikation). 
Insbesondere haben alle minimalen, vollständigen Mengen von
Unifikatoren die gleiche Kardinalität. Deswegen
kann der Unifikationstyp einer Gleichungstheorie 
definiert werden. 

\begin{definition}%[Unifikationstyp E]
\label{def:unifikationstyp-e}
Eine Gleichungstheorie $\mathpzc{E} = (\Sigma,E)$ besitzt den
\emph{Unifikationstyp} 
\begin{description}
\item [eindeutig,] gdw.\ $MU_{\mathpzc{E}}(P)$ existiert und 
  $|MU_{\mathpzc{E}}(P)| \leq 1$ für alle
  $\mathpzc{E}$-Unifikationsprobleme $P$ gilt. 
\item [endlich,] gdw.\ $MU_{\mathpzc{E}}(P)$ existiert und 
  $|MU_{\mathpzc{E}}(P)| \leq \infty$ für alle
  $\mathpzc{E}$-Unifikationsprobleme $P$ gilt. 
\item [unendlich,] gdw.\ $MU_{\mathpzc{E}}(P)$ existiert für alle
  $\mathpzc{E}$-Unifikationsprobleme $P$ und es ein
  $\mathpzc{E}$-Unifikationsproblem $P$ mit $|MU_{\mathpzc{E}}(P)|=\infty$ gibt. 
\item [null,] gdw.\ es ein $\mathpzc{E}$-Unifikationsproblem $P$ gibt, für
  das $MU_{\mathpzc{E}}(P)$ nicht existiert. 
\end{description}
%  eine vollständige, minmale Menge von
%  Unifikatoren für alle Unifikationsproblem existiert und deren
%  Kardinalität immer $\leq 1$ ist.
%Sei 
%$\mathpzc{E} = (\Sigma,E)$ eine Gleichungstheorie und
%$P$ ein $\mathpzc{E}$-{Uni\-fi\-ka\-ti\-ons\-pro\-blem}. Dann hat $P$ den Typ \emph{eindeutig}
%(\emph{endlich}, \emph{unendlich}, gdw.\ $P$ eine minimale,
%vollständige Menge von $\mathpzc{E}$-Unifikatoren der Kardinalität 1 (endlicher
%Kardinalität, unendlicher Kardinalität) hat. Besitzt $P$ keine minimale,
%vollständige Menge von $\mathpzc{E}$-Unifikatoren, dann hat es den Typ \emph{null}.
%Man schreibt als Abkürzungen $1$ für eindeutig, $\omega$ für
%endlich, $\infty$ für unendlich und $0$ für null. Die Ordnung der
%Typen ist $1 < \omega < \infty < 0$.
%
%Der \emph{Unifikationstyp} einer Gleichungstheorie $\mathpzc{E}$ ist
%der maximale Typ eines $\mathpzc{E}$-{Uni\-fi\-ka\-ti\-ons\-pro\-blems}. 
\end{definition}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Syntaktische Unifikation in beliebigen Gleichungstheorien}
\label{sec:synt-unif-fur}

Die $\mathpzc{E}$-Unifikation, bezüglich einer beliebigen Gleichungstheorie $\mathpzc{E}$,
benötigt eine Methode, um die Identitäten, die $\mathpzc{E}$ definieren, in die
Berechnung einer vollständigen Menge von $\mathpzc{E}$-Unifikatoren 
%für ein $\mathpzc{E}$-Unifikationsproblem 
einzubeziehen. Eine allgemeine Methode, die
sich auf keine spezifische Gleichungstheorie $\mathpzc{E}$ beschränkt, erhält
man durch die Erweiterung der Unifikationsregeln 
(für Terme über regulären Signaturen: Definition \ref{def.unifikationsregeln})
durch folgende Regel (nach \citeA{schmidt-schauss_computational_1989}):

\begin{definition}%[mutaiton regel]
\label{def:mutation-regel}
Sei $\mathpzc{E} = (\Sigma,E)$ eine Gleichungstheorie mit einer
regul\"aren Signatur $\Sigma$. 
Die Unifikationsregeln für endliche und reguläre Signaturen werden
um folgende Regel erweitert, um beliebige
$\mathpzc{E}$-Unifikationsprobleme zu lösen:

\fbox{
\begin{minipage}{0.98\textwidth}
\[\begin{array}{l}
\multicolumn{1}{l}{\mathbf{Mutation}} \\
\set{s \ue t} \uplus P \Rightarrow \set{s \ue l, t \ue r} \cup P \\ 
\end{array}\]
Wobei $l \approx r$ eine Version mit neuen Variablen von $l \approx r
\in E \cup E^-$ ist und
\begin{itemize}
\item $t$ keine Variable ist und 
\item wenn $l$ keine Variable ist, dann sind die Wurzelsymbole von $s$
  und $l$ gleich und als nächste Transformation wird
  \emph{Decomposition} auf $s \ue l$ oder $t \ue r$ angewendet.
\end{itemize}
\end{minipage}}
\end{definition}

\citeA{schmidt-schauss_computational_1989} zeigt, dass die 
Unifikationsregeln für reguläre Signaturen 
zusammen mit der Regel \emph{Mutation} eine vollständige
Unifikationsprozedur für $\mathpzc{E}$-{Uni\-fi\-ka\-ti\-ons\-pro\-bleme} 
%über einer beliebigen 
zu einer beliebigen 
Gleichungstheorie $\mathpzc{E}$ darstellen (zur Vollständigkeit im unsortierten
Fall siehe \citeA{gallier_complete_1989}). An dieser Stelle wird nicht
auf den Vollständigkeitsbeweis eingegangen,
sondern wir wollen an einem Beispiel betrachten, wie die
Unifikationsprozedur mit der \emph{Mutation}-Regel einen $\mathpzc{E}$-Unifikator
für ein $\mathpzc{E}$-Unifikationsproblem $P$ berechnet. 

\begin{beispiel}
\label{bsp:bsp.mut.vollst}
Sei $P := \set{\setf{c,\setf{b(x,s),\emptyset}} \ue \setf{b(y,t),\setf{d,\emptyset}}}$  
ein $\mathpzc{E}^{let}_{Cl}$-{Uni\-fi\-ka\-ti\-ons\-pro\-blem}
mit den Variablensorten \\
\[\begin{array}{l}
\mathbb{S}(c) = \mathbb{S}(d) = \mathbb{S}(b_i) = B, \\
\mathbb{S}(e_i) = U, \\
\mathbb{S}(x) = \mathbb{S}(y) = V, \\
\mathbb{S}(s) = \mathbb{S}(t) = T. \\
\end{array}\]
Eine mögliche Folge von Transformationen des Problems
ist:\footnote{\emph{Mu-Cl} steht für einen \emph{Mutation}-Schritt mit
  dem \emph{Cl}-Axiom. Die Namen der anderen Unifikationsregeln
  sind ebenfalls abgekürzt. $\times n$ bedeutet $n$-fache Anwendung
  einer Unifikationsregel.}  
\begin{longtable}{rlr}
& $\set{\setf{c|\setf{b(x,s)|\emptyset}} \ue \setf{b(y,t)|\setf{d|\emptyset}}}$ & \\
$\xrightarrow{\emph{Mu-Cl}}$ & $\set{\setf{c|\setf{b(x,s)|\emptyset}} \ue \setf{b_1|\setf{b_2|e_1}},
 \setf{b(y,t)|\setf{d|\emptyset}} \ue \setf{b_2|\setf{b_1|e_1}}}$ & \\
$\xrightarrow{\emph{Dec} \times 2}$ & $\set{c \ue b_1, b(x,s) \ue b_2, \emptyset \ue e_1, 
   \setf{b(y,t)|\setf{d|\emptyset}} \ue \setf{b_2|\setf{b_1|e_1}}}$ & \\
$\xrightarrow{\emph{Orient}\times 2}$ & $\set{c \ue b_1, b_2 \ue b(x,s), e_1 \ue \emptyset, 
   \setf{b(y,t)|\setf{d|\emptyset}} \ue \setf{b_2|\setf{b_1|e_1}}}$ & \\
$\xrightarrow{\emph{Elim} \; b_2}$ & $\set{c \ue b_1, b_2 \ue b(x,s), e_1 \ue \emptyset, 
   \setf{b(y,t)|\setf{d|\emptyset}} \ue \setf{b(x,s)|\setf{b_1|e_1}}}$ & \\
$\xrightarrow{\emph{Dec} \times 2}$ & $\set{c \ue b_1, b_2 \ue b(x,s), e_1 \ue \emptyset, 
   b(y,t) \ue b(x,s), d \ue b_1, \emptyset \ue e_1}$ & \\
$\xrightarrow{\emph{Elim} \; e_1}$ & $\set{c \ue b_1, b_2 \ue b(x,s), e_1 \ue \emptyset, 
   b(y,t) \ue b(x,s), d \ue b_1, \emptyset \ue \emptyset}$ & \\
$\xrightarrow{\emph{Taut}}$ & $\set{c \ue b_1, b_2 \ue b(x,s), e_1 \ue \emptyset, 
   b(y,t) \ue b(x,s), d \ue b_1}$ & \\
$\xrightarrow{\emph{Dec}}$ & $\set{c \ue b_1, b_2 \ue b(x,s), e_1 \ue \emptyset, 
   y \ue x, t \ue s, d \ue b_1}$ & \\ 
\end{longtable}
Das Unifikationsproblem in der letzten Zeile ist in
(wohlsortierter) gelöster Form und es gilt
$\sigma_S|_{Var(P)} \in CU_{\mathpzc{E}^{let}_{Cl}}(P)$. 
%Für den in der Einleitung angegeben Unifikator 
%$\tau = \set{c \mapsto d, x \mapsto y, s \mapsto t} \in CU_{\mathpzc{E}}(P)$ gilt 
%$\sigma \sim_{\mathpzc{E}} \tau$, nach folgender überlegung: 
%$\sigma = \sigma \tau [\Var(P)]$ und für 
%$\delta = \set{e_1 \mapsto d, x \mapsto y, s \mapsto t}$
%$\tau =  \delta \sigma [\Var(P)]$; 
%außerdem ist nach  $\rho := \delta \sigma$ 
%eine $\Sigma$-Permutation, so dass $\tau = \rho \sigma$.
\end{beispiel}

Es ist leicht zu sehen, wie die Folge der Transformationen (ohne
\emph{Mutation}) auszusehen hat, die den anderen in der Einleitung
angegebenen Unifikator zu obigem Beispielproblem findet. Die
Vollständigkeit der Unifikationsprozedur ist also auch neben dem 
Beweis intuitiv plausibel. 
Der Vorteil, dass diese Unifikationsprozedur mit beliebigen
Gleichungstheorien verwendbar ist, wird von dem Nachteil wett gemacht, 
dass sich außer der Vollständigkeit der Prozedur nicht viel über
ihre Eigenschaften sagen lässt. Dass sie beispielsweise für 
\eletcln-{Uni\-fi\-ka\-ti\-ons\-pro\-bleme} nicht immer 
terminiert, verdeutlicht folgendes Beispiel. 
\begin{beispiel}
\label{bsp:nicht-terminierung}
Wir betrachten die Situation wie in Beispiel
\ref{bsp:bsp.mut.vollst}. Eine mögliche nicht terminierende Folge von
Transformationsschritten ist:
\begin{longtable}{rlr}
& $\set{\setf{c|\setf{b(x,s)|\emptyset}} \ue \setf{b(y,t)|\setf{d|\emptyset}}}$ & \\
$\xrightarrow{\emph{Mu-Cl}}$ & $\set{\setf{c|\setf{b(x,s)|\emptyset}} \ue \setf{b_1|\setf{b_2|e_1}},
 \setf{b(y,t)|\setf{d|\emptyset}} \ue \setf{b_2|\setf{b_1|e_1}}}$ & \\
$\xrightarrow{\emph{Dec}}$ & $\set{c \ue b_1, \setf{b(x,s)|\emptyset} \ue \setf{b_2|e_1}, 
   \setf{b(y,t)|\setf{d|\emptyset}} \ue \setf{b_2|\setf{b_1|e_1}}}$ & \\
$\xrightarrow{\emph{Mu-Cl}}$ & $\set{c \ue b_1, \setf{b(x,s)|\emptyset} \ue \setf{b_2|e_1}, 
   \setf{b(y,t)|\setf{d|\emptyset}} \ue \setf{b_3|\setf{b_4|e_2}},$ &  \\
 & \wklammer $\setf{b_2|\setf{b_1|e_1}} \ue \setf{b_4|\setf{b_3|e_2}}}$ & \\
$\xrightarrow{\emph{Dec}}$ & $\set{c \ue b_1, \setf{b(x,s)|\emptyset} \ue \setf{b_2|e_1}, 
   b(y,t) \ue b_3, \setf{d|\emptyset} \ue \setf{b_4|e_2},$ &  \\
 & \wklammer $\setf{b_2|\setf{b_1|e_1}} \ue \setf{b_4|\setf{b_3|e_2}}}$ & \\
$\xrightarrow{\emph{Mu-Cl}}$ & $\dots$ & \\
\end{longtable}

%$ \mathbb{S}(c) = \mathbb{S}(d) = \mathbb{S}(e_i) = U, \\
%  \mathbb{S}(x) = \mathbb{S}(y) = \mathbb{S}(z) = V, \\
%  \mathbb{S}(s) = \mathbb{S}(t) = \mathbb{S}(u) = T.$ 
%\[
%\begin{array}{rl}
%& \set{umg(c,b(x,s)) \ue umg(d,umg(b(y,t),b(z,u)))} \\ \hline
%\text{Mu-C} \Rightarrow & \set{umg(c,b(x,s)) \ue umg(e_1,e_2) , umg(d,umg(b(y,t),b(z,u))) \ue umg(e_2,e_1)} \\
%\text{Dec} \Rightarrow & \set{c \ue e_1, b(x,s) \ue e_2, umg(d,umg(b(y,t),b(z,u))) \ue umg(e_2,e_1)} \\
%\text{Dec} \Rightarrow & \set{c \ue e_1, b(x,s) \ue e_2, d \ue e_2, umg(b(y,t),b(z,u)) \ue e_1} \\
%\text{Orient} \Rightarrow & \set{c \ue e_1, e_2 \ue b(x,s), d \ue e_2, umg(b(y,t),b(z,u)) \ue e_1} \\
%\text{Elim} \Rightarrow & \set{c \ue e_1, e_2 \ue b(x,s), d \ue b(x,s), umg(b(y,t),b(z,u)) \ue e_1} \\
%\text{Orient} \Rightarrow & \set{c \ue e_1, e_2 \ue b(x,s), d \ue b(x,s), e_1 \ue umg(b(y,t),b(z,u)) } \\
%\text{Elim} \Rightarrow & \set{c \ue umg(b(y,t),b(z,u)), e_2 \ue b(x,s), d \ue b(x,s), e_1 \ue umg(b(y,t),b(z,u)) } \\ \hline
%
%\text{Mu-C} \Rightarrow & \set{umg(c,b(x,s)) \ue umg(e_1,e_2) , umg(d,umg(b(y,t),b(z,u))) \ue umg(e_2,e_1)} \\
%\text{Dec} \Rightarrow & \set{c \ue e_1, b(x,s) \ue e_2, umg(d,umg(b(y,t),b(z,u))) \ue umg(e_2,e_1)} \\
%\text{Mu-C} \Rightarrow & \set{c \ue e_1, b(x,s) \ue e_2, umg(d,umg(b(y,t),b(z,u))) \ue umg(e_3,e_4), umg(e_2,e_1) \ue umg(e_4,e_3)} \\
%\end{array}
%\]
%\[\begin{array}{rl}
%& \set{umg(c,b(x,s)) \ue umg(b(y,t),d)} \\
%\text{Mu-C} \Rightarrow & \set{umg(c,b(x,s)) \ue umg(e_1,e_2) , umg(b(y,t),d) \ue umg(e_2,e_1)} \\
%\text{Dec} \Rightarrow & \set{c \ue e_1, b(x,s) \ue e_2, umg(b(y,t),d) \ue umg(e_2,e_1)} \\
%\text{Mu-C} \Rightarrow & \set{c \ue e_1, b(x,s) \ue e_2, umg(b(y,t),d) \ue umg(e_3,e_4), \\ 
%                        & \wklammer umg(e_2,e_1) \ue umg(e_4,e_3)} \\
%\text{Dec} \Rightarrow & \set{c \ue e_1, b(x,s) \ue e_2, b(y,t) \ue e_3, d \ue e_4,  \\
%                        & \wklammer umg(e_2,e_1) \ue umg(e_4,e_3)} \\
%\text{Mu-C} \Rightarrow & \set{c \ue e_1, b(x,s) \ue e_2, b(y,t) \ue e_3, d \ue e_4, \\ 
%                        & \wklammer umg(e_2,e_1) \ue umg(e_5,e_6),  umg(e_4,e_3) \ue umg(e_6,e_5)} \\
%\dots & \dots \\
%\end{array}\]

Nach jeder Anwendung des \emph{Cl}-Axioms wird eine
\emph{Decomposition}-Transformation möglich, die direkt wieder von
einem \emph{Cl}-Schritt gefolgt werden kann. Die Anwendung des Axioms
wird von der Unifikationsprozedur nicht beschränkt, abgesehen von den
oben genannten Bedingungen (Def. \ref{def:mutation-regel}), die hier
erfüllt sind.
Dadurch ist es möglich, die Bindungen einer Umgebung beliebig oft zu
vertauschen. Dies entspricht auch der mathematischen Intuition, hat hier 
allerdings die Nichtterminierung der Unifikation zur Folge. 
\end{beispiel}

Unifikation modulo beliebiger Gleichungstheorien ist generell
unentscheidbar,
ebenso wie Eigenschaften allgemeiner $\mathpzc{E}$-Unifikationsprobleme
(siehe z.B. \cite{nutt_unification_1991} zur Unentscheidbarkeit des
Unifikationstyps). Allgemeine Methoden, die $\mathpzc{E}$-Unifikatoren für
beliebige Gleichungstheorien berechnen, liefern aus diesem Grund nur
schwache Ergebnisse. So kann die oben skizzierte Methode nur verwendet
werden, um eine vollständige Menge von Unifikatoren rekursiv
aufzuzählen. Sie liefert somit keine Entscheidungsprozedur für
$\mathpzc{E}$-Unifizierbarkeit, selbst wenn in der betrachteten Gleichungstheorie
das Unifikationsproblem entscheidbar ist und der Unifikationstyp der
Theorie eindeutig oder endlich ist. 

Um bessere Berechenbarkeitsresultate für spezifische
Gleichungstheorien zu erhalten, wendet man sich einzelnen Theorien
zu. Die beiden Theorien (ohne Signaturen mit Sorten) 
$AC$ und $Cl$ besitzen eine Reihe guter 
Eigenschaften. Beide sind entscheidbar, allerdings ist Unifikation in
beiden Theorien NP-vollständig 
%(\emph{AC}: \citeA{kapur_complexity_1992}.
%{\emph{Cl}: \citeA{dovier_set_1998}) 
und beide Theorien haben den Unifikationstyp endlich.
%(\emph{AC}: \citeA{livesey_unification_1976},
%\citeA{stickel_unification_1981},
%\citeA{fages_associative-commutative_1984}. 
%\emph{Cl}: \citeA{dovier_set_1998}, 
%\citeA{stolzenburg_algorithm_1999}). 
Außerdem existieren für die Theorien Unifikationsalgorithmen.
%(\emph{AC}: \citeA{stickel_complete_1975},
%\citeA{livesey_unification_1976}, 
%\citeA{fortenbacher_algebraic_1985},
%\citeA{bttner_unification_1986}, 
%\citeA{lincoln_adventures_1989},
%\citeA{boudet_new_1990},
%\emph{Cl}: 
%\citeA{dovier_set_1998},
%\citeA{dovier_set_2006},
%\citeA{dantsin_bag_1999}). 
\citeA<Zur \emph{AC}-Theorie und zu Unifikationsalgorithmen siehe beispielsweise:>
{livesey_unification_1976,stickel_unification_1981,fortenbacher_algebraic_1985,bttner_unification_1986,lincoln_adventures_1989,boudet_new_1990}.
\citeA<Zur \emph{Cl}-Theorie und zu Unifikationsalgorithmen siehe
beispielsweise:>
{dovier_uniform_1998,dovier_set_1998,dantsin_bag_1999,stolzenburg_algorithm_1999,dovier_set_2006}

Allerdings berücksichtigt keiner dieser Algorithmen Sorten. Um
zu klären, wie sich das Verhältnis von Sorten zu Identitäten, die
eine Gleichungstheorie definieren, auf die $\mathpzc{E}$-Unifikation für
spezifische Theorien auswirkt, werden zunächst Charakterisierungen
für Gleichungstheorien \"uber Signaturen mit Sorten betrachtet. Dabei werden wir
Folgendes feststellen: Wenn bestimmte Bedingungen für
eine Gleichungstheorie $\mathpzc{E}$
über einer Signatur mit Sorten gelten, dann können $\mathpzc{E}$-Unifikatoren
berechnet werden, indem man mit einem speziellen
$\mathpzc{E}$-Unifikationsalgorithmus Unifikatoren berechnet, ohne
die Sorten zu berücksichtigen, und anschließend 
die berechneten Unifikatoren an die entsprechende Sortenstruktur
anpasst. 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Unifikation in Congruence Closed und Sort Preserving Gleichungstheorien}
\label{sec:unif-congr-clos}
In diesem Abschnitt werden zwei wichtige Eigenschaften von
Gleichungstheorien eingeführt. Anschließend wird gezeigt, wie diese
Eigenschaften verwendet werden können, um $\mathpzc{E}$-Unifikatoren in 
zwei unabhängigen Schritten zu berechnen. 
Dieser Abschnitt orientiert sich an \citeA{schmidt-schauss_computational_1989}. 

Die Identitäten, die eine Gleichungstheorie definieren, werden
formuliert mit Funktionssymbolen aus einer Signatur mit
Sorten $\Sigma$. Dabei sind zunächst keine Bedingungen an
die Identitäten gestellt. Insbesondere lassen sich Gleichungen
definieren, die nicht kompatibel mit der durch $\Sigma$ definierten
Sortenstruktur sind. Betrachtet man beispielsweise 
$\Sigma^{let}$ und  $E = \set{abs(x,u) \approx b(y,abs(x,u))}$, 
sowie die beiden Terme $s = abs(z,r),$ $t = b(y,(abs(z,r))$, 
dann gilt $ s =_{\Sigma^{let},E} t$. Die beiden Terme haben 
aber unterschiedliche Sorten, d.h. 
$S_{\Sigma}(s) \neq S_{\Sigma}(t)$. Außerdem haben wir beispielsweise 
$app(s,r)  =_{\Sigma^{let},E} app(t,r)$, wobei allerdings $app(t,r)$
kein wohlsortierter Term ist. Um solche Verhältnisse von Sorten zu
Identitäten zu charakterisieren definiert man:

\begin{definition}
\label{def:sort-preserving-congruence-closed}
Eine Gleichungstheorie $\mathpzc{E}=(\Sigma,E)$ ist 
\begin{enumerate}
\item \emph{deduction closed}, gdw.\ $s_1 \gee t_1, \dots s_n \gee t_n$
  und $f(s_1, \dots, s_n) \in T(\Sigma,X)$ impliziert, dass 
  $f(t_1, \dots, t_n)$ wohlsortiert ist. 
\item \emph{sort preserving}, gdw.\ für alle $s \gee t$ gilt 
  $\ssigf{t} = \ssigf{s}$.
\end{enumerate}
\end{definition}
Eine  Gleichungstheorie ist deduction closed, wenn Subterme eines
wohlsortierten Terms $t$ durch gleiche Terme ersetzt werden können, so
dass der Term $t$ wohlsortiert bleibt. 
Eine Theorie ist sort preserving, wenn gleiche Terme die gleichen Sorten 
besitzen. 
Ist eine Theorie sort preserving, dann ist sie auch deduction closed. 
Die für uns interessante Eigenschaft ist hier sort preservation, wie
wir weiter unten sehen werden (auf deduction closedness wird hier
nicht weiter eingegangen).
Gleichungstheorien, die sort preserving sind, haben eine wichtige Eigenschaft,
die die Berechnung von $\mathpzc{E}$-Unifikatoren vereinfacht:
Die Gleichheit von Substitutionen erhält deren Wohlsortiertheit.

%Für $\mathpzc{E}=(\overline\Sigma,E)$ sort preserving gilt:
%$\sigma \gE \tau$, $\sigma \in Sub_{\Sigma}$ impliziert $\tau \in
%Sub_{\Sigma}$. Diese Eigenschaft gilt i.A. nicht, wenn die Theorie
%nicht sort preserving ist. 

\begin{lemma}%[sort preserving subs]
\label{lemma:sort-preserving-subs}
Sei $\mathpzc{E}=(\Sigma,E)$ eine sort preserving Gleichungstheorie. 
Dann gilt 
\[\forall \sigma \in Sub_{\Sigma} \; \forall \tau \in Sub_{\overline\Sigma}:
  \sigma \gee \tau \Rightarrow \tau \in Sub_{\Sigma}.\] 
\end{lemma}
\begin{beweis}
Sei $\sigma \in Sub_{\Sigma}$ und $\tau \in Sub_{\overline\Sigma}$. 
Dann gilt $\set{x \mapsto \sigma x} \in Sub_{\Sigma}$ für alle $x$.
Nach Definition von wohlsortierten Substitutionen gilt 
$S_{\Sigma}(\sigma x) \supseteq S_{\Sigma}(x)$ und nach Voraussetzung
($\sigma \gee \tau$) und weil $\mathpzc{E}$ sort preserving ist gilt 
$S_{\Sigma}(\tau x) \supseteq S_{\Sigma}(x)$. Damit haben wir 
$\set{x \mapsto \tau x} \in Sub_{\Sigma}$ für alle $x$ und letztlich 
$\tau \in Sub_{\Sigma}$. $\qed$
\end{beweis}

Jeder Gleichungstheorie $\mathpzc{E}=(\Sigma,E)$ kann eine
\emph{unsortierte Gleichungstheorie}
$\mathcal{\overline{\mathpzc{E}}}=(\overline\Sigma,E)$
zugeordnet werden, die durch dieselben Identitäten $E$ definiert
ist, aber alle Sorten ignoriert. 
Eine weitere, für die Berechnung von $\mathpzc{E}$-Unifikatoren interessante
Eigenschaft von Gleichungstheorien, wird charakterisiert durch die
Beziehung zwischen einer Theorie $\mathpzc{E}$ und der zugehörigen unsortierten
Theorie $\overline{\mathpzc{E}}$.

\begin{definition} Eine Gleichungstheorie $\mathpzc{E}=(\Sigma,E)$ ist
\emph{congruence closed}, gdw.\ für alle $s,t \in T(\Sigma,X)$
  gilt $s \gee t \Leftrightarrow s =_{\overline{\mathpzc{E}}} t$.
\end{definition}

Ist eine Gleichungstheorie $\mathpzc{E}$ congruence closed, dann kann zur Berechnung
von $\mathpzc{E}$-Unifikatoren in zwei unabhängigen, aufeinander folgenden Schritten
vorgegangen werden: 
\begin{itemize}
\item Ignoriere die Sorten und berechne einen
  $\overline{\mathpzc{E}}$-Unifikator
  für die unsortierte Theorie $\overline{\mathpzc{E}}$. 
\item Ignoriere alle Identitäten und passe die berechneten
  $\overline{\mathpzc{E}}$-Unifikatoren an gegebene Sorten an. 
\end{itemize}

\begin{proposition}
\label{prop:c-c-unifier}
Sei $\mathpzc{E}=(\Sigma,E)$ eine congruence closed
Gleichungstheorie. Dann gilt 
\[U_{\overline{\mathpzc{E}}}(P) \cap Sub_{\Sigma} = U_{\mathpzc{E}}(P)\] 
für alle $\mathpzc{E}$-Unifikationsprobleme $P$. 
\end{proposition}
\begin{beweis}
$U_{\overline{\mathpzc{E}}}(P) \cap Sub_{\Sigma} \supseteq U_{\mathpzc{E}}(P)$ folgt direkt
  aus $Sub_{\Sigma} \subseteq Sub_{\overline\Sigma}$.

Es wird $U_{\overline{\mathpzc{E}}}(P) \cap Sub_{\Sigma} \subseteq U_{\mathpzc{E}}(P)$ gezeigt.
Sei dazu $\sigma \in U_{\overline{\mathpzc{E}}}(P) \cap Sub_{\Sigma}$. Damit gilt 
$\sigma s_i =_{\overline{\mathpzc{E}}} \sigma t_i$ für alle
$\mathpzc{E}$-Unifikationsprobleme $P = \set{s_i \ue t_i}$ und weil $\mathpzc{E}$
congruence closed ist, haben wir 
$\sigma s_i =_{\overline{\mathpzc{E}}} \sigma t_i \Leftrightarrow \sigma s_i =_{\mathpzc{E}} \sigma t_i$.
D.h. $\sigma \in U_{\mathpzc{E}}(P)$. $\qed$
\end{beweis}

Für eine Gleichungstheorie $\mathpzc{E}=(\Sigma,E)$, die nicht congruence closed
ist, hat man nach dieser Proposition folgende unangenehme Situation:
Es gibt Terme $s,t$ für die $s =_{\overline{\mathpzc{E}}} t$ und 
$s \not \gee t$ gilt, woraus folgt
$Id \in U_{\overline{\mathpzc{E}}}(s \ue t)\cap Sub_{\Sigma}$ und 
$Id \notin U_{\mathpzc{E}}(s \ue t)$. 
 
Die Anpassung von $\overline{\mathpzc{E}}$-Unifikatoren, 
die berechnet werden, ohne die Sorten zu beachten, an die
gegebene Sortenstruktur, geschieht durch sogenannte \emph{Weakenings}.  
\begin{definition}[Weakening]
\label{def:weakening}
Das \emph{Weakening}-Problem zu einer Substitution $\tau \in Sub_{\overline\Sigma}$ 
ist folgendermaßen definiert: Gegeben eine (unsortierte) Substitution 
$\tau \in Sub_{\overline\Sigma}$, finde eine wohlsortierte Substitution 
$\omega \in Sub_{\Sigma}$, so dass $\omega \tau \in Sub_{\Sigma}$. Die
wohlsortierte Substitution $\omega$ wird als \emph{Weakening} von
$\tau$ bezeichnet. Die Menge der Lösungen für das Weakening-Problem
von $\tau$ wird durch $W_{\Sigma}(\tau)$ bezeichnet. 
Analog zu
Definition \ref{def:vollst-min-mgu-menge-E} wird eine vollständige 
(minimale) Menge von Weakenings $CW_{\Sigma}(\tau)$
(bzw. $MW_{\Sigma}(\tau)$) zu einer Substitution $\tau$ definiert. 
\end{definition}

Man beachte, dass Weakenings nicht bezüglich Gleichungstheorien
definiert sind, sondern nur bezüglich Signaturen. 
Für reguläre und elementare Signaturen hat die Menge der Weakenings
eine besonders einfache Struktur.
\begin{proposition}
\label{prop:muw-in-reg-elem-sig}
Sei $\Sigma$ eine endliche, elementare und reguläre Signatur und 
$\tau \in Sub_{\overline\Sigma}$, so dass eine wohlsortierte
Substitution $\omega$ existiert mit $\omega \tau \in Sub_{\Sigma}$.
Dann existiert eine minimale, vollständige Menge $MU_{\Sigma}(\tau)$, 
die 
%effizient berechenbar ist und 
nur aus
    $\overline\Sigma$-{Va\-ri\-a\-blen\-um\-be\-nen\-nung\-en}\footnote{Eine
    $\overline\Sigma$-Variablenumbenennungen $\rho$, muss nicht sort
    preserving sein, d.h. $S_{\Sigma}(\rho x) = S_{\Sigma}(x)$ gilt
    i.A. nicht für alle $x \in \Dom(\rho)$.}
besteht. 
\end{proposition}
\begin{beweis}
Sei $\omega$ eine Substitution, so dass $\omega \tau \in Sub_{\Sigma}$
wohlsortiert ist. Sei $\delta$ eine Substitution, mit 
$\Dom(\delta) = \VRan(\tau)$ und $\Ran(\delta)$ bestehe aus neuen 
Variablen, so dass $LS_{\Sigma}(\delta x) = LS_{\Sigma}(\omega x)$.
Dann gilt $LS_{\Sigma}(\delta \tau y) = LS_{\Sigma}(\omega \tau y)$ 
für alle $y \in \VRan(\tau)$, weil $\Sigma$ elementar
ist\footnote{In elementaren Signaturen ist die Sorte eines Terms $f(t_1,\dots, t_n)$ 
  vollständig bestimmt durch die Sorte von $f$ und die Sorten der  $t_i$.}  
und nach Konstruktion von $\delta$.
Folglich ist $\delta$ ein Weakening von $\tau$, außerdem ist $\delta$
nach Konstruktion eine $\overline\Sigma$-Variablenumbenennung. % $\delta \in W_{\Sigma}(\tau)$.
Nach Konstruktion gilt außerdem $\delta \lesssim_{\Sigma} \omega [\VRan(\tau)]$,
woraus wir folgern, dass $CU_{\Sigma}(\tau)$ existiert und lediglich
aus $\overline\Sigma$-Variablenumbenennungen besteht. Die
vollständige Menge von Weakenings ist endlich, weil $\Sigma$ 
und $\VRan(\tau)$ endlich sind. Also kann sie zu einer minimalen
vollständigen Menge von Weakenings $MW_{\Sigma}(\tau)$ gemacht
werden, indem jeweils nur ein Repräsentant der Äquivalenzklassen
bezüglich $\sim_{\Sigma}$ in $MW_{\Sigma}(\tau)$ aufgenommen wird. 
$\qed$
\end{beweis}

Um das zentrale Resultat 
%diese Abschnittes 
zu beweisen, benötigen wir folgendes technisches Detail:
Alle Variablen einer unsortierten Substitution $\sigma$ in
$\VRan(\sigma)$ können so gewählt werden, dass sie eine maximale
Sorte $\Top$ besitzen, für die $S \undertilde{\sqsubset} \Top$ für alle
$S \in S_{\Sigma}$ gilt. Besitzt eine Signatur keine solche
$\Top$-Sorte, dann kann  sie um eine solche erweitert werden.
\begin{lemma}%[top sort]
\label{lemma:top-sort}
Sei $\mathpzc{E}=(\Sigma,E)$ eine Gleichungstheorie. Dann kann zu der
Menge $S_{\Sigma}$ der Sortensymbole eine Sorte $\Top$ hinzugefügt
werden, mit $S \sseq \Top$ für alle $S \in S_{\Sigma}$,
so dass sich an der Instantiierungs-Quasiordnung nichts ändert. 
\end{lemma}
\begin{beweis}
Die Menge der Terme $T(\Sigma,X)$ ändert sich nicht, es kommen nur
neue Variablen der Sorte $\Top$ hinzu. Neue Komponenten in
Substitutionen sind $\set{x_{\Top} \mapsto t}$, die wohlsortiert sind
und die $\iqse$ auf alten Substitutionen nicht beeinflussen. 
$\qed$
\end{beweis}

\begin{korollar}
\label{kor:top-sort}
Sei $\sigma \in Sub_{\overline\Sigma}$. Dann können die Variablen in
$\VRan(\sigma)$ so gewählt werden, dass 
$S_{\Sigma}(x) = \Top$ für alle $x \in \VRan(\Sigma)$ gilt.
\end{korollar}

Wir kommen zum zentralen Satz, der angibt, wie $\mathpzc{E}$-Unifikatoren für
eine Gleichungstheorie berechnet werden können, die congruence closed
und sort preserving ist. 
\begin{satz}[\citeA{schmidt-schauss_computational_1989}]
\label{satz:satz-vom-schmidt-schauss}
Sei $\mathpzc{E}=(\Sigma,E)$ eine Gleichungstheorie, die congruence
closed und sort preserving ist und sei $P$ ein beliebiges
$\mathpzc{E}$-{Uni\-fi\-ka\-ti\-ons\-pro\-blem} mit $W = \Var(P)$. Dann gilt
\[\begin{array}{l}
\text{für alle} \; \delta \in U_{\mathpzc{E}}(P) \\
\text{gibt es} \; \sigma \in \set{\omega \tau \; | \; \tau \in CU_{\overline{\mathpzc{E}}}(P), \omega \in MW_{\Sigma}(\tau)}, \\
\text{so dass} \; \sigma \iqse \delta [W]. 
\end{array}\]
\end{satz}
\begin{beweis}
Sei $\delta \in U_{\mathpzc{E}}(P)$.
Nach Proposition \ref{prop:c-c-unifier} gilt  
$U_{\mathpzc{E}}(P) = U_{\overline{\mathpzc{E}}}(P) \cap Sub_{\Sigma}$, weil $\mathpzc{E}$
congruence closed ist, d.h. $\delta \in U_{\overline{\mathpzc{E}}}(P) \cap Sub_{\Sigma}$.
Folglich gibt es für $\delta$ eine (unsortierte)
Substitution $\tau \in CU_{\overline{\mathpzc{E}}}(P)$ 
%aus der Menge dervollständigen Unifikatoren 
und eine Substitution 
$\theta \in Sub_{\overline\Sigma}$, so dass $\Dom(\theta) =
\VRan(\tau)$ und
$\theta \tau =_{\overline{\mathpzc{E}}} \delta [W]$. 
Nach Korollar \ref{kor:top-sort} können alle Variablen in $x \in \VRan(\tau)$ so
gewählt werden, dass sie die $\Top$-Sorte besitzen: $S_{\Sigma}(x) = \Top$.
%Nach Definition 
%\ref{def:inst-quas-e} ist $\tau \lesssim_{\overline{\mathpzc{E}}} \delta [W]$  
%gleichbedeutend mit 
%$\exists \theta \in Sub_{\overline\Sigma}: \theta \tau =_{\overline{\mathpzc{E}}} \delta [W]$.
Anwendung der congruence closed Eigenschaft von $\mathpzc{E}$ auf
$\theta \tau =_{\overline{\mathpzc{E}}} \delta [W]$ ergibt
$\theta \tau =_{\mathpzc{E}} \delta [W]$.

Jetzt ist noch zu zeigen, dass $\theta$ durch Instantiierung aus einem
wohlsortierten minimalen Weakening von $\tau$ gewonnen werden
kann. Dazu wird zuerst gezeigt, dass $\theta$ wohlsortiert ist.
Weil $\mathpzc{E}$ sort preserving ist, und 
$\theta \tau =_{\overline{\mathpzc{E}}} \delta [W]$, $\delta \in Sub_{\Sigma}$ 
gilt, kann man mit Lemma \ref{lemma:sort-preserving-subs} folgern, dass
$\theta \tau x$ wohlsortiert ist für alle $x \in W$.
Insbesondere sind alle Terme in $\Ran(\theta)$ wohlsortiert. 
Es gilt $\Dom(\theta) = \VRan(\tau)$ (nach Konstruktion von $\theta$)
und da alle Variablen in $\VRan(\tau)$ so gewählt wurden, dass sie die
$\Top$-Sorte besitzen, gilt $\forall x \in \Dom(\theta):$ 
$S_{\Sigma}(x) \supseteq S_{\Sigma}(\theta x)$, d.h. $\theta \in Sub_{\Sigma}$.

Halten wir fest, dass $\theta$ und $\delta$ wohlsortiert sind und 
$\theta \tau \gee \delta[W]$ gilt, d.h. $\theta$ ist ein Weakening von
$\tau$ (Def. \ref{def:weakening}). 
Die minimale vollständige Menge $MU_{\Sigma}(\tau)$
existiert\footnote{Für reguläre elementare Signaturen nach
  Proposition \ref{prop:muw-in-reg-elem-sig}, im allgemeinen Fall
  siehe \citeA{schmidt-schauss_computational_1989}, S. 96.} 
und wir wählen ein $\omega \in MU_{\Sigma}(\tau)$, so dass 
$\omega \lesssim_{\Sigma} \theta$, d.h. 
$\exists \eta \in Sub_{\Sigma}: \eta \omega = \theta [W]$. 
Einsetzen von $\eta \omega$ für $\theta$ ergibt 
$\eta \omega \tau = \delta [W]$ und folglich $\omega \tau \iqse \delta [W]$.
$\qed$
\end{beweis}

Nach diesem Satz ist 
$\set{\omega \tau \;|\; \tau \in CU_{\overline{\mathpzc{E}}}(P), \omega \in MW_{\Sigma}(\tau)}$ 
eine vollständige Menge von Unifikatoren für ein
$\mathpzc{E}$-Unifikationsproblem, wenn $\mathpzc{E}$ sort preserving und congruence
closed ist. Der entscheidende Punkt hierbei ist, dass $CU_{\overline{\mathpzc{E}}}(P)$
berechnet werden kann, ohne die Sorten von $\mathpzc{E}$ zu berücksichtigen,
und $MW_{\Sigma}(\tau)$ berechnet werden kann, ohne die definierenden 
Identitäten von $\mathpzc{E}$ zu berücksichtigen. 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Eigenschaften von \eletac und \eletcl}
\label{sec:eigensch-von-e_ac-und-e_p}
Wir untersuchen die beiden Theorien \eletac und \eletcl
auf congruence closedness und sort preservation. 
\begin{bemerkung}
Die beiden Theorien \eletac und \eletcl verf\"ugen \"uber endliche
und einfache Signaturen. Aus der Einfachheit folgt, dass die 
Signaturen auch elementar und 
regul\"ar sind (vgl. Abschnitt \ref{sec:wohlsortierte-terme}).  
\end{bemerkung}

Im Allgemeinen ist es unentscheidbar, ob eine Gleichungstheorie
congruence closed 
%(auch für elementare, reguläre Signaturen)
ist, was man durch Reduktion 
auf das Wortproblem\footnote{Gegeben eine Gleichungstheorie $\mathpzc{E}$ und
Terme $s,t$. Gilt $s =_{\mathpzc{E}} t$?} zeigen kann 
\cite{schmidt-schauss_computational_1989}. 
Folgendes Lemma gibt ein einfaches Kriterium, mit dem sich für
endliche, reguläre und elementare Signaturen prüfen lässt, ob eine
Gleichungstheorie congruence closed ist.   
Die Beweise der beiden Lemmata, mit denen sich für
bestimmte (endliche, reguläre und elementare) Gleichungstheorien  
feststellen lässt, ob sie congruence closed und sort preserving sind, 
sind hier ausgespart. Sie sind in 
\citeA{schmidt-schauss_computational_1989} zu finden.

\begin{lemma}%[bedingung fuer congruence closedness]
\label{lemma:beding-fuer-congr-closed}
Sei $\Sigma$ eine endliche, elementare und reguläre Signatur. 
Wenn für alle Identitäten $s \approx t \in E$ und für alle
$\overline \Sigma$-{Va\-ri\-a\-blen\-um\-be\-nen\-nung\-en} $\rho$ gilt
$\rho s \in T(\Sigma,X)$ impliziert $\rho \in Sub_{\Sigma}$, dann ist
$\mathpzc{E}$ congruence closed.
\end{lemma}

\begin{proposition}
\label{prop:congruence-closedness-ac-p}
Die Theorien \eletac und \eletcl sind congruence closed. 
\end{proposition}
\begin{beweis}
Wir zeigen congruence closedness für \eletcl.
Sei $\rho$ eine $\overline\Sigma$-{Va\-ri\-a\-blen\-um\-be\-nen\-nung}, so dass 
$\rho(\setf{c_B|\setf{d_B|e_U}}) \in T(\Sigma^{let},X)$. 
Jetzt ist zu zeigen, dass 
$LS_{\Sigma^{let}}(x) \sqsubseteq LS_{\Sigma^{let}}(\rho x)$
f\"ur alle $x \in \Dom(\rho)$ gilt, 
was offensichtlich der Fall ist, weil die Wohlsortiertheit von 
$\rho(\setf{c_B|\setf{d_B|e_U}})$ 
impliziert $\rho(c), \rho(d): B$ und $\rho(e) : R \sqsubseteq U$.
%(d.h. $S = U$ oder $S = B$).

Der Beweis geht analog für \eletac. $\qed$
\end{beweis}

Die Eigenschaft sort preservation ist ebenfalls unentscheidbar für
den allgemeinen Fall, allerdings ist die Eigenschaft entscheidbar,
wenn die Signatur endlich, elementar und regulär ist. 

\begin{lemma}%[bedingung fuer sort preserving]
\label{lemma:bedingung-fuer-sort-preserving}
Sei $\Sigma$ eine endliche und elementare Signatur. 
\begin{enumerate}
\item Für alle $\sigma \in Sub_{\Sigma}$ und für alle 
  $s \approx t \in E$ gilt
  \[S_{\Sigma}(\sigma s) = S_{\Sigma}(\sigma t)\; \Leftrightarrow \;\; =_{\mathpzc{E}} \; \text{ist sort preserving.}\]
\item Sei $\Sigma$ außerdem regulär. Wenn
  für alle wohlsortierten $\overline \Sigma$-{Va\-ri\-a\-blen\-um\-be\-nen\-nung\-en} $\rho$
  und für alle $s \approx t \in E$ gilt $LS_{\Sigma}(\rho s) = LS_{\Sigma}(\rho t)$, 
  dann folgt $\forall \sigma \in Sub_{\Sigma} \;\; \forall s \approx t \in E: LS_{\Sigma}(\sigma s) = LS_{\Sigma}(\sigma t)$. 
\end{enumerate}
\end{lemma}

\begin{proposition}
\label{prop:sort-preservation-ac-p}
Die Theorien \eletac und \eletcl sind sort preserving. 
\end{proposition}
\begin{beweis}
\sloppy
Es wird sort preservation für \eletcl gezeigt. 
Dazu muss für alle wohlsortierten
$\overline\Sigma$-Variablenumbenennungen $\rho$ geprüft werden, ob 
$LS_{\Sigma}(\rho(\setf{c_B|\setf{d_B|e_U}})) = LS_{\Sigma}(\rho(\setf{ d_B | \setf{ c_B | e_U}}))$
gilt. Als wohlsortierte $\overline\Sigma$-Variablenumbenennungen kommen
in Frage: $\rho = \set{c \mapsto c', d \mapsto d', e \mapsto e'}$ mit 
$c',d':B,\;e':R \sqsubseteq U$, wofür die Bedingung
erfüllt ist. Sort preservation für \eletcl folgt dann aus der ersten
Aussage von Lemma \ref{lemma:bedingung-fuer-sort-preserving}. 

Der Beweis für die Theorie \eletac geht analog. $\qed$
\end{beweis}

Beide Theorien sind sowohl congruence closed
als auch sort preserving. Damit 
%erfüllen sie die Voraussetzung, um 
können in beiden Theorien Unifikatoren auf die beschriebene Art
in zwei unabhängigen Schritten berechnet werden. 
Alle Sorten k\"onnen zun\"achst ignoriert werden. Zur 
Unifikation von Termen mit einem assoziativen und kommutativen, 
bzw. einem links-kommutativen Funktionssymbol kann ein
Unifikationsalgorithmus verwendet werden, der Terme unter
Ber\"ucksichtigung der entsprechenden Axiome unifiziert. 
Wie wir bereits am Ende von Abschnitt \ref{sec:synt-unif-fur} bemerkt
haben, existierten f\"ur $AC$- und $Cl$-Funktionssymbole eine Reihe von
Unifikationsalgorithmen, auf die zur\"uckgegriffen werden kann. 
Betrachten wir zun\"achst die generelle Vorgehensweise zur Unifikation
von $AC$-Funktionssymbolen. 

Aufgrund der hohen Bedeutung von $AC$-Funktionssymbolen existiert 
eine Vielzahl von Arbeiten, die sich mit deren Unifikation
beschäftigen (f\"ur eine \"Ubersicht siehe die bereits zitierten Arbeiten, sowie
\citeA{baader_unification_2001}). $AC$-Unifikation verwendet
(semantische) Eigenschaften der durch die $AC$-Theorie definierten freien Algebren,
um Unifikationsprobleme in Gleichungen über bestimmte algebraische
Strukturen (Diophantische Gleichungen) zu übersetzen und dann mit Hilfe
bekannter mathematischer Resultate zu lösen. Dabei wurden historisch
zunächst nur $AC$-Unifikationsprobleme zwischen Termen betrachtet,
die lediglich $AC$-{Funk\-ti\-ons\-sym\-bole}, Konstanten und Variablen enthielten 
(\citeA{stickel_complete_1975}, \citeA{livesey_unification_1976}). Um
Unifikationsprobleme mit zusätzlichen freien 
Funktionssymbolen (das sind Funktionssymbole, die nicht assoziativ und
kommutativ sind) zu lösen, benötigt man zusätzlich die Theorie zur
Kombination von Unifikationsalgorithmen
(\citeA{schmidt-schauss_unification_1988}, \citeA{baader_unification_1996}).
Da \letr-Umgebungen i.A. freie Funktionssymbole ($\set{\cdot}$ und $b(\cdot,\cdot)$)
enthalten, muss die Kombination von Unifikationsalgorithmen für
allgemeine Unifikation von $AC$-Funktionssymbolen berücksichtigt
werden. 

Unifikationsalgorithmen f\"ur $Cl$-Funktionssymbole folgen einem eher
syntaktischen Ansatz. Unifikationsprobleme werden schrittweise in
gel\"oste Form transformiert. Die \emph{Decomposition}-Regel wird f\"ur 
das $Cl$-Funktionssymbol durch eine Regel ersetzt, die
Vertauschbarkeit von Argumenten ber\"ucksichtigt. In der Literatur ist
dieser Ansatz unter dem Stichwort 
"`Unifikation von (Multi-) Mengen"' zu finden 
\cite{dovier_uniform_1998,dantsin_bag_1999,dovier_set_2006}. 
Wie wir gesehen haben (Bemerkung \ref{bem:eletcl-ist-einschraenukug-von-eletac}), 
stellt die $Cl$-Theorie eine Einschränkung der $AC$-Theorie dar, da
die Anzahl der Variablen der Sorte $U$ in $Cl$-Umgebungstermen auf
eins beschränkt ist, im Gegensatz zu $AC$-Umgebungstermen, die beliebig
viele Variablen der Sorte $U$ enthalten k\"onnen (zum Verhältnis von 
$AC$-Theorien zu $Cl$-Theorien siehe auch \citeA{dovier_set_1998}).
%Die gegenüber der $AC$-Theorie eingeschränkte $Cl$-Theorie ist
Allerdings ist die $Cl$-Theorie  ausreichend, um Vertauschbarkeit von
Elementen in \letr-Umgebungen zu axiomatisieren (Bemerkung
\ref{bem:eletcl-ist-einschraenukug-von-eletac}).  
Sie ermöglicht einen
Unifikationsalgorithmus, der sich im Rahmen der bisher behandelten
(syntaktischen) Begriffe bewegt, ohne zusätzlich auf Methoden
zurückzugreifen, die semantische Eigenschaften der Gleichungstheorien
verwenden. Ein Vorteil dieses syntaktischen Ansatzes ist, dass er
direkt mit den in Kapitel \ref{cha:unif-fur-terme-mit-sorten} %\ref{sortedcha:unif-fur-terme-mit-sorten}
definierten Unifikationsregeln
für reguläre Signaturen verwendet werden kann. 
Ein Vorgehen in zwei Schritten wie oben beschrieben, ist nicht
notwendig.\footnote{Schon aus dem Grunde nicht, weil die Signatur
  $\Sigma^{let}$ \"uber einen eindeutigen Unifikationstyp verfügt.}  
Aus diesem Grund, und da sich die beiden Theorien
bezüglich der Berechenbarkeitseigenschaften nicht unterscheiden,
fällt die Wahl hier auf die \eletcln-Theorie anstelle der \eletac
Theorie, um die Vertauschbarkeit von Elementen in \letr-Umgebung zu
repräsentieren.  

Nachdem die Entscheidung auf die \eletcln-Theorie gefallen ist,
betrachten wir noch einmal genau, wie
\letr-Umgebungen in $\Sigma^{let}_{\setf{\cdot|\cdot}}$-Terme
\"ubersetzt werden.

\begin{definition}
\label{def:uebersetzung}
Die in Abschnitt \ref{sec:sig-terme-subs-mit-sorts} %\ref{sortedsec:wohlsortierte-terme} 
definierte Abbildung 
$\transl{\;} : \Lambda^{let} \rightarrow T(\Sigma^{let},X)$, 
%die Ausdrücke des Ursprungskalküls $\Lambda^{let}$ 
%(ausgenommen Variablenketten und Kontextvariablen) 
%übersetzt in $\Sigma^{let}$-Terme erster Ordnung mit Sortinformation,
wird folgendermaßen zu einer Abbildung 
$\transl{\;} : \Lambda^{let} \rightarrow T(\Sigma^{let}_{\setf{\cdot|\cdot}},X)$
erweitert, um \letr-Umgebungen zu übersetzen.  
%(Es wird noch einmal darauf
%hingewiesen, dass Kontextvariablen und Ketten  
%hier noch nicht behandelt werden.)
\begin{longtable}{rcl}
%\transl{x}           & = & x_V \\
%\transl{v}           & = & v_A \\
%\transl{s}           & = & s_T \\
%\transl{E}           & = & e_U \\ 
%\transl{\lambda x.s} & = & abs(\transl{x},\transl{s}) \\
%\transl{(s \; t)}      & = & app(\transl{s},\transl{t}) \\;
$ \transl{\letrecm{Env}{s}} $ & $ = $ & $ letrec(\transl{Env},\transl{s}) $ \\
$ \transl{\set{Env, x_1 = s_1, \dots, x_n = s_n}} $ & $ = $ & $
   \transl{\set{x_1=s_1, \dots, x_n=s_n, Env}} $ \\
$ \transl{\set{x_1 = s_1, \dots, Env, \dots, x_n = s_n}} $ & $ = $ & $
  \transl{\set{x_1=s_1, \dots, x_n=s_n, Env}} $ \\
$\transl{\set{x_1=s_1,x_2=s_2, \dots, x_n=s_n}} $ & $ = $ & $ \setf{\transl{x_1=s_1}|\transl{\set{x_2=s_2, \dots, x_n=s_n}}} $ \\
$\transl{\set{x=s, Env}} $ & $ = $ & $ \setf{\transl{x=s}|\transl{Env}} $ \\
$\transl{\set{x=s}} $ & $ = $ & $ \setf{\transl{x=s}|\emptyset } $ \\
$\transl{x=s} $ & $ = $ & $bind(\transl{x},\transl{s}) $ \\
%\set{Env,\set{x_i =x_{i-1}}^n_{i=m}}
\end{longtable}
\end{definition}

Aufgrund der Sorte $B \rightarrow U \rightarrow U$ des Funktionssymbols 
$\setf{\cdot|\cdot}$ muss die Umgebungsvariable an die
letzte Position in der Umgebung getauscht werden. 
Ist in einer Umgebung keine Umgebungsvariable enthalten, muss das
zusätzliche Konstantensymbol $\emptyset$ an letzter Position durch
die Übersetzung eingefügt werden. 
So wird sichergestellt, dass bei der Übersetzung keine Umgebungen der Form 
$\setf{b_1|b_2}$ mit $b_1,b_2$ Terme der Sorte $B$ entstehen. 
Umgebungsterme dieser Form werden vermieden, weil für Unifikationsprobleme der
Gestalt 
$\setf{b_1|b_2} \ue \setf{b_3|b_4}$ das \emph{Cl}-Axiom nicht
anwendbar ist, und deshalb nicht alle möglichen Unifikatoren berechnet
werden. Für das Problem 
$\setf{b_1|\setf{b_2|\emptyset}} \ue \setf{b_3|\setf{b_4|\emptyset}}$
ist das \emph{Cl}-Axiom anwendbar und alle Unifikatoren können
wie erwartet berechnet werden. 

\sloppy
F\"ur einen $\Sigma^{let}_{\setf{\cdot|\cdot}}$-Umgebungsterm 
wird verk\"urzt $\setf{s_1,\dots, s_m|S}$ geschrieben, 
anstatt $\setf{s_1|\setf{ \dots \setf{s_m|S}\dots}}$.
%wobei $s_i$ Terme mit Sort $R \sseq B$ sind und 
%$S$ einen beliebigen Term mit Sort $R' \sseq U$ ist.
Ist $S = \emptyset$, schreiben wir $\setf{s_1, \dots, s_m}$.
Im weiteren Verlauf bezeichnen $X,Y,N$ Variablen der Sorte $U$, die
auch Umgebungsvariablen genannt werden. 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Unifikation in \eletcl}
%in endlichen und regul\"aren Signaturen mit einem Permutativen Funktionssymbol}
\label{sec:unifikationsalgo}
In diesem Abschnitt wird ein Algorithmus vorgestellt, um Unifikatoren 
%wird erklärt, wie Unifikatoren f\"ur
f\"ur  \eletcln-{Uni\-fi\-ka\-ti\-ons\-pro\-bleme} zu berechnen.
%$\mathpzc{E}$-Unifikatoren für Probleme über Gleichungstheorien mit
%endliche reguläre Signaturen und einem Permutativen Funktionssymbol
%%$\setf{\cdot|\cdot}$ berechnet werden können. 
Da das links-kommutative Funktionssymbol
$\setf{\cdot|\cdot}$ als Multimengenkonstruktor verstanden werden
kann, orientieren wir uns an Arbeiten zur Unifikation von Multimengen.
%(\citeA{dovier_uniform_1998}). 
Der Algorithmus wird bez\"uglich der Theorie \eletcl erkl\"art. Er kann
aber zur Unifikation von beliebigen $\Sigma$-Termen verwendet werden, wenn 
\begin{itemize}
\item $\Sigma$ eine regul\"are und elementare
  %\footnote{Da es sich bei
  %$\Sigma^{let}_{\setf{\cdot|\cdot}$ um eine einfache Signatur
  %handelt, konzentrieren wir uns vor allem auf  }) 
  %und elementaren 
  Signatur ist und
  %außerdem congruence closed und sort preserving ist. Und 
\item in der Signatur ein \emph{Cl}-Funktionssymbol enthalten ist, das
  eine vergleichbare Sorte wie $\setf{\cdot|\cdot}$ besitzt.
\end{itemize}

Ein Unifikator für ein gegebenes Unifikationsproblem wird durch
Transformation des Problems in gel\"oste Form berechnet. Dazu werden
die Unifikationsregeln des vorhergehenden Kapitels verwendet, wobei
die \emph{Decomposition} Regel für das 
\emph{Cl}-Funktionssymbol $\setf{\cdot|\cdot}$ ersetzt wird durch eine
spezielle Unifikationsregel, die Vertauschbarkeit von Argumenten
berücksichtigt, da die Transformation von  
$\setf{s_1, \dots, s_m|S} \ue \setf{t_1, \dots, t_n|T}$ 
mit \emph{Decomposition} i.A. in Nicht-Unifizierbarkeit resultiert und
nicht alle möglichen Unifikatoren gefunden werden. 

\begin{definition}%[p-unifikationsregeln]
\label{def:p-unifikationsreglen}
Sei $P$ ein \eletcln-Unifikationsproblem. 
Die Unifikationsregeln f\"ur
regul\"are Signaturen (Definition \ref{def.unifikationsregeln})
werden folgenderma"sen erweitert und modifiziert 
\cite<nach>{dovier_uniform_1998}:

\fbox{
\begin{minipage}{0.98\textwidth}
$\begin{array}{l}
\multicolumn{1}{l}{\mathbf{Decomposition}} \\
\set{f(s_1, \dots s_n) \ue f(t_1, \dots t_n)} \uplus P \Rightarrow \set{s_1 \ue t_1, \dots s_n \ue t_n} \cup P \\ 
\quad \text{wenn}\; f \in \Sigma^n - \set{\setf{\cdot|\cdot}}. \\
\end{array}$

$\begin{array}{l}
\multicolumn{1}{l}{\mathbf{U-Decomposition}} \\
\set{\setf{t|s} \ue \setf{t'|s'}} \uplus P \Rightarrow
                                                      \begin{array}[t]{rl} 
							 i)& \set{t \ue t', s \ue s'} \cup P  \\
							ii)& \set{s \ue \setf{t'|N}, \setf{t|N} \ue s'} \cup P \\  
						      \end{array} \\
 \quad \text{wobei}\; N \; \text{eine neue Variable der Sorte U ist.} 
\end{array}$
\end{minipage}}
\end{definition}

Die Regel \emph{U-Decomposition} wird im weiteren Verlauf abgekürzt
bezeichnet als \emph{U-Dec}. Zur Unifikation von Gleichungen der Art
$\setf{s_1, \dots, s_m|S} \ue \setf{t_1, \dots, t_n|T}$ wird nichtdeterministisch
eine der Transformationsmöglichkeiten $i)$ oder $ii)$ der
\emph{U-Dec}-Regel gewählt. 

Für Unifikationsprobleme zwischen zwei Umgebungen, die beide dieselbe
Umgebungsvariable $X$ enthalten, können die oben definierten
Unifikationsregeln zu einer nicht terminierenden Folge von
Transformationen führen. Beispielsweise 

\begin{tabular}{rl}
& $\setf{t|X} \ue \setf{u|X}$\\
$\xrightarrow{\emph{U-Dec}\; ii)}$& $\set{X \ue \setf{u|N}, \setf{t|N} \ue X}$ \\
$\xrightarrow{\emph{Elim}}$& $\set{X \ue \setf{u|N}, \setf{t|N} \ue \setf{u|N}}$. \\
\end{tabular}

Das letzte Unifikationsproblem ist mindestens so kompliziert wie
das erste. Diesem Problem kann man begegnen, indem man sich
überlegt, dass eine Gleichung zwischen Umgebungen, in der dieselbe
Umgebungsvariable in beiden Umgebungen vorkommt, nur dann eine Lösung
besitzt (unter $Cl$), wenn beide Umgebungen genau die
gleiche Anzahl von Elementen besitzen. 
Die Regel \emph{U-Dec} wird dann aufgespalten in die Fälle:
\begin{enumerate}
\item Die Umgebungsvariablen zweier zu unifizierender Umgebungen sind
  gleich, dann ersetze beide Variablen durch die Konstante $\emptyset$ und unifiziere
  die resultierenden Umgebungen. Oder
\item die zu unifizierenden Umgebungen besitzen keine gemeinsamen
  Umgebungsvariablen, dann unifiziere die Umgebungen wie unter
  \emph{U-Dec} angegeben. 
\end{enumerate}

Um die entsprechenden modifizierten Unifikationsregeln zu definieren,
benötigen wir eine Methode, die Umgebungsvariablen zweier Umgebungen zu
vergleichen. 
%die aufgrund der Sorte von Umgebungen immer ganz hinten stehen 
Wir definieren 

\begin{tabular}{rcl}
\emph{tail$(s)$} & = & $s$, wenn $s$ ein Term mit Wurzelsymbol
  ungleich $\setf{\cdot|\cdot}$ ist und \\
\emph{tail$(\setf{t|s})$} & = & \emph{tail$(s)$}.
\end{tabular}

\begin{definition}%[p-unifikationsregeln mod]
\label{def:p-unifikatiosregeln-mod}
Die modifizierten Unifikationsregeln, die Nichtterminierung
ausschließen für den Fall, dass zwei zu unifizierende Umgebungen
dieselbe Variable enthalten, sind folgendermaßen definiert.  

\fbox{
\begin{minipage}{0.98\textwidth}
$\begin{array}{l}
\multicolumn{1}{l}{\mathbf{U - Decomposition}} \\
\set{\setf{t|s} \ue \setf{t'|s'}} \uplus P \Rightarrow
                                                      \begin{array}[t]{rl} 
							 i)& \set{t \ue t', s \ue s'} \cup P  \\
							ii)& \set{s \ue \setf{t'|N}, \setf{t|N} \ue s'} \cup P \\
						      \end{array} \\
\quad \text{wenn \emph{tail$(s)$} und \emph{tail$(s')$} nicht dieselbe Variable $X$ der Sorte $U$ bezeichnen}.\\
\quad  N \; \text{ist eine neue Variable der Sorte} \; U. \\
\end{array}$

$\begin{array}{l}
\multicolumn{1}{l}{\mathbf{U - Decomposition*}} \\
\set{\setf{t|s} \ue \setf{t'|s'}} \uplus P \Rightarrow \set{\setf{t|\widehat{s}} \ue \setf{u|\widehat{s'}}} \cup P \\
\quad \text{wenn \emph{tail$(s)$}} = \emph{tail$(s')$ $= X:U$}. \\  
\quad  \;\widehat{s}, \widehat{s'} \; \text{sind gleich}\; s,s'\; \text{mit} \; \emph{tail}(s), \emph{tail}(s') \; 
   \text{durch} \; \emptyset \; \text{ersetzt}.\\
\end{array}$

$\begin{array}{l}
\multicolumn{1}{l}{\mathbf{U - Fail}} \\
\set{\setf{t|s} \ue \setf{t'|s'}} \uplus P \Rightarrow \bot \\
\quad \text{wenn \emph{tail$(s)$}} = \emph{tail$(s')$} = \emptyset  
 \; \text{und} \\
\quad s,s' \; \text{besitzen nicht} \; \text{die gleiche Anzahl von Elementen.} \\
\end{array}$
\end{minipage}}

\end{definition}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Terminierung}
\label{sec:terminierung}
Terminierung für den Unifikationsalgorithmus mit der \emph{U-Dec} 
Regel zu zeigen, wird erschwert durch die Einführung neuer Variablen
bei der Anwendung von \emph{U-Dec $ii)$}. Die Variablen werden
so eingeführt, dass sie nicht direkt eliminiert werden können, so wie
es beim Beweis der Terminierung ohne \emph{U-Dec} Transformation für
die Regeln \emph{Subsort} und \emph{Common Subsort} der Fall war 
(siehe Lemma \ref{lemma:terminierung-von-unify}). 
Ziel dieses Abschnittes ist es zu zeigen, dass der
Algorithmus mit der zusätzlichen Regel trotzdem für alle
\eletcln-Unifikationsprobleme terminiert. 
Die Überlegung dazu sieht folgendermaßen aus:
Jedem \eletcln-Unifikationsproblem wird ein Komplexitätsmaß
zugeordnet. Bei der Unifikation von zwei Umgebungstermen
vergrößert eine Anwendung von \emph{U-Dec $ii)$} dieses
Maß zunächst. Allerdings kann die Gleichung zwischen den 
Umgebungstermen durch eine Folge von
Transformationen komplett zerlegt werden, so dass sich das
Komplexitätsmaß am Ende dieser Zerlegung verkleinert hat. 
Komplette Zerlegung von Gleichungen zwischen Umgebungen definieren wir
folgendermaßen: 
\begin{definition}[Semi-gelöste Form]
\label{def:semi-geloeste-form}
Ein Unifikationsproblem
\[P=\set{X_1 \ue u_1, \dots X_m \ue u_m, s_1 \ue t_1, \dots s_n \ue t_n}\] 
ist in \emph{semi-gelöster Form}, gdw.\
\begin{itemize}
\item alle $X_i$ paarweise verschiedene Variablen, 
  der Sorte $U$ sind, die  nicht in $u_i$ und $t_j$ vorkommen. Und 
  %gelöster Form 
  %und $u_i$ Terme der Sorte $R \sqsubseteq U$ sind. Und
\item für alle Gleichungen $s_i \ue t_i$ gilt, dass die Wurzelsymbole
  von $s_i,t_i$ ungleich $\setf{\cdot|\cdot}$ sind. 
\end{itemize}
\end{definition}

Wenn ein Unifikationsproblem zwischen Umgebungen lösbar ist, dann
kann es in eine semi-gelöste Form transformiert werden. Bei dieser
Transformation werden i.A. neue Variablen der Sorte $U$ eingeführt,
die aber fast alle (d.h. entweder alle oder alle bis auf eine)
in gel\"oste Form\footnote{
  Ein Variable $x$ ist im Unifikationsproblem
  $P$ in \emph{gelöster Form}, gdw.\ $x$ in $P$ genau einmal in
  einer Gleichung $x = t$ vorkommt und $x \notin \Var(t)$.}
 gebracht werden k\"onnen, wie wir im Folgenden sehen werden. 

\begin{lemma}
\label{lemma:vollst.zerlegung.von.umg}
Sei $P = \set{\setf{s_1, \dots, s_m | S} \ue \setf{t_1, \dots t_n | T}}$
ein \eletcln-Unifikationsproblem
mit $U_{\mathpzc{E}^{let}_{Cl}}(P) \neq \emptyset$.  
$S$ und $T$ sind Terme deren Wurzelsymbol ungleich $\setf{\cdot|\cdot}$ ist. 

Dann kann $P$ durch eine endliche Folge von Transformationen in
eine semi-gelöste Form $S$ gebracht werden 
und für alle solche Transformationsfolgen gilt, dass $S$ 
%so dass für alle Transformationsfolgen $S$ 
von folgender Gestalt ist:
\[\set{s_{i_1} \ue t_{j_1}, \dots, s_{i_k} \ue t_{j_k}} \cup G \cup H\] mit 
$i_1, \dots, i_k \in \set{0,\dots, m}$,  
$j_1, \dots, j_k \in \set{0,\dots, n}$.
Die Menge $H$ ist leer oder enthält endlich viele Gleichungen 
$N_i \ue u_i$ in gelöster Form. 
%wobei $N_i$ paarweise verschiedene Variablen 
%mit Sort $U$.
$G$ ist eine endliche Menge von Unifikationsgleichungen, 
die von der Form von $S$ und $T$ abhängig sind:
\begin{enumerate}
\item $S$ und $T$ sind keine Variablen der Sorte $U$, 
%  (also Terme der Sorte $R \sqsubset U$ ungleich $\setf{\cdot|\cdot}$, 
%  oder Variablen des Sort $R \sqsubset U$)
  dann ist $G = \set{S \ue T}$ und es muss  
  $m=n$ gelten, da sonst $P$ keine Lösung besitzt. 
%\item Wenigstens einer der beiden Terme $S$ oder $T$ ist ein Variablenterm, 
%  dann gilt $Q = G \cup H$ wobei $H$ nur Gleichungen in
%  gelöster Form enthält {$E \ue u$, so dass in $u$ nur
%  eliminierte Variablen stehen; evtl. zur Def von semi-gelöst
%  hinzunehmen.} und 
%  die Unifikationsgleichungen in $G$ von einer der folgenden Formen sind:
%  \begin{enumerate}
  \item \sloppy $S$ und $T$ sind verschiedene Variablen der Sorte $U$, dann ist 
    $G = \set{S \ue \setf{t_{j_{k+1}}, \dots, t_{j_{n}}|N}, 
               T \ue \setf{s_{i_{k+1}}, \dots, s_{i_{m}}|N}}$
    mit $m,n \geq k$ und $N$ ist eine neue Variable der Sorte $U$.    
  \item $S:U$ ist Variable und $T:U$ ist Variable $(T \neq S)$\footnote{
    Für den Fall $T = S$ werden die beiden Variablen durch die
    Konstante $\emptyset$ ersetzt (\emph{U-Dec$*$}). Wir befinden uns
    dann in Fall 1.} 
    oder $T:U$ ist ein Term.
    %dessen Wurzelsymbol ungleich $\setf{\cdot|\cdot}$ ist. 
    Dann ist 
    $G =  \set{S \ue \setf{t_{j_{k+1}}, \dots, t_{j_{n}}|T}}$
    mit $n \geq k$.
    Falls $m=n$ gilt, ist auch noch der Fall $G = \set{S \ue T}$
    möglich. Oder
  \item $T:U$ ist Variable und $S:U$ ist Variable $(S \neq T)$ oder 
    $S:U$ ist ein Term.
    %mit Wurzelsymbol ungleich $\setf{\cdot|\cdot}$. 
    Dann ist $G =  \set{T \ue \setf{s_{i_{k+1}}, \dots, s_{i_{m}}|S}}$
    mit $m \geq k$. 
    Falls $m=n$ gilt ist auch noch der Fall $G = \set{T \ue S}$
    möglich. 
%  \end{enumerate}
\end{enumerate}
\end{lemma}
\begin{beweis}

Durch Induktion über die Anzahl der Variablen $m$ und $n$ mit
Fallunterscheidung über die Terme $S$ und $T$. Dabei müssen alle möglichen
Transformationen ausgehend von $P$ betrachtet werden, die $P$ in
semi-gelöste Form bringen. 

Wir gehen der Einfachheit halber davon aus, dass $S$
nicht in den $s_i$ und $T$ nicht in den $t_i$ vorkommt.\footnote{ 
Diese Annahme gilt, weil die Unifikationsprobleme, 
die zur Berechnung von \"Uberlappungen gel\"ost werden m\"ussen
eingeschr\"ankt sind. Siehe dazu Definition
\ref{def:eingschraenktes-unifikationsproblem} im Kapitel
\ref{cha:unif-von-kontexten} \"uber die Unifikation von Termen mit Kontextvariablen.}

\begin{description}
\item [$m = 1, n=1$:] $P = \set{\setf{s_1|S} \ue \setf{t_1|T}}$ kann
  transformiert werden zu 

  \begin{tabular}{rrll}
    $a)$ & \emph{U-Dec $i)$} $\Rightarrow$ & $\set{s_1 \ue t_1, S \ue T}$ & oder \\ \hline
    $b)$ & \emph{U-Dec $ii)$} $\Rightarrow$ & $\set{S \ue \setf{t_1|N}, \setf{s_1|N} \ue T}$. & \\ 
  \end{tabular}

Sind beide Terme $S$ und $T$ keine Variablen der Sorte $U$, dann ist $a)$ in
semi-gel\"oster Form (Fall 1) und $b)$ besitzt keine L\"osung. Der
gleiche Fall gilt, falls einer der beiden Terme keine Variable der
Sorte $U$ ist (nach eventueller Orientierung). 
Sind $S,T$ beides Variablen der Sorte $U$, dann sind die Probleme
$a)$ (Fall 3) und $b)$ (Fall 2) nach einem \emph{Orient}-Schritt für
$T$ in semi-gelöster Form. 

\end{description}
Um zu sehen, wie die Fälle 3 und 4 des Lemmas zustande kommen und wie
die Gleichungen in $H$ aussehen, betrachten wir den Fall:
\begin{description}
\item [$m = 1, n=2$:] $P = \set{\setf{s_1|S} \ue \setf{t_1,t_2|T}}$ kann
  transformiert werden zu 

  \begin{tabular}{rrll}
    $a)$ & \emph{U-Dec $i)$} $\Rightarrow$ & $\set{s_1 \ue t_1, S \ue \setf{t_2|T}}$ & oder \\ \hline
    $b)$ & \emph{U-Dec $ii)$} $\Rightarrow$ & $\set{S \ue \setf{t_1|N}, \setf{s_1|N} \ue \setf{t_2|T}}$. & \\ 
  \end{tabular}

Problem $a)$ ist in semi-gelöster Form, (Fall 3) wenn $S$
eine Variable mit Sorte $U$ ist. 
Problem $b)$ muss noch weiter transformiert werden. Folgende
Möglichkeiten bestehen:

  \begin{tabular}{rrll}
    $c)$ & \emph{U-Dec $i)$} $\Rightarrow$ & $\set{S \ue \setf{t_1|N}, s_1 \ue t_2, N \ue T}$ & oder \\ \hline
    $d)$ & \emph{U-Dec $ii)$} $\Rightarrow$ & $\set{S \ue \setf{t_1|N}, N \ue \setf{t_2|N_2}, \setf{s_1|N_2} \ue T}$. & \\ 
  \end{tabular}

Falls $S:U$ eine Variable ist, kann Problem $c)$  durch 
\emph{Variable Elimination} von $N$ in semi-gelöste Form (Fall 3)
gebracht werden. Die Gleichung $N \ue T$ ist in der Menge $H$.  
Das Unifikationsproblem $d)$ kann ebenfalls in semi-gelöste Form gebracht
werden, falls $S,T:U$ Variablen sind und \emph{Variable Elimination} auf
$N$ sowie \emph{Orient} auf $T$ angewendet wird:
$\set{S \ue \setf{t_1,t_2|N_2}, N \ue \setf{t_2|N_2}, T \ue \setf{s_1|N_2}}$  
(Fall 2). Die Gleichung $N \ue \setf{t_2|N_2}$ befindet sich in $H$. 

Ist $S$ keine Variable der Sorte $U$, oder $S$ und $T$ sind beides
keine Variablen der Sorte $U$, dann besitzt $P$ keine Lösung.  
\end{description}
Für $m=2, n=1$ haben wir $T \ue \setf{s_i|S}$ (Fall 4) anstelle von
$S \ue \setf{t_i|S}$, ansonsten ist der Fall analog. 
\begin{description}
\item [$m = 1, n \rightarrow n+1$], (Induktionsschritt für $n$).

Transformiere $P = \set{\setf{s_1|S} \ue \setf{t_1, \dots, t_{n+1}|T}}$ zu 

  \begin{tabular}{rrll}
    $a)$ & \emph{U-Dec $i)$} $\Rightarrow$ & $\set{s_1 \ue t_1, S \ue \setf{t_2, \dots, t_{n+1}|T}}$ & oder \\ \hline
    $b)$ & \emph{U-Dec $ii)$} $\Rightarrow$ & $\set{S \ue \setf{t_1|N}, \setf{s_1|N} \ue \setf{t_2, \dots, t_{n+1}|T}}$. & \\ 
  \end{tabular}

Wenn $S:U$ eine Variable ist, dann ist $a)$ in semi-gelöster Form (Fall 3), 
sonst besitzt $P$ keine Lösung. Die erste Gleichung von Problem $b)$ ist 
in semi-gelöster Form. Auf die zweite Gleichung ist die Induktionsannahme 
anwendbar, da die Umgebung $\setf{t_2, \dots t_{n+1}|N}$ nur noch $n$ 
Elemente besitzt. 
\end{description}
Der Induktionsschritt $m \rightarrow m+1$ verläuft analog. 
Folglich enden alle Transformationsfolgen, die ein Unifikationsproblem
zwischen Umgebungen in semi-gelöste Form bringen, mit einem
Problem, das einer der im Lemma angegebenen Formen entspricht. $\qed$
\end{beweis}

\begin{bemerkung}
\label{bem:trans-semi-regeln}
Eine Folge von Transformationen, die ein Unifikationsproblem in
semi-gelöste Form transformiert, besteht lediglich aus 
\emph{U-Dec}, \emph{U-Dec$*$}, \emph{Orientation} und 
\emph{Variable Elimination} Transformationen. 
Insbesondere werden keine anderen Transformationen angewendet, 
die neue Variablen einf\"uhren
(etwa \emph{Common Subsort} oder \emph{Weakening}). 
\end{bemerkung}

Wir halten eine wichtige Tatsache, die zum Beweis der Terminierung
notwendig ist, fest:
Entweder ist die Menge $H$ aus obigem Lemma 
(\ref{lemma:vollst.zerlegung.von.umg}) leer (wenn alle Elemente zweier zu
unifizierender Umgebungen untereinander unifiziert werden), oder alle
Gleichungen der Menge $H$ haben eine der folgenden Formen,
wobei $N_i,N:U$ jeweils paarweise verschiedene, neu eingeführte
Variablen sind: 
\begin{itemize}
\item $N_i \ue \setf{u_1, \dots, u_l}$
  mit $u_i \in \set{s_1, \dots, s_m, t_1, \dots, t_n}$ (Fall 1), 
\item $N_i \ue \setf{u_1, \dots u_l|N}$ mit 
  $u_i \in \set{s_1, \dots, s_m, t_1, \dots, t_n}$ (Fall 2), 
\item $N_i \ue \setf{t_{j_{k+1}}, \dots t_{j_{n}}|T}$ (Fall 3),
\item $N_i \ue \setf{s_{i_{k+1}}, \dots s_{i_{m}}|S}$ (Fall 4),
\item $N_i \ue X$ mit $X$ gleich $S$ oder $T$ (Fälle 2, 3, 4) oder gleich
  $N$ (Fall 2) oder gleich $\emptyset$ (Fall 1).
\end{itemize}

D.h. nach einer Folge von Transformationen eines Unifikationsproblems
in semi-gelöste Form, sind alle neuen 
Variablen bis auf $N$ in gelöster Form,
unabhängig davon, wie viele Variablen neu eingeführt wurden. 

\begin{korollar}%[#geloester var in semi-geloe form]
\label{kor:geloester-var-semi-geloe-form}
Wird ein Unifikationsproblem durch eine beliebige Folge von
Transformationen in semi-gelöste Form gebracht, dann enthält die
semi-gelöste Form maximal eine neue Variable, die nicht in gelöster
Form ist (Fall 2 aus Lemma \ref{lemma:vollst.zerlegung.von.umg},  
in den Fällen 1, 3 und 4 werden keine neuen, nicht gelösten Variablen
eingeführt).
\end{korollar}

\begin{figure}[p]
\newcommand{\twot}[2]{\ar[d]^{\txt{\scriptsize \emph{#1} \\ \scriptsize \emph{ #2}}}}
\newcommand{\threet}[3]{\ar[d]^{\txt{\scriptsize \emph{ #1} \\ \scriptsize \emph{ #2} \\ \scriptsize \emph{ #3}}}}
\newcommand{\elim}{{\bf{Elim}}}
\newcommand{\orient}{{\bf{Orient}}}
\[\xymatrix@C=0.45cm@R=0.9cm{
& 
*\txt{$\setf{s_2|S} \ue \setf{t_1|N}$\\$\setf{s_1|N} \ue \setf{t_2|T}$} \ar[dl]_{\bf{Dec \; i)}} \ar[dr]^{\bf{Dec \; ii)}} & 
& 
& 
\\
*\txt{$s_2 \ue t_1, S \ue N $\\$\setf{s_1|N} \ue \setf{t_2|T}$} \ar[d]_{\bf{Dec \; i})} \ar[dr]^{\bf{Dec \; ii)}} & 
&
*\txt{$S \ue \setf{t_1|N_2}$\\$\setf{s_2|N_2} \ue N$\\$\setf{s_1|N} \ue \setf{t_2|T}$} \ar[d]_{\bf{Dec \; i)}} \ar[dr]^{\bf{Dec \; ii)}} 
   %\ar@{->} `l`d[dddl]|>>>>>>>>>>>>{\mathbf{Orient \; N, \; Elim \; N}} & %`l `d
   \ar@/_/ `l`d[dddl]^>>>>>>>>>>>>{\orient \; N, \; \elim \; N} & 
&
\\ 
*\txt{$s_2 \ue t_1, S \ue N $\\$s_1 \ue t_2, N \ue T$} \ar[d]^{\elim \; N} & 
*\txt{$s_2 \ue t_1, S \ue N $\\$N \ue \setf{t_2|N_2}$\\$\setf{s_1|N_2} \ue T$} \twot{\elim \; N}{{\bf{Orient}} T} & 
*\txt{$S \ue \setf{t_1|N_2}$\\$\setf{s_2|N_2} \ue N$\\$s_1 \ue t_2, N \ue T$} \twot{{\bf{Orient}} N, \elim \; N}{{\bf{Orient}} T} & 
*\txt{$S \ue \setf{t_1|N_2}$\\$\setf{s_2|N_2} \ue N$\\$N \ue \setf{t_2|N_3}$\\ $\setf{s_1|N_3} \ue T$} \ar[d]^{\elim \; N} &
\\
*+[F]\txt{$s_2 \ue t_1, S \ue T $\\$s_1 \ue t_2, \underline{N \ue T}$} & 
*+[F]\txt{$s_2 \ue t_1$ \\ $S \ue \setf{t_2|N_2} $\\$\underline{N \ue \setf{t_2|N_2}}$\\$T \ue \setf{s_1|N_2}$} & 
*+[F]\txt{$S \ue \setf{t_1|N_2}$\\$\underline{N \ue \setf{s_2|N_2}}$\\$s_1 \ue t_2$ \\$T \ue \setf{s_2|N_2}$} &
*\txt{$S\ue \setf{t_1|N_2}$\\$\setf{s_2|N_2} \ue \setf{t_2|N_3}$\\$N \ue \setf{t_2|N_3}$\\$\setf{s_1|N_3} \ue T$} 
  \ar[dl]_{\bf{Dec \; i)}} \ar[d]^{\bf{Dec \; ii)}} &
\\
& 
*\txt{$S \ue \setf{t_1|N_2}$\\$N \ue \setf{s_2|N_2}$\\$\setf{s_1,s_2|N_2} \ue \setf{t_2|T}$}  \ar[dl]^{\bf{Dec \; i)}} \ar[d]^{\bf{Dec \; ii)}} &
*\txt{$S \ue \setf{t_1|N_2}$\\$s_2 \ue t_2, N_2 \ue N_3$\\$N \ue \setf{t_2|N_3}$\\$\setf{s_1|N_3} \ue T$} \twot{\elim \; $N_2$}{\orient T} &
*\txt{$S \ue \setf{t_1|N_2}$\\$N_2 \ue \setf{t_2|N_4}$\\$\setf{s_2|N_4} \ue N_3$\\$N \ue \setf{t_2|N_3}$\\ $\setf{s_1|N_3} \ue T$} 
  \ar[d]^{\txt{\scriptsize \bf{Orient $N_3$} \\ \scriptsize \elim \; $N_3$}}_{\txt{\scriptsize \bf{Elim $N_2$} \\ \scriptsize {\bf{Orient}} $T$}}
  %\threet{Elim $N_2$}{Orient,Elim $N_3$}{Orient T} & 
\\
*\txt{$S \ue \setf{t_1|N_2}$\\$N \ue \setf{s_2|N_2}$\\$s_1 \ue t_2$\\$\setf{s_2|N_2} \ue T$}  \ar@{-->} [uur]^{\orient \; T} &
*\txt{$S \ue \setf{t_1|N_2}$\\$N \ue \setf{s_2|N_2}$\\$\setf{s_2|N_2} \ue \setf{t_2|N_3}$\\$\setf{s_1|N_3} \ue T$} 
  \ar[d]^{\bf{Dec \; i)}} \ar[dr]|<<<<<<<{\bf{Dec\;ii)}} &
*+[F]\txt{$S \ue \setf{t_1|N_3}$\\$s_2 \ue t_2$\\$\underline{N_2 \ue N_3}$\\$\underline{N \ue \setf{t_2|N_3}}$\\$T \ue \setf{s_1|N_3}$} &
*+[F]\txt{$S \ue \setf{t_1,t_2|N_4}$\\ $\underline{N_2 \ue \setf{t_2|N_4}}$\\$\underline{N_3 \ue \setf{s_2|N_4}}$\\
  $\underline{N \ue \setf{t_2,s_2|N_4}}$\\ $T \ue \setf{s_1,s_2|N_4}$} & 
\\
%*\txt{$S \ue \setf{t_1|N_2}$\\$N \ue \setf{s_2|N_2}$\\$s_1 \ue t_2$\\$T \ue \setf{s_2|N_2}$} &
&
*\txt{$S \ue \setf{t_1|N_2}$\\$N \ue \setf{s_2|N_2}$\\$s_2 \ue t_2, N_2 \ue N_3$\\$\setf{s_1|N_3} \ue T$} 
  \ar@{-->}[ur]_>>>>>{\elim \; N_2, \; \orient \; T} &    
*\txt{$S \ue \setf{t_1|N_2}$\\$N \ue \setf{s_2|N_2}$\\$N_2 \ue \setf{t_2|N_4}$\\$\setf{s_2|N_4} \ue N_3$\\$\setf{s_1|N_3} \ue T$} 
  \ar@{-->}[ur]_{\txt{\scriptsize \emph{\orient $N_3$, \elim \; $N_3$} \\ \scriptsize \emph{\elim \; $N_2$}, \scriptsize \emph{\orient T}}} & 
&
\\}\]
\caption{Alle möglichen Transformationen von 
  %$\set{\setf{s_2|S} \ue \setf{t_1|N}, \setf{s_1|N} \ue \setf{t_2|T}}$
  $\setf{s_1, s_2|S} \ue \setf{t_1,t_2|T}$
  nach einem \emph{U-Dec $ii)$}-Schritt. 
  \label{fig:induktionsanfang}} 
\end{figure}

Betrachte zur Veranschaulichung der Gleichungen in der Menge $H$ auch

Beispiel \ref{bsp:unify-nicht-minimal} und
Abbildung \ref{fig:induktionsanfang}. Dort sind
alle Transformationsmöglichkeiten eines Unifikationsproblems 
$\setf{s_1,s_2|S} \ue \setf{t_1, t_2|T}$, f\"ur $S,T$ Variablen der
Sorte $U$, nach einem \emph{U-Dec $ii)$}-Schritt zu sehen (das
entspricht dem Fall $m=n=2$ aus Lemma
\ref{lemma:vollst.zerlegung.von.umg}). 
Wir gehen der Einfachheit halber davon aus, dass $S$
nicht in den $s_i$ und $T$ nicht in den $t_i$ vorkommt.
Die Gleichungen, die sich in $H$ befinden, sind in der Abbildung
unterstrichen.   

Um die Terminierung des Unifikationsalgorithmus mit der
\emph{U-Dec}-Regel zu zeigen, wird der Algorithmus \emph{Unify} aus
Abschnitt \ref{sec:uni-druch-transformation} 
folgendermaßen modifiziert:
Wende auf ein Unifikationsproblem $P$ eine beliebige
Transformationsregel aus Definition \ref{def:p-unifikatiosregeln-mod}
an. Ist die angewendete Unifikationsregel \emph{U-Dec}, die eine
Gleichung $e \in P$ zwischen Umgebungen transformiert, dann bringe das
Teilproblem $e$ in semi-gelöste Form. An dieser Stelle wird der
Nichtdeterminismus des ursprünglichen Algorithmus eingeschränkt,
indem alle Transformationen, die $e$ in semi-gelöste Form bringen,
vorgezogen werden. Der Grund für dieses Vorgehen liegt darin, dass
sich ein Unifikationsproblemen zugeordnetes Komplexitätsmaß nach
dieser Folge von Transformationen verringert (was im Beweis von Satz
\ref{satz:term-von-unify-p} gezeigt wird).  
Der modifizierte Unifikationsalgorithmus ist in Abbildung
\ref{fig:unify-permut} zu sehen. 

\begin{figure}[!htb]
\fbox{
\begin{minipage}{0.98\textwidth}
\begin{tabbing}
%\qquad\=\hspace{\lwidth}\=\hspace{\cwidth}\=\+\kill
${\Conid{\emph{Unify-Cl}}\;(\Conid{P})\mathrel{=}}$\\
${\hskip2.00em\relax\mathbf{if}\;\Varid{es}\;\Varid{gibt}\;\Varid{eine}\;\Conid{Gleichung}\;\Varid{e}\mathrel{=}(\Varid{s}\;\Varid{\ue}\Varid{t})
  \mathbf{\in}\;\Conid{P},}$\\
${\hskip2.00em\relax\phantom{\mathbf{if}\;\mbox{}}\Varid{so}\;\Varid{dass}\;\Varid{fuer}\;\Varid{die}\;\Conid{Anwendung}\;\Varid{einer}\;\Conid{Unifikationsregeln}\;\Varid{auf}\;\Varid{e}\;\Varid{gilt}\mathbin{:}\Conid{P}\Conid{\Rightarrow}\;\Conid{P'}}$\\
${\hskip2.00em\relax\mathbf{then}\;\mathbf{if}\;\Varid{s}\;\Varid{und}\;\Varid{t}\;\Varid{haben}\;\Varid{beide}\;\Varid{\setf{\cdot|\cdot}}
  \;\Varid{als}\;\Conid{Wurzelsymbol}}$\\
${\hskip2.00em\relax\phantom{\mathbf{then}\;\mbox{}}\mathbf{then}\;\Varid{transformiere}\;\Varid{e}\;\Varid{in}\;\Varid{semi}\text{-}\Varid{geloeste}\;\Conid{Form}\;\Varid{e'},}$\\
${\hskip2.00em\relax\phantom{\mathbf{then}\;\mbox{}}\phantom{\mathbf{then}\;\mbox{}}
  \Varid{werden}\;\Varid{dabei}\;\Conid{Variablen}\;\Varid{eliminiert},}$\\ 
  ${\hskip2.00em\relax\phantom{\mathbf{then}\;\mbox{}}\phantom{\mathbf{then}\;\mbox{}}
  \Varid{dann}\;\Varid{eliminiere}\;\Varid{diese}\;\Varid{aus}\;\Varid{e}\;\Varid{und}\;\Conid{P}-\Varid{\set{e}}.}$\\
${\hskip2.00em\relax\phantom{\mathbf{then}\;\mbox{}}\phantom{\mathbf{then}\;\mbox{}}
  \Conid{Anschliessend}\;\Varid{rufe}\;\Conid{\emph{Unify-Cl}}\;(\Varid{e'}\;\Varid{\cup}\;\Conid{P}-\Varid{\set{e})}\;\Varid{auf}}$\\
${\hskip2.00em\relax\phantom{\mathbf{then}\;\mbox{}}\mathbf{else}\;\Conid{\emph{Unify-Cl}}\;(\Conid{P'})}$\\
${\hskip2.00em\relax\mathbf{else}\;\mathbf{if}\;\Conid{P}\;\Varid{ist}\;\mathbf{in}\;\Varid{geloester}\;
  \Conid{Form}\;\mathbf{then}\;\mathbf{return}\; \Varid{\sigma_P}}$\\
${\hskip2.00em\relax\phantom{\mathbf{else}\;\mathbf{if}\;\Conid{P}\;\Varid{ist}\;\Varid{in}\;\Varid{geloester}\;\Conid{Form}\;
\mbox{}}\mathbf{else}\;\mathbf{return}\;\Conid{P}\;\Varid{ist}\;\Varid{nicht}\;\Varid{loesbar}}$
\end{tabbing}
\caption{\emph{Unify-Cl}\label{fig:unify-permut}}
\end{minipage}}
\end{figure}


\begin{satz}%[terminierung von Unify-P]
\label{satz:term-von-unify-p}
\emph{Unify-Cl} terminiert für alle \eletcln-Unifikationsprobleme $P$.
\end{satz}
\begin{beweis}
Einem Unifikationsproblem $P$ wird das Komplexitätsmaß $(n_1,n_2)$
zugeordnet, so dass 
\begin{itemize}
\item [$n_1$] die Anzahl der Variablen in $P$ ist, die nicht gelöst
  sind, und
\item [$n_2$] sei $p = max\set{|s| \;| \; s \ue t \in P}$. 
  Für $i = 0, \dots p$ sei $\eta(i)$ die Anzahl der nicht gelösten
  Gleichungen $s \ue t \in P$, so dass $|s| = i$. Dann ist $n_2$ die
  Liste $[\eta(p),\eta(p-1), \dots, \eta(0)]$. 
  
%\item [$n_2$] die Größe von $P$ ist: $\sum_{(s \ue t) \in P} (|s| +  |t|)$, und
%\item [$n_3$] die Anzahl der Gleichungen der Form $t = x$ in $P$ ist,
%  wobei $t$ keine Variable ist. 
\end{itemize}
Es wird folgende (fundierte) Ordnung auf Listen $l_1, l_2$ definiert:
\[\begin{array}{lcl}
l_1 <_{list} l_2 &, gdw.\ & length(l_1) < length (l_2) \; \text{oder} \\
& & length(l_1) = length (l_2) \; \text{und} \; head(l_1) < head(l_2) \; \text{oder} \\
& & length(l_1) = length (l_2), head(l_1) < head(l_2) \; \text{und} \; tail(l_1) < tail(l_2) \\
\end{array}\]
Jede Anwendung einer Unifikationsregel bis auf \emph{U-Dec $ii)$}
verkleinert das Tupel bezüglich der lexikographischen Ordnung auf
$(n_1,n_2)$: 
%\begin{longtable}{lcc}
\[\begin{array}{lcc}
                  &  n_1   &  n_2  \\ %\endhead 
\emph{Tautology}  &  \geq  &  >   \\
\emph{Orientation} &  \geq  &  >   \\
\emph{Decomposition} &  \geq  &  >   \\
\emph{Elimination} &  >  &    \\
\emph{Umg Decomposition i)} &  \geq  &  > \\
\emph{$Subsort^*$} &  >  &    \\
\emph{$Common Subsort^*$} &  >  &  \\
\end{array}\]
%\end{longtable}

Die Überlegungen hierzu sind analog zum Beweis  
der Terminierung von \emph{Unify} 
(Lemma \ref{lemma:terminierung-von-unify}).
Weil $\Sigma^{let}_{\setf{\cdot|\cdot}}$ eine einfache Signatur ist,
vernachlässigen wir wieder die \emph{Weakening}-Regel, die aber für
reguläre, elementare Signaturen so modifiziert werden kann, dass
eine Anwendung das Komplexitätsmaß verkleinert.
%Die Begr\"undung ist, dass wenn sich das im Beweis der Terminierung von
%\emph{Unify} definierte Komplexit\"atsma"s $(n_1,n_2,n_3)$ veringert,
%dann veringert sich auch $(n_1,n_2)$

%Betrachten wir nun die Regel \emph{Umg Decomposition $i)$}.
%\[\begin{array}{lccc}
%                  &  n_1   &  n_2  &  n_3 \\
%\emph{Umg Decomposition} \; i)  &  \geq  &  >  & \end{array}\]
%Eine Anwendunge von \emph{Umg Decomposition} $i)$ verkleinert
%möglicherweise die Anzahl der nicht gelösten Variablen $n_1$,
%vergrößert sie aber in keinem Fall. Die Größe des
%Unifikationsproblems $n_2$ wird verkleinert. 

Eine Anwendung der Regel \emph{U-Dec $ii)$} vergrößert
die Menge der nicht gelösten Variablen von $P$ zunächst um 1, da eine neue,
nicht direkt eliminierbare Variable eingeführt wird. 
Die Gleichung $e$, die zur Anwendung von \emph{U-Dec $ii)$} gef\"uhrt
hat, ist von der Form 
$e = \setf{s_1, \dots, s_m | S} \ue \setf{t_1, \dots t_n | T}$. 
Eine solche Gleichung wird durch \emph{Unify-Cl}
in semi-gelöste Form transformiert, deren Gestalt nach Lemma
\ref{lemma:vollst.zerlegung.von.umg} bekannt ist.
Sind $S,T$ keine Variablen der Sorte $U$, dann sind wir in Fall 1 des Lemmas. 
Nach Korollar \ref{kor:geloester-var-semi-geloe-form} sind alle  
neu eingeführten Variablen in gelöster Form, d.h. $n_1$ 
hat sich nicht vergrößert. 
Die Anzahl der Gleichungen des Unifikationsproblems kann angewachsen sein, 
da neue Gleichungen (in die Menge $H$) eingeführt werden
können. Allerdings werden die beiden Umgebungsterme
der Unifikationsgleichung $e$ komplett zerlegt.
%weil $S$ und $T$ keine Variablen sind. 
Durch diese Transformation in
semi-gelöste Form verkleinert sich $n_2$. 
Diese Überlegung gilt auch, wenn $S$ und $T$ Umgebungsvariablen sind
mit $S =T$, da dann beide Variablen durch die Konstante $\emptyset$
ersetzt werden (durch die Regel \emph{U-Dec$*$}) und das resultierende
Unifikationsproblem in semi-gelöste Form transformiert wird.  

Wenn $S \neq T$ beides Variablen sind, dann wird $e$ zu einer
semi-gelösten Form der Gestalt aus Fall 2 (bzw. 3 oder 4, siehe unten) 
des Lemmas \ref{lemma:vollst.zerlegung.von.umg} transformiert. Nach
Korollar \ref{kor:geloester-var-semi-geloe-form} wurde 
eine neue Variable eingeführt, die nicht in gelöster Form ist. 
Die beiden Variablen $S,T$ sind aus $P$ eliminierbar. Nach diesen
beiden \emph{Variable Elimination}-Schritten verringert sich die Anzahl
der nicht gelösten Variablen $n_1$ um 1.

Ist mindestens einer der beiden Terme $S$ oder $T$ eine Variable
der Sorte U, dann
endet die Transformation mit einem Unifikationsproblem, dessen Gestalt
Fall 3 oder 4 aus Lemma \ref{lemma:vollst.zerlegung.von.umg}
entspricht.   
Alle neuen Variablen sind in gelöster Form (nach Korollar
\ref{kor:geloester-var-semi-geloe-form}). Eine der beiden Variablen
$S$ oder $T$ ist aus $P$ eliminierbar, wodurch $n_1$ um 1 verkleinert wird.  
%Jetzt ist \emph{Variable Elimination} anwendbar, wodurch die Anzahl 
%der nicht gelösten Variablen $n_1$ um 1 veringert wird, da entweder 
%$S$ und $T$ eliminierbar sind und eine neue Variable $N$, die nicht in
%gelöster Form ist, eingeführt wurde, oder keine neue, nicht
%eliminerbare Variable eingeführt wurde und $S$ oder $T$
%eliminierbar sind.
D.h. nach einer beliebigen Folge von
Transformationen einer Gleichung zwischen Umgebungen in semi-gelöste
Form und anschließender \emph{Variable Elimination} (die unter
Umständen zweimal durchgeführt werden muss), verringert sich das
Komplexitätsmaß: 

\[\begin{array}{lccclr}
&  n_1   &  n_2  &  n_3 \\
\emph{U-Dec}\; ii) &  \geq &  >  & & \text{Fall 1 aus Lemma \ref{lemma:vollst.zerlegung.von.umg}, oder}  \\
\emph{U-Dec}\; ii) &  >  & & &  \text{F\"alle 2,3 oder 4 aus Lemma \ref{lemma:vollst.zerlegung.von.umg}.} & \hfill \qed\\
\end{array}\]
\end{beweis}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Vollständigkeit}
\label{sec:vollstaendigkeit}
Die Vollständigkeit aller verwendeten Unifikationsregeln, außer
\emph{U-Dec} wurde bereits gezeigt (Lemma \ref{lem.vollst.sorted.unifikation}).
Bei der \emph{U-Dec}-Regel handelt es sich offensichtlich nicht um
eine vollständige Transformationsregel. Der Vollständigkeitsbeweis
muss deshalb zeigen, dass \emph{Unify-Cl} eine vollständige
Unifikationsprozedur in dem Sinne ist, dass für alle 
\eletcln-Unifikationsprobleme und für
alle $\tau \in U_{\mathpzc{E}^{let}_{Cl}}(P)$ ein
Unifikationsproblem $S$ in gelöster Form existiert, so dass $P$
zu $S$ transformierbar ist und 
$\sigma_{S} \lesssim_{\mathpzc{E}^{let}_{Cl}} \tau$ gilt. 
Hierbei kann man sich, wegen der Vorgehensweise des
Unifikationsalgorithmus und der bereits gezeigten Vollständigkeit der
anderen Unifikationsregeln, auf die Transformationsfolgen von
Teilproblemen der Art $\setf{\cdot|\cdot} \ue \setf{\cdot|\cdot}$ in
semi-gelöste Form beschränken. Unter Verwendung von Lemma
\ref{lemma:vollst.zerlegung.von.umg} kann für diese Transformationsfolgen
%von Unifikationsproblemen zwischen Umgebungen 
gezeigt werden, dass sie
korrekte (Folgen von) Transformationen sind. 
Betrachtet man dann den vollständigen Baum aller
nichtdeterministischen Verzweigungen der Transformationen
(siehe Definition \ref{def:CU-Dec})
%(wieder unter Zuhilfenahme von Lemma \ref{lemma:vollst.zerlegung.von.umg}) 
und verwendet die Terminierung
des Unifikationsalgorithmus, kann die Vollständigkeit von
\emph{Unify-Cl} gezeigt werden. Dieses Vorgehen ist allerdings technisch etwas
aufwendig. Aus diesem Grund vollziehen wir eine Überlegung aus
\citeA{dovier_uniform_1998} nach, die die Vollständigkeit auf eine andere
Art zeigt. 

Dazu lösen wir uns etwas von der durch Termersetzung geprägten
Sichtweise auf Identitäten, die wir bisher als
Ersetzungsregeln verstanden haben, die es erlauben, in Termen Instanzen
einer Seite durch die entsprechende Instanz der anderen Seite zu
ersetzen. Wir betrachten das $Cl$-Axiom als Formel der Logik erster
Stufe, die Vertauschbarkeit von Elementen einer Multimenge
(d.h. Umgebung)  
% über deren Gleichheit 
axiomatisiert: 
\[\begin{array}{rcl}
Cl & := & \forall x, y, z: \; \setf{x|\setf{y|z}} = \setf{y|\setf{x|z}}.\end{array}\]

Ein anderes Axiom, das ebenfalls Gleichheit von Multimengen unter
der Eigenschaft der 
Vertauschbarkeit von Elementen axiomatisiert, ist durch 
die Formel:
\[\begin{array}{rcll}
K & := & \forall y_1, y_2, v_1, v_2: & \setf{y_1|v_1} = \setf{y_2|v_2} \Leftrightarrow \\
  & & & (y_1 = y_1 \wedge v_1 = v_2) \; \vee \\
  & & & \exists z: (v_1 = \setf{y_2|z} \wedge v_2 = \setf{y_1|z}). \\
\end{array}\]
gegeben.

Die beiden Axiome stehen in folgendem Verhältnis zueinander: 
\begin{proposition}
\label{prop:aequiv.p.k}
Die Axiome $K$ und $Cl$ sind äquivalent.
\end{proposition}
\begin{beweis}
$K \Rightarrow Cl$: Seien $\setf{x,y|z}$ und $\setf{y,x|z}$ gegeben mit 
$x \neq y$ (da für $x = y$ die Gleichheit offensichtlich ist). 
Nach $K$ gilt $\setf{x,y|z} = \setf{y,x|z}$, gdw.\ es ein $k$ gibt, so dass 
$\setf{y|z} = \setf{y|k}$ und $\setf{x|z} = \setf{x|k}$. Wähle $k$
gleich $z$ und wir haben $\setf{x,y|z} = \setf{y,x|z}$. 

$Cl \Rightarrow K$: Seien ebenfalls $\setf{x,y|z}$ und $\setf{y,x|z}$
gegeben mit $x \neq y$. Nach $Cl$ haben wir 
$\setf{x,y|z} = \setf{y,x|z}$, d.h. 
$\setf{y|z} = \setf{y|k}$ und $\setf{x|z} = \setf{x|k}$ gilt für 
$k = z$. $\qed$
\end{beweis}

\begin{satz}%[vollst unify]
\label{satz:vollst-unify-p}
\emph{Unify-Cl} ist eine vollständige Unifikationsprozedur für
\eletcl-{Uni\-fi\-ka\-ti\-ons\-pro\-bleme}.
\end{satz}
\begin{beweis}
Alle Unifikationsregeln außer \emph{U-Dec} und \emph{U-Dec$*$} 
sind vollständige Transformationen für \eletcl-Unifikationsprobleme, 
%weil $\Sigma^{let}_{\setf{\cdot|\cdot}}$ eine regul\"are
wie in Lemma \ref{lem.vollst.sorted.unifikation} %\ref{sortedlem.vollst.sorted.unifikation} 
des vorhergehenden Kapitels gezeigt wurde. 
Die \emph{U-Dec$*$}-Regel ist eine vollständige Unifikationsregel, 
weil eine Unifikationsgleichung 
$\setf{s_1, \dots, s_m|X} \ue \setf{t_1, \dots, t_n|X}$ eine Lösung besitzt 
gdw. $\setf{s_1, \dots, s_m} \ue \setf{t_1, \dots, t_n}$ eine Lösung
besitzt. Eine Gleichung $\setf{s_1, \dots, s_m} \ue \setf{t_1, \dots, t_n}$
besitzt keine Lösung, wenn $n \neq m$ gilt, d.h. \emph{U-Fail} ist
eine vollständige Unifikationsregel. 
Die Vollständigkeit von \emph{Unify-Cl} folgt aus
Proposition \ref{prop:aequiv.p.k} und der strikten Analogie der
\emph{U-Dec}-Regel zu Axiom $K$. $\qed$
\end{beweis}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Unifikationstyp, Berechnung einer vollständigen Menge von Unifikatoren und Komplexität}
\label{sec:unifikationstyp-berechnung-vollst-komplexitaet}
\begin{satz}
Die Gleichungstheorie \eletcl besitzt den Unifikationstyp endlich. 
\end{satz}
\begin{beweis}
%Die Gleichungstheorie \eletcl ist congruence closed (Proposition
%\ref{prop:congruence-closedness-ac-p}) und sort preserving
%(Proposition \ref{prop:sort-preservation-ac-p}), die Berechnung einer
%vollständigen Menge von \eletcl-Unifikatoren kann deshalb in zwei
%unabhängigen Schritten vor sich gehen: Zuerst berchen ein .  
Der Algorithmus \emph{Unify-Cl} zur Lösung von
\eletcl-Unifikationsproblemen terminiert 
(Satz \ref{satz:term-von-unify-p}) und ist vollständig (Satz
\ref{satz:vollst-unify-p}). Außerdem besitzt der Baum der
nichtdeterministischen Verzweigungsmöglichkeiten 
der Transformationen %sfolgen 
einen endlichen Verzweigungsgrad (auf jedes
endliche \eletcl-Unifikationsproblem sind nur endlich viele
Transformationen anwendbar).  
Damit folgt, dass \eletcl den Unifikationstyp endlich besitzt. $\qed$
\end{beweis}

Die Berechnung aller Überlappungen zwischen
$\Sigma^{let}_{\setf{\cdot|\cdot}}$-Termen ist also mit 
\emph{Unify-Cl} {mög\-lich}. 
%für $\Sigma^{let}$-Terme mit dem links-kommutativen Funktionssymbol %$\setf{\cdot|\cdot}$ 
Der Algorithmus \emph{Unify-Cl} berechnet nichtdeterministisch einen
Unifikator für ein Unifikationsproblem aus der vollständigen Menge
der Unifikatoren.\footnote{Die Überlegungen hierzu sind analog zu
  denen in Abschnitt \ref{sec:uni-druch-transformation}: 
  \emph{Unify-Cl} transformiert ein 
  Unifikationsproblem in gelöste Form, die einen idempotenten
  Unifikator aus der Menge der vollständigen Unifikatoren
  repräsentiert.} 
Um die komplette vollständige Menge von Unifikatoren
zu berechnen, betrachten wir die vollständige Menge von Alternativen
von Transformationen (Definition \ref{def:complete-transformation}).
Für ein $\mathpzc{E}$-Unifikationsproblem 
$P$ wird  $CU_{\mathpzc{E}}(P)$ berechnet, indem alle
Transformationsmöglichkeiten 
$P \Rightarrow P_1 \dots P \Rightarrow P_n$ betrachtet werden, so dass 
$CU_{\mathpzc{E}}(P) = CU_{\mathpzc{E}}(P)|_{Var(P)} \cup \dots \cup CU_{\mathpzc{E}}(P)|_{Var(P)}$ 
gilt. D.h. der Baum aller nichtdeterministischen
Verzweigungsmöglichkeiten von Transformationen %sfolgen 
wird berechnet. Dazu ist es in \eletcl ausreichend, anstatt der nichtdeterministischen
Wahl einer Transformation bei der Anwendung von \emph{U-Dec}, beide
Transformationen $i)$ und $ii)$ anzuwenden. Anschließend werden beide
resultierenden Unifikationsprobleme rekursive weiter 
transformiert. D.h. für ein Teilproblem $\setf{\cdot|\cdot} \ue
\setf{\cdot|\cdot}$ werden alle möglichen semi-gelösten Formen
berechnet, was durch folgende Modifikation der \emph{U-Dec} Regel
geschehen kann: 

\begin{definition}
\label{def:CU-Dec}
Zur Berechnung einer vollständigen Menge von Unifikatoren eines
\eletcln-{Uni\-fi\-ka\-ti\-ons\-pro\-blems} wird die
\emph{U-Decompositon}-Regel aus Definition
\ref{def:p-unifikatiosregeln-mod} durch folgende Regel ersetzt:

\fbox{
\begin{minipage}{0.98\textwidth}
\[\begin{array}{l}
\multicolumn{1}{l}{\mathbf{CU - Decomposition}} \\
\set{\setf{t|s} \ue \setf{t'|s'}} \uplus P \Rightarrow
                                                      \begin{array}[t]{rl} 
							 & \set{\set{t \ue t', s \ue s'} \cup P} \; \cup  \\
							 & \set{\set{s \ue \setf{t'|N}, \setf{t|N} \ue s'} \cup P} \\
						      \end{array} \\
\quad \text{wenn \emph{tail$(s)$} und \emph{tail$(s')$} nicht dieselbe Variable $X$ der Sorte $U$ bezeichne}.\\
\quad N \; \text{ist eine neue Variable der Sorte} \; U.\\
\end{array}\]
\end{minipage}}
\end{definition}

Der Algorithmus mit dieser modifizierten Regel berechnet eine
vollständige Menge von Unifikatoren für ein Unifikationsproblem,
allerdings nicht die minimale vollständige Menge von Unifikatoren,
wie an folgendem Beispiel zu sehen ist:

\begin{beispiel}
\label{bsp:unify-nicht-minimal}
Sei $P = \set{\setf{x,x|S} \ue \setf{x|T}}$ ein 
\eletcln-Unifikationsproblem. 
\begin{longtable}{rlr}
& $\set{\setf{x,x|S} \ue \setf{x|T}}$ & $= P$\\ \hline
$\xrightarrow{\emph{U-Dec-C}}$ & $\set{\set{x \ue x, \setf{x|S} \ue T},$ & \\
& \phantom{\{}$\set{\setf{x|S} \ue \setf{x|N_1}, \setf{x|N_1} \ue T}} $ & \\ \hline
$\xrightarrow{\emph{Taut}}$ & $\set{\set{\setf{x|S} \ue T},$ & \\
$\xrightarrow{\emph{U-Dec-C}}$ & \phantom{\{}$\set{x \ue x, S \ue N_1, \setf{x|N_1} \ue T}$ & \\ 
& \phantom{\{}$\set{S \ue \setf{x|N_2}, \setf{x|N_2} \ue N_1, \setf{x|N_1} \ue T}}$ & \\ \hline
$\xrightarrow{\emph{Orient}}$ & $\set{\set{T \ue \setf{x|S}},$ & $=S_1$\\
$\xrightarrow{\emph{Taut, Orient}\; \times 2, \;\emph{Elim}\; N_1}$ & \phantom{\{}$\set{N_1 \ue S, T \ue \setf{x|S}}$ & $=S_2$\\ 
$\xrightarrow{\emph{Orient} \; \times 2, \;\emph{Elim}\; N_1}$ & \phantom{\{}$\set{S \ue \setf{x|N_2}, N_1 \ue \setf{x|N_2}, T \ue \setf{x,x|N_2}}}$ & $=S_3$ \\
\end{longtable}

Das Unifikationsproblem $P$ besitzt einen mgu, der zweimal berechnet wird:
$\sigma_{S_1} =_{\mathpzc{E}^{let}_{Cl}} \sigma_{S_2} [\set{S,T}]$. Für den dritten
berechneten Unifikator gilt 
$\sigma_{S_3} =_{\mathpzc{E}^{let}_{Cl}} \sigma_{S_3}\sigma_{S_1}$.
%, d.h. 
%$\sigma_{S_1} \lesssim_{\mathpzc{E}^{let}_{Cl}} \sigma_{S_3}$. 
\end{beispiel}

Dass die berechnete vollständig Menge der
Unifikatoren nicht minimal ist, stellt für die Berechnung aller
Überlappungen zwischen Termen kein Problem dar.  
Wichtig ist nur, dass alle möglichen (kritischen) Überlappungen
berechnet werden. 
%Ein Unifikator, der durch Instantiierung aus einem
%anderen Unifikator der vollständigen Menge gewonnen werden kann,
%führen zur selben überlappung 
Außerdem werden die zu überlappenden Terme umbenannt und sind
deswegen variablendisjunkt. Deshalb kann ein Fall, wie in Beispiel
\ref{bsp:unify-nicht-minimal}, bei der Berechnung von Überlappungen
nicht auftreten. 
\citeA{arenas-sanchez_minimality_1997} und
\citeA{stolzenburg_algorithm_1999} geben eine Reihe von Verbesserungen
des Algorithmus an, um die Anzahl der redundanten Unifikatoren
möglichst gering zu halten. 

Unifikation von Multimengen ist, ebenso wie Unifikation von
$AC$-Funktionssymbolen, NP-vollständig  
\cite{kapur_np-completeness_1986,dovier_uniform_1998,kapur_complexity_1992} 
und die Anzahl der Unifikatoren kann exponentiell in der Größe der Eingabe
sein \cite{kapur_double-exponential_1992}.
Des Weiteren kopiert \emph{Unify-Cl} Terme bei der Elimination von
Variablen. Dieses Verhalten kann allerdings verbessert werden durch
die Verwendung  von Datenstrukturen, die das Kopieren
von Termen während der Unifikation vermeiden, wie 
Multimengen von Unifikationsgleichungen 
(\citeNP{martelli_efficient_1982}, siehe auch Abschnitt \ref{sec:effizienz-der-unif}) 
oder die Darstellung von Termen als DAG
\cite{corbin_rehabilitation_1983}.  

Bei der Berechnung von Überlappungen für $\Lambda^{let}$
Reduktionsregeln haben wir es nur mit Umgebungen zu tun, die nicht mehr
als drei Elemente enthalten (wenn Ketten nicht berücksichtigt werden).
Aufgrund dieser geringen Eingabegrößen 
ist die exponentielle Laufzeit und die exponentielle Anzahl von
Unifikatoren (im worst-case) für die Berechnung dieser spezifischen
Überlappungen vernachlässigbar. 

\chapter{Unifikation von Termen mit Variablenketten}
\label{cha:unif-von-ketten}
Es gibt zwei Arten von Ketten von \letr-Bindungen in
$\Lambda^{let}$. Die so genannten \emph{Variablenketten} 
$\set{x_i = x_{i-1}}^n_{i=m}$in den (\emph{cp})-Reduktionsregeln und
die Ketten $\set{x_i=R^-_i[x_{i-1}]}^n_{i=m}$, die in
Reduktionskontexten auftauchen, die so genannten \emph{Reduktionsketten}. Die
Möglichkeiten, diese Ketten bei der Unifikation zu berücksichtigen
sind:
\begin{enumerate}
\item Für einen zu unifizierenden Ausdruck, der eine Kette enthält,
  werden Terme mit Variablenketten verschiedener Länge instantiiert. 
  Beispielsweise kann der Ausdruck 
  $\letrecm{x_1=v,\set{x_i=x_{i-1}}^n_{i=2}Env}{C[x_n]}$ übersetzt
  werden zu: 
  \begin{itemize}
  \item $letrec(\setf{b(x_1,v)\footnote{Wir verwenden, wie bisher
      üblich, für das Funktionssymbol $bind$ die Abkürzung $b$.}|e},C(x_1))$
    (Variablenkette der Länge 0),  
  \item $letrec(\setf{b(x_1,v),b(x_2,x_1)|e},C(x_2))$ (Variablenkette
    der Länge 1), 
  \item $letrec(\setf{b(x_1,v),b(x_2,x_1),b(x_3,x_2)|e},C(x_3))$
    (Variablenkette der Länge 2),  
  \item ...
  \end{itemize} 
Aus diesem Vorgehen ergibt sich das Problem, dass Ketten
variabler Länge so nicht unifizierbar sind. Es kann nur eine
begrenzte Anzahl Instanzen von Reduktionsregeln mit Ketten unterschiedlicher
Länge auf Unifizierbarkeit getestet werden. Die Unifikationsprozedur
ist somit nicht vollständig. 
Außerdem wächst die Laufzeit der Unifikation wegen der
NP-Vollständigkeit der $Cl$-Unifikation mit zunehmender Länge der
Ketten exponentiell. 
\item Die zweite Möglichkeit besteht darin, ein Konstrukt einzuführen, das
  Variablenketten beliebiger Länge darstellen kann. 
\end{enumerate}
Für Variablenketten in $\sigmaLet$ betrachten wir die zweite Alternative. 
Für Reduktionsketten wird die erste Möglichkeit gewählt. 

In diesem Kapitel wird die Methode vorgestellt, um Terme zu
unifizieren, die Variablenketten beliebiger Länge enthalten. 
Dazu erweitern wir in Abschnitt \ref{sec:ketten-in-sigmaLet} die
Signatur $\sigmaLet$ um ein Funktionssymbol $ch$, mit den Variablenketten
dargestellt werden können. Für dieses Funktionssymbol werden drei
Axiome definiert, durch die sich wesentliche Eigenschaften von
Variablenketten beschreiben lassen: Einzelne Bindungen aus k\"onnen
Variablenketten abgespalten und separat unifiziert werden.  
Der Theoretische Rahmen dieses Kapitels ist, wie im vorhergehenden
Kapitel, die Theorie der Gleichungsunifikation. 

In Abschnitt \ref{sec:ketten-in-sigmaLet} wird zuerst eine vollständige
Unifikationsprozedur für Terme mit Variablenketten skizziert, die
allerdings nur zu rekursiven Aufzählung von Unifikatoren verwendet
werden kann. Über ihre Terminierung kann keine Aussage getroffen
werden. 
In den folgenden Unterabschnitten stellen wir Überlegungen an, wie sich
die Anwendung der Axiome, die für Variablenketten gelten,
beschränken lassen, um die Terminierung der Unifikationsprozedur
sicherzustellen. Dazu werden die entsprechenden Unifikationsregeln
entwickelt. 

\section{Variablenketten in $\sigmaLet$}
\label{sec:ketten-in-sigmaLet}
\begin{definition}
\label{def:sigmaLet-ketten}
Die Signatur $\sigmaLet$ wird um ein Konstrukt zur
Darstellung von Variablenketten beliebiger Länge erweitert. Dazu wird eine neue
Sorte $K$ für Variablenketten eingeführt und eine neue Sorte $M$,
die es ermöglicht, Ketten als Bestandteile der \letr-Umgebung
$\setf{\cdot|\cdot}$ darzustellen. 
Wir notieren nur die relevanten neuen Bestandteile der Signatur. 

\newcommand{\fktsort}[3]{#1 \rightarrow #2 \rightarrow #3}
\[\begin{array}{rllrl}
\sigmaLet = \set{ 
& \multicolumn{2}{l}{\mathbf{Subsortdeklarationen:}} \\
& B,K \sqsubset M \sqsubset U, & \\
%& A, V, \sqsubset T, \\ %\; B \sqsubset U& \\
%& Ab, Ap, V, L \sqsubset T, & \\
%& Ap, L \sqsubset ST \sqsubset T, & \\
%& Ap, L \sqsubset RT \sqsubset ST, & \\
%& Ap \sqsubset RWT \sqsubset RT, & \\
%& B \sqsubset U, & \\
%& B \sqsubset U,  & \\
& \multicolumn{2}{l}{\mathbf{Funktionsdeklarationen:}} \\
%&  abs : \fktsort{V}{T}{Ab} & \mathsf{(Abstraktion)}, \\
%&  app : \fktsort{T}{T}{Ap} & \mathsf{(Applikation)}, \\
%&  letrec : \fktsort{U}{T}{L} & \mathsf{(\letr)}, \\
&  ch : \fktsort{B}{B}{K} & \mathsf{(Variablenkette)}, \\
&  \setf{\cdot|\cdot} : \fktsort{M}{U}{U} & \mathsf{(\letr-Umgebung)}. & } \\
%&  bind : \fktsort{V}{T}{B} & \mathsf{(\letr-Bindung)},  \\
%&  \emptyset : U & \mathsf{(leere \; \letr-Umgebung)} & } \\
%%&  kette : \fktsort{B}{B}{U} & \mathsf{(Kette \; von \; Bindugen)} \\
\end{array}\]
\sloppy
Eine Variablenkette in $\sigmaLet$ ist durch ihre Anfangs- und
Endbindung definiert. Variablenketten enthalten per Konvention
nur \letr-Bindungen, die ausschließlich Variablen der Sorte $V$
enthalten. So stellt beispielsweise $ch(b(x_2,x_1),b(x_n,x_{n-1}))$
eine Variablenkette in $\sigmaLet$ dar, wenn $x_1,x_2,x_{n-1}$ und
$x_n$ Variablen der Sorte $V$ sind. $ch(b(x_1,s_T),b(x_n,x_{n-1}))$
ist keine Variablenkette, da $s$ eine Variable der Sorte $T$ ist. 
Variablenketten werden folgendermaßen durch $\transl{\;}:
\Lambda^{let} \rightarrow \sigmaLet$ von
$\Lambda^{let}$ nach $\sigmaLet$ übersetzt:
\[\begin{array}{rcl}
\transl{\set{\set{x_i=x_{i-1}}^n_{i=m},x_1=s_1, \dots }} & = & \setf{\transl{\set{x_i=x_{i-1}}^n_{i=m}}|\transl{\set{x_1=s_1, \dots }}} \\
\transl{\set{x_i=x_{i-1}}^n_{i=m}}  & = & ch(b(\transl{x_m},\transl{x_{m-1}}),b(\transl{x_n},\transl{x_{n-1}})\\
%\transl{\lambda x.s} & = & abs(\transl{x},\transl{s}) \\
\end{array}\]

Das Verhalten von Variablenketten, dass einzelne Bindungen separat
betrachtet (bzw. unifiziert) werden können, lässt sich durch
folgende Identitäten beschreiben:
\[\begin{array}{lllll}
E_{Split} = & \set{ & \\
\multicolumn{3}{l}{\setf{ch(b(x_V,y_V),b_B)|e_U} \approx \setf{b(x_V,y_V)|\setf{ch(b(z_V,x_V),b_B)|e_U}}} & \mathsf{Split\;A},\\
\multicolumn{3}{l}{\setf{ch(b_B,b(x_V,y_V))|e_U} \approx \setf{ch(b_B,b(y_V,z_V))|\setf{b(x_V,y_V)|e_U}}} & \mathsf{Split\;E}, \\
\multicolumn{3}{l}{\setf{ch(b_B,d_B)|e_U} \approx \setf{(ch(b_B,b(w_V,x_V))|\setf{b(y_V,w_V))|\setf{ch(b(z_V,y_V),d_B)|e_U}}}}& \mathsf{Split\;M}. \\
} &  & & \\
\end{array}\]
\end{definition}

Eine Definition der Split-Axiome in der Form  
\begin{equation} 
\label{eqq1}
  ch(b(x_V,y_V),b_B) \approx \setf{b(x_V,y_V)|ch(b(z_V,x_V),b_B)} 
\end{equation} 
scheint natürlicher als die oben gewählte, bei der die Ketten in
\letr-Umgebungen stehen müssen, um aufgespalten zu werden. 
Allerdings ist die Axiom-Variante (\ref{eqq1}) nicht sort preserving
(Definition \ref{def:sort-preserving-congruence-closed})
und eine Anwendung kann dazu führen, dass das $Cl$-Axiom 
nicht mehr anwendbar ist. 
Diese beiden Probleme werden durch die gewählte Definition
vermieden. 
Für alle Terme mit Variablenketten, die zur Berechnung von
Überlappungen betrachtet werden müssen, gilt, dass die
Variablenketten in \letr-Umgebungen vorkommen, d.h. die Split-Axiome
anwendbar sind. Außerdem haben alle Variablenketten in diesen Termen
die Form $ch(b(x_m,x_{m-1}),b(x_n,x_{n-1}))$.
%(das Variablenketten-Funktionssymbol wird zwei Bindungs-Funktionsymbole 

Die drei Split-Axiome erlauben das Abspalten einer Bindung vom Anfang
einer Variablenkette (\emph{Split A}), vom Ende einer Variablenkette
(\emph{Split E}) oder aus der Mitte einer Kette (\emph{Split M}). 
Eine Berücksichtigung dieser drei Positionen ist ausreichend:
Betrachtet man die linken Seiten der
$cp$-Reduktionsregeln, in denen 
Variablenketten vorkommen, dann sieht man, dass Variablen der
Anfangsbindung einer Kette noch einmal in der linken Seite der jeweiligen 
Reduktionsregel vorkommen.
Beispielsweise $\letrecm{\xkette{v},Env}{C[x_n]}$, wobei $x_2 = x_1$
die Anfangsbindung der Kette ist und $x_1$ noch einmal in $x_1 = v$ vorkommt. 
Ebenso kommt eine Variable aus der Endbindung der Kette noch einmal in
der linken Seite der Reduktionsregel vor. Sonstige Variablen der Kette
tauchen in der linken Seite der Reduktionsregel nicht mehr auf. 
Eine Variablenkette komplett in ihre konstituierenden Bindungen
zu zerlegen, ist nicht möglich, da Ketten beliebiger Länge
betrachtet werden sollen. Deshalb werden durch die drei Split-Axiome die
beiden Bindungen einer Kette bei der Unifikation berücksichtigt, die
Variablen enthalten, die an anderer Stelle in der linken Seite der
Reduktionsregel noch einmal vorkommen und stellvertretend eine
Bindung, aus der keine Variable mehr an anderer Stelle vorkommt. 

\sloppypar
Durch die Einführung der neuen Sorte $M$ und der Anpassung der Sorte
von $\setf{\cdot|\cdot}$ zu $M \rightarrow U \rightarrow U$ muss das 
\emph{Cl}-Axiom, das die Vertauschbarkeit von Elementen in
\letr-Umgebungen formuliert, zu
\[\begin{array}{rll} 
E_{Cl} = & \set{\; \; \setf{c_M|\setf{d_M|e_U}} \approx \setf{d_M|\setf{c_M|e_U}} & } \\
\end{array}\]
angepasst werden.
Die Kongruenzrelation auf Termen, die nun betrachtet wird, ist 
$=_\mathpzc{E}$ mit $\mathpzc{E} = (\sigmaLet,E_{Cl} \cup E_{Split})$,
wobei $\sigmaLet$ über \letr-Umgebungen und Variablenketten verfügt. 
Bei der Unifikation von $\sigmaLet$-Termen mit \letr-Umgebungen und 
Variablenketten müssen die beiden Gleichungstheorien $E_{Cl}$ und 
$E_{Split}$ berücksichtigt werden. Um dies formal zu behandeln, wird
die Theorie der \emph{Kombination von Unifikationsalgorithmen} 
\cite{schmidt-schauss_unification_1988,baader_unification_1996}
benötigt. Dabei kommt erschwerend hinzu, dass die Identitäten
\emph{Cl} und \emph{Split}, die die Gleichungstheorien definieren,
über der gleichen Signatur $\sigmaLet$ definiert sind, und somit die
Signaturen der beiden Theorien nicht disjunkt sind. 
Der Aspekt der Kombination von Unifikationsalgorithmen für die
Theorien \emph{Cl} und \emph{Split} wird hier nicht
formal behandelt, sondern wir stützen uns auf die Erfahrungen, die bei
der Programmierung des Unifikationsalgorithmus für \letr-Umgebungen
mit vertauschbaren Elementen und Variablenketten gewonnen wurden. 
Ein formaler Nachweis, dass Unifikationsalgorithmen für die
beiden Theorien tatsächlich problemlos kombiniert werden können,
muss noch erbracht werden.  

Um die Split-Axiome bei der Unifikation zu berücksichtigen, benötigen
wir eine Variante der Mutationsregel (aus Definition
\ref{def:mutation-regel}), die so genannte  
\emph{Lazy Paramodulation}
\cite{gallier_complete_1989,baader_unification_2001}, die etwas 
liberaler bezüglich der Position ist, an der eine Identität angewendet
werden kann. 

\section{Unifikation von Termen mit Variablenketten}
\label{sec:uni-von-termen-mit-ketten}
\begin{definition}%[lazy paramodulation]
\label{def:lazy-paramodulation}
Die Regeln zur $Cl$-Unifikation in $\sigmaLet$ (Definition \ref{def:p-unifikatiosregeln-mod})
werden um folgende Regel erweitert (nach \citeA{gallier_complete_1989}):  

\fbox{
\begin{minipage}{0.98\textwidth}
\[\begin{array}{l}
\multicolumn{1}{l}{\mathbf{Lazy \; Paramodulation}} \\
\set{s[t]} \uplus P \Rightarrow \set{l \ue t, s[r]} \cup P \\ 
\quad \text{wobei} \; l \approx r \; \text{eine Version mit neuen Variablen von} \; l \approx r \in E \cup E^- \; \text{ist und} \\
\quad t \; \text{keine Variable ist. Wenn}\; l \; \text{keine Variable ist,} \\
\quad \text{dann sind die Wurzelsymbole Symbole von} \; l \; \text{und}\; t \; \text{gleich und} \\
\quad \text{auf} \; l \ue t \; \text{muss als nächstes \emph{Decomposition} angewendet werden.}
\end{array}\]
\end{minipage}}
\end{definition}

\begin{beispiel}
\label{bsp:lp-ketten}
Wir geben ein ausführliches Beispiel an, wie Terme mit Variablenketten in
$\sigmaLet$ mit Hilfe der \emph{Lazy Paramodulation}-Regel (abgekürzt
als \emph{LP}) unifiziert werden können. 
Es wird ein Unifikator aus der vollständigen Menge der Unifikatoren
berechnet für die Überlappung einer $(n,\emph{cp-e})$-Reduktion mit
einer internen (\emph{cp-e})-Reduktion.
Die Sorten der verwendeten Variablen sind
$x,x_i,y,y_i: V$; $v,w : Ap$; $s,t : T$ und $e,d : U$. 
Die Sorten der neu eingeführten Variablen sind $e', N_i : U$
und $b_1,b_2 : B$.
Die zu unifizierenden Terme enthalten Kontextvariablen
$C,R^-_1,R^-_2$, was ein Vorgriff auf den Inhalt des Kapitels zur
Unifikation mit Kontextvariablen darstellt (Kapitel \ref{cha:unif-von-kontexten}). Die Terme
$C(y_n),R^-_2(x)$ und $R^-_1(app(x_m,s))$ können vereinfacht als
Terme der Sorte $T$ mit einem entsprechenden Subterm verstanden werden. 
\begin{longtable}{rl}
\multicolumn{2}{l}{$\{letrec(\setf{b(x_1,v),{b(x,R^-_1(app(x_m,s))),{ch(b(x_2,x_1),b(x_m,x_{m-1}))|e}}}, R^-_2(x))$} \\
\multicolumn{2}{l}{$\phantom{\{} \ue letrec(\setf{b(y_1,w),{b(y,C(y_n)),{ch(b(y_2,y_1),b(y_n,y_{n-1}))|d}}}, t)\}$} \\
%& $\set{ letrec(\setf{b(x_1,v),{b(x,R^-_1(app(x_m,s))),{ch(b(x_2,x_1),b(x_m,x_{m-1}))|e}}}, R^-_2(x))$ \\
%& $\phantom{\{} \ue letrec(\setf{b(y_1,w),{b(y,C(y_n)),{ch(b(y_2,y_1),b(y_n,y_{n-1}))|d}}}, t)} $\\
$\xrightarrow{Dec} $ &$\set{\setf{b(x_1,v),{b(x,R^-_1(app(x_m,s))),{ch(b(x_2,x_1),b(x_m,x_{m-1}))|e}}} $\\
                  & $\phantom{\{} \ue \setf{b(y_1,w),{b(y,C(y_n)),{ch(b(y_2,y_1),b(y_n,y_{n-1}))|d}}}, $\\
		  & $\phantom{\{} R^-_2(x) \ue t} $\\
$ \xrightarrow{\emph{U-Dec $i)$}} $ &$\set{\setf{b(x,R^-_1(app(x_m,s))),{ch(b(x_2,x_1),b(x_m,x_{m-1}))|e}} $\\
                  & $\phantom{\{} \ue \setf{b(y,C(y_n)),{ch(b(y_2,y_1),b(y_n,y_{n-1}))|d}}, $\\
		  & $\phantom{\{} b(x_1,v) \ue b(y_1,w),R^-_2(x) \ue t} $\\
$ \xrightarrow{\emph{LP Split M}} $ &$\set{\setf{b(x,R^-_1(app(x_m,s))), $\\
  & $\phantom{\{\{\!|} {ch(b_1,b(z_2,z_1)),{b(z_3,z_2)),{ch(b(z_4,z_3),b_2)|e}}}} $\\ 
  & $\phantom{\{} \ue \setf{b(y,C(y_n)),{ch(b(y_2,y_1),b(y_n,y_{n-1}))|d}}, $\\
  & $\phantom{\{} \setf{ch(b_1,b_2)|e'} \ue \setf{ch(b(x_2,x_1),b(x_m,x_{m-1}))|e} $\\
  & $\phantom{\{} b(x_1,v) \ue b(y_1,w),R^-_2(x) \ue t} $\\
$ \xrightarrow{\emph{U-Dec $i)$}} $ &$\set{\setf{b(x,R^-_1(app(x_m,s))), $\\
  & $\phantom{\{\{\!|} {ch(b_1,b(z_2,z_1)),{b(z_3,z_2)),{ch(b(z_4,z_3),b_2)|e'}}}} $\\ 
  & $\phantom{\{} \ue \setf{b(y,C(y_n)),{ch(b(y_2,y_1),b(y_n,y_{n-1}))|d}}, $\\
  & $\phantom{\{} ch(b_1,b_2) \ue ch(b(x_2,x_1),b(x_m,x_{m-1})), e' \ue e $\\
  & $\phantom{\{} b(x_1,v) \ue b(y_1,w),R^-_2(x) \ue t} $\\
$ \xrightarrow{\emph{U-Dec $ii)$}} $ &$\set{\setf{ch(b_1,b(z_2,z_1)),{b(z_3,z_2)),{ch(b(z_4,z_3),b_2)|e'}}} \ue \setf{b(y,C(y_n))|N_1}, $\\ 
  & $\phantom{\{} \setf{b(x,R^-_1(app(x_m,s)))|N_1} \ue \setf{ch(b(y_2,y_1),b(y_n,y_{n-1}))|d}, $\\
  & $\phantom{\{} ch(b_1,b_2) \ue ch(b(x_2,x_1),b(x_m,x_{m-1})), e' \ue e $\\
  & $\phantom{\{} b(x_1,v) \ue b(y_1,w),R^-_2(x) \ue t} $\\
$ \xrightarrow{\emph{U-Dec $ii)$}} $ &$\set{\setf{b(z_3,z_2)),{ch(b(z_4,z_3),b_2)|e'}} \ue \setf{b(y,C(y_n))|N_2}, $\\ 
  & $\phantom{\{} \setf{ch(b_1,b(z_2,z_1))|N_2} \ue N_1, $\\
  & $\phantom{\{} \setf{b(x,R^-_1(app(x_m,s)))|N_1} \ue \setf{ch(b(y_2,y_1),b(y_n,y_{n-1}))|d}, $\\
  & $\phantom{\{} ch(b_1,b_2) \ue ch(b(x_2,x_1),b(x_m,x_{m-1})), e' \ue e $\\
  & $\phantom{\{} b(x_1,v) \ue b(y_1,w),R^-_2(x) \ue t} $\\
$ \xrightarrow{\emph{U-Dec $i)$}} $ &$\set{b(z_3,z_2)) \ue b(y,C(y_n)), \setf{ch(b(z_4,z_3),b_2)|e'} \ue N_2, $\\ 
  & $\phantom{\{} \setf{ch(b_1,b(z_2,z_1))|N_2} \ue N_1, $\\
  & $\phantom{\{} \setf{b(x,R^-_1(app(x_m,s)))|N_1} \ue \setf{ch(b(y_2,y_1),b(y_n,y_{n-1}))|d}, $\\
  & $\phantom{\{} ch(b_1,b_2) \ue ch(b(x_2,x_1),b(x_m,x_{m-1})), e' \ue e $\\
  & $\phantom{\{} b(x_1,v) \ue b(y_1,w),R^-_2(x) \ue t} $\\

$ \xrightarrow{\emph{U-Dec $ii)$}} $ & $\set{b(z_3,z_2)) \ue b(y,C(y_n)), \setf{ch(b(z_4,z_3),b_2)|e'} \ue N_2, $\\ 
  & $\phantom{\{} \setf{ch(b_1,b(z_2,z_1))|N_2} \ue N_1, $\\
  & $\phantom{\{} N_1 \ue \setf{ch(b(y_2,y_1),b(y_n,y_{n-1}))|N_3}, \setf{b(x,R^-_1(app(x_m,s)))|N_3} \ue d, $\\
  & $\phantom{\{} ch(b_1,b_2) \ue ch(b(x_2,x_1),b(x_m,x_{m-1})), e' \ue e $\\
  & $\phantom{\{} b(x_1,v) \ue b(y_1,w),R^-_2(x) \ue t} $\\
$ \xrightarrow{\emph{Orient $N_1$}} $ & $\set{b(z_3,z_2)) \ue b(y,C(y_n)), \setf{ch(b(z_4,z_3),b_2)|e'} \ue N_2, $\\ 
$ \xrightarrow{\emph{Elim $N_1$}} $ & $\phantom{\{} N_1 \ue \setf{ch(b_1,b(z_2,z_1))|N_2},  $\\
  & $\phantom{\{} \setf{ch(b_1,b(z_2,z_1))|N_2} \ue \setf{ch(b(y_2,y_1),b(y_n,y_{n-1}))|N_3}, $\\
  & $\phantom{\{} \setf{b(x,R^-_1(app(x_m,s)))|N_3} \ue d, ch(b_1,b_2) \ue ch(b(x_2,x_1),b(x_m,x_{m-1})), $\\
  & $\phantom{\{} e' \ue e, b(x_1,v) \ue b(y_1,w),R^-_2(x) \ue t} $\\
$ \xrightarrow{\emph{U-Dec $i)$}} $ & $\set{b(z_3,z_2)) \ue b(y,C(y_n)), \setf{ch(b(z_4,z_3),b_2)|e'} \ue N_2, $\\ 
  & $\phantom{\{} N_1 \ue \setf{ch(b_1,b(z_2,z_1))|N_2},  $\\
  & $\phantom{\{} ch(b_1,b(z_2,z_1)) \ue ch(b(y_2,y_1),b(y_n,y_{n-1})), N_2 \ue N_3, $\\
  & $\phantom{\{} \setf{b(x,R^-_1(app(x_m,s)))|N_3} \ue d, ch(b_1,b_2) \ue ch(b(x_2,x_1),b(x_m,x_{m-1})), $\\
  & $\phantom{\{} e' \ue e, b(x_1,v) \ue b(y_1,w),R^-_2(x) \ue t} $\\
$ \xrightarrow{\emph{Dec}} $ & $\set{z_3 \ue y, z_2 \ue C(y_n), \setf{ch(b(z_4,z_3),b_2)|e'} \ue N_2, $\\ 
  & $\phantom{\{} N_1 \ue \setf{ch(b_1,b(z_2,z_1))|N_2},  $\\
  & $\phantom{\{} ch(b_1,b(z_2,z_1)) \ue ch(b(y_2,y_1),b(y_n,y_{n-1})), N_2 \ue N_3, $\\
  & $\phantom{\{} \setf{b(x,R^-_1(app(x_m,s)))|N_3} \ue d, ch(b_1,b_2) \ue ch(b(x_2,x_1),b(x_m,x_{m-1})), $\\
  & $\phantom{\{} e' \ue e, b(x_1,v) \ue b(y_1,w),R^-_2(x) \ue t} $\\
$ \xrightarrow{\emph{Con Weak}}$\footnote{An dieser Stelle wird die
  Unifikationsregel \emph{Context Weakening} aus Kapitel \ref{cha:unif-von-kontexten} zur Unifikation von
  Kontextvariablen verwendet: Die Gleichung $z_2 \ue C(y_n)$ besitzt
  eine Lösung, wenn $C$ gleich dem leeren Kontext $\square$ ist und
  $z_2$ gleich $y_n$.} 
 & $\set{z_3 \ue y, C \ue \square, z_2 \ue y_n, \setf{ch(b(z_4,z_3),b_2)|e'} \ue N_2, $\\ 
  & $\phantom{\{} N_1 \ue \setf{ch(b_1,b(z_2,z_1))|N_2},  $\\
  & $\phantom{\{} ch(b_1,b(z_2,z_1)) \ue ch(b(y_2,y_1),b(y_n,y_{n-1})), N_2 \ue N_3, $\\
  & $\phantom{\{} \setf{b(x,R^-_1(app(x_m,s)))|N_3} \ue d, ch(b_1,b_2) \ue ch(b(x_2,x_1),b(x_m,x_{m-1})), $\\
  & $\phantom{\{} e' \ue e, b(x_1,v) \ue b(y_1,w),R^-_2(x) \ue t} $\\
$ \xrightarrow{\emph{Dec}} $ & $\set{z_3 \ue y, C \ue \square, z_2 \ue y_n, \setf{ch(b(z_4,z_3),b_2)|e'} \ue N_2, $\\ 
  & $\phantom{\{} N_1 \ue \setf{ch(b_1,b(z_2,z_1))|N_2},  $\\
  & $\phantom{\{} b_1 \ue b(y_2,y_1), b(z_2,z_1) \ue b(y_n,y_{n-1}), N_2 \ue N_3, $\\
  & $\phantom{\{} \setf{b(x,R^-_1(app(x_m,s)))|N_3} \ue d, ch(b_1,b_2) \ue ch(b(x_2,x_1),b(x_m,x_{m-1})), $\\
  & $\phantom{\{} e' \ue e, b(x_1,v) \ue b(y_1,w),R^-_2(x) \ue t} $\\
$ \xrightarrow{\emph{Dec}} $ & $\set{z_3 \ue y, C \ue \square, z_2 \ue y_n, \setf{ch(b(z_4,z_3),b_2)|e'} \ue N_2, $\\ 
  & $\phantom{\{} N_1 \ue \setf{ch(b_1,b(z_2,z_1))|N_2},  $\\
  & $\phantom{\{} b_1 \ue b(y_2,y_1), b(z_2,z_1) \ue b(y_n,y_{n-1}), N_2 \ue N_3, $\\
  & $\phantom{\{} \setf{b(x,R^-_1(app(x_m,s)))|N_3} \ue d, b_1 \ue b(x_2,x_1), b_2 \ue b(x_m,x_{m-1}), $\\
  & $\phantom{\{} e' \ue e, b(x_1,v) \ue b(y_1,w),R^-_2(x) \ue t} $\\

$ \xrightarrow{\emph{Elim $b_1$}} $ & $\set{z_3 \ue y, C \ue \square, z_2 \ue y_n, \setf{ch(b(z_4,z_3),b_2)|e'} \ue N_2, $\\ 
  & $\phantom{\{} N_1 \ue \setf{ch(b_1,b(z_2,z_1))|N_2},  $\\
  & $\phantom{\{} b_1 \ue b(y_2,y_1), b(z_2,z_1) \ue b(y_n,y_{n-1}), N_2 \ue N_3, $\\
  & $\phantom{\{} \setf{b(x,R^-_1(app(x_m,s)))|N_3} \ue d, b(y_2,y_1) \ue b(x_2,x_1), b_2 \ue b(x_m,x_{m-1}), $\\
  & $\phantom{\{} e' \ue e, b(x_1,v) \ue b(y_1,w),R^-_2(x) \ue t} $\\
$ \xrightarrow{\emph{Dec $\times$ 3}} $ & $\set{z_3 \ue y, C \ue \square, z_2 \ue y_n, \setf{ch(b(z_4,z_3),b_2)|e'} \ue N_2, $\\ 
  & $\phantom{\{} N_1 \ue \setf{ch(b_1,b(z_2,z_1))|N_2},  $\\
  & $\phantom{\{} b_1 \ue b(y_2,y_1), z_2 \ue y_n, z_1 \ue y_{n-1}, N_2 \ue N_3, $\\
  & $\phantom{\{} \setf{b(x,R^-_1(app(x_m,s)))|N_3} \ue d, y_2 \ue x_2, y_1 \ue x_1, b_2 \ue b(x_m,x_{m-1}), $\\
  & $\phantom{\{} e' \ue e, x_1 \ue y_1, v \ue w,R^-_2(x) \ue t} $\\
$ \xrightarrow{\emph{Orient $\times$ 3}} $ & $\set{z_3 \ue y, C \ue \square, z_2 \ue y_n, N_2 \ue \setf{ch(b(z_4,z_3),b_2)|e'}, $\\ 
  & $\phantom{\{} N_1 \ue \setf{ch(b_1,b(z_2,z_1))|N_2},  $\\
  & $\phantom{\{} b_1 \ue b(y_2,y_1), z_2 \ue y_n, z_1 \ue y_{n-1}, N_2 \ue N_3, $\\
  & $\phantom{\{} d \ue \setf{b(x,R^-_1(app(x_m,s)))|N_3}, y_2 \ue x_2, y_1 \ue x_1, b_2 \ue b(x_m,x_{m-1}), $\\
  & $\phantom{\{} e' \ue e, x_1 \ue y_1, v \ue w, t \ue R^-_2(x)} $\\
$ \xrightarrow{\emph{Elim $N_2$}} $ & $\set{z_3 \ue y, C \ue \square, z_2 \ue y_n, N_2 \ue \setf{ch(b(z_4,z_3),b_2)|e'}, $\\ 
  & $\phantom{\{} N_1 \ue \setf{ch(b_1,b(z_2,z_1))|{ch(b(z_4,z_3),b_2)|e'}},  $\\
  & $\phantom{\{} b_1 \ue b(y_2,y_1), z_2 \ue y_n, z_1 \ue y_{n-1}, \setf{ch(b(z_4,z_3),b_2)|e'} \ue N_3, $\\
  & $\phantom{\{} d \ue \setf{b(x,R^-_1(app(x_m,s)))|N_3}, y_2 \ue x_2, y_1 \ue x_1, b_2 \ue b(x_m,x_{m-1}), $\\
  & $\phantom{\{} e' \ue e, x_1 \ue y_1, v \ue w, t \ue R^-_2(x)} $\\
$ \xrightarrow{\emph{Orient $N_3$}} $ & $\set{z_3 \ue y, C \ue \square, z_2 \ue y_n, N_2 \ue \setf{ch(b(z_4,z_3),b_2)|e'}, $\\ 
$ \xrightarrow{\emph{Elim $N_3$}} $  & $\phantom{\{} N_1 \ue \setf{ch(b_1,b(z_2,z_1))|{ch(b(z_4,z_3),b_2)|e'}},  $\\
  & $\phantom{\{} b_1 \ue b(y_2,y_1), z_2 \ue y_n, z_1 \ue y_{n-1}, N_3 \ue \setf{ch(b(z_4,z_3),b_2)|e'}, $\\
  & $\phantom{\{} d \ue \setf{b(x,R^-_1(app(x_m,s)))| {ch(b(z_4,z_3),b_2)|e'}}, $\\ 
  & $\phantom{\{} y_2 \ue x_2, y_1 \ue x_1, b_2 \ue b(x_m,x_{m-1}), e' \ue e, x_1 \ue y_1, v \ue w, t \ue R^-_2(x)} $\\
$ \xrightarrow{\emph{Elim $z_1,z_2, z_3$}} $ & $\set{z_3 \ue y, C \ue \square, z_2 \ue y_n, N_2 \ue \setf{ch(b(z_4,y),b(x_m,x_{m-1}))|e}, $\\ 
$ \xrightarrow{\emph{Elim $y_1,y_2$}} $ & $\phantom{\{} N_1 \ue \setf{ch(b(x_2,x_1),b(y_n,y_{n-1})),{ch(b(z_4,y),b(x_m,x_{m-1}))|e}},  $\\
$ \xrightarrow{\emph{Elim $b_1,b_2$}} $  & $\phantom{\{} b_1 \ue b(x_2,x_1), y_n \ue y_n, z_1 \ue y_{n-1}, N_3 \ue \setf{ch(b(z_4,y),b(x_m,x_{m-1}))|e}, $\\
$ \xrightarrow{\emph{Elim $e'$}} $  & $\phantom{\{} d \ue \setf{b(x,R^-_1(app(x_m,s))), {ch(b(z_4,y),b(x_m,x_{m-1}))|e}}, $\\ 
  & $\phantom{\{} y_2 \ue x_2, y_1 \ue x_1, b_2 \ue b(x_m,x_{m-1}), e' \ue e, x_1 \ue x_1, v \ue w, t \ue R^-_2(x)} $\\
\end{longtable}
Das Unifikationsproblem in der letzten Zeile ist in gelöster Form und
repräsentiert einen Unifikator $\sigma$ für das Ausgangsproblem:
\[\begin{array}{rrll}
\sigma = & \set{ & 
  y_1 \ue x_1, 
  y_2 \ue x_2, \\
& &   z_1 \ue y_{n-1}, 
   z_2 \ue y_n, 
   z_3 \ue y,
   e' \ue e, \\
& &  v \ue w, 
  C \ue \square, 
  t \ue R^-_2(x), \\
& &  d \ue \setf{b(x,R^-_1(app(x_m,s))), {ch(b(z_4,y),b(x_m,x_{m-1}))|e}}, \\ 
& &   N_1 \ue \setf{ch(b(x_2,x_1),b(y_n,y_{n-1})),{ch(b(z_4,y),b(x_m,x_{m-1}))|e}},  \\
& &   N_2 \ue \setf{ch(b(z_4,y),b(x_m,x_{m-1}))|e}, \\ 
& &   N_3 \ue \setf{ch(b(z_4,y),b(x_m,x_{m-1}))|e}, \\  
& &   b_1 \ue b(x_2,x_1), 
   b_2 \ue b(x_m,x_{m-1}) & }. \\
\end{array}\]

Anwendung des berechneten Unifikators auf die beiden Ausgangsterme
ergibt 
\[\begin{array}{l}
\sigma(letrec(\setf{b(y_1,w),b(y,C(y_n)),ch(b(y_2,y_1),b(y_n,y_{n-1}))|d}, t)) \\
= letrec(\setf{b(x_1,w),b(y,y_n),ch(b(x_2,x_1),b(y_n,y_{n-1})), \\
\phantom{= letrec( \{\!|} b(x,R^-_1(app(x_m,s))), ch(b(z_4,y),b(x_m,x_{m-1}))|e}, R^-_2(x)) \\
\end{array}\]
und 
\[\begin{array}{l}
\sigma(letrec(\setf{b(x_1,v),b(x,R^-_1(app(x_m,s))),ch(b(x_2,x_1),b(x_m,x_{m-1}))|e},R^-_2(x))) \\
= letrec(\setf{b(x_1,w),b(x,R^-_1(app(x_m,s))),ch(b(x_2,x_1),b(x_m,x_{m-1}))|e},R^-_2(x)). \\
\end{array}\]
Die beiden Resultatterme sehen nicht gleich aus, sind aber bezüglich $=_{\mathpzc{E}}$ 
(der durch die Split-Axiome und das $Cl$-Axiom induzierten
Kongruenzrelation) gleich. Dies ist offensichtlich, wenn man das
\emph{Split M}-Axiom mit den gleichen neuen  
Variablen, wie auch während der Unifikation anwendet:
\[\begin{array}{l}
letrec(\setf{b(x_1,v),b(x,R^-_1(app(x_m,s))),ch(b(x_2,x_1),b(x_m,x_{m-1}))|e}, R^-_2(x)) \\
\approx^{Split\; M} letrec(\setf{b(x_1,w),b(x,R^-_1(app(x_m,s))), \\
\phantom{\approx^{Split\; M} letrec(\{\!|} ch(b_1,b(z_2,z_1)),b(z_3,z_2),ch(b(z_4,z_3),b_2)|e}, R^-_2(x))\\ 
\xrightarrow{\sigma} 
letrec(\setf{b(x_1,v),b(x,R^-_1(app(x_m,s))), \\
\phantom{\xrightarrow{\sigma} letrec(\{\!|} ch(b(x_2,x_1),b(y_n,y_{n-1})),b(y,y_n),ch(b(z_4,y),b(x_m,x_{m-1}))|e}, R^-_2(x))\\  
\end{array}\]
Berücksichtigt man die Vertauschbarkeit der Elemente in
\letr-Umgebungen, sind die beiden substituierten Resultatterme
gleich. 
\end{beispiel}

Zusammen mit den Regeln \emph{Tautology, Orientation, Decomposition,
Variable Elimination, Symbol Clash} und \emph{Occurs Check}
beschreibt die Regel \emph{Lazy Paramodulation} eine vollständige
Unifikationsprozedur in beliebigen (unsortierten) Gleichungstheorien
\cite{gallier_complete_1989}. Allerdings kann über ihr
Terminierungsverhalten
%, wie bei der (sortieren) Unifikationsprozedur,
%die die \emph{Mutation}-Regel verwendet 
keine Aussage gemacht werden. Wir haben hier das Problem,
dass die Anwendung eines Axioms nicht eingeschränkt ist und beliebig
oft wiederholt werden kann, wenn eine \emph{Decomposition}-Transformation 
mit dem durch die Anwendung des Axioms neu eingeführten Term möglich wird.  
Auf eine Variablenkette können demnach beliebig viele \emph{Split A-, Split E- }
oder \emph{Split M}-Transformationen angewendet werden. 

\subsection{Unifikation von Bindungen aus Variablenketten mit Bindungen}
\label{sec:uni-ketten-bindungen}
Um die Terminierung der Unifikation von Termen mit Variablenketten zu
gewährleisten, muss nach Möglichkeiten gesucht werden, die Anwendung
der Split-Axiome zu beschränken. Dabei machen wir uns die Tatsache
zunutze, dass Variablenketten in Termen, die für die Berechnung von 
Überlappungen unifiziert werden müssen, immer Bestandteile von
\letr-Umgebungen sind. D.h. die zu unifizierenden Gleichungen zwischen
\letr-Umgebungen sind immer von der Form 
\[\setf{b_1, \dots, b_m, c_1, \dots, c_n|e} \ue \setf{b'_1, \dots, b'_{m'}, c'_1, \dots c'_{n'}|e'}, \]
wobei $b_i,b'_{i'}$ Terme der Sorte $B$ (d.h. \letr-Bindungen), $c_i,c'_{i'}$ Variablenketten und
$e,e'$ Umgebungsvariablen der Sorte $U$ sind.
Einzelne Bindungen der Variablenketten $c_i$ (bzw. $c'_{i'}$), die
durch eine Anwendung von Split-Axiomen abgespalten werden, können
unifiziert werden mit 
\begin{enumerate}
\item Bindungen $b'_{i'}$ (bzw. $b_i$) oder 
\item mit einzelnen Bindungen einer Variablenkette $c'_{i'}$ (bzw. $c_i$)
  oder 
\item mit der Umgebungsvariablen $e'$ (bzw. $e$). 
\end{enumerate}
Die Anwendung von Split-Axiomen kann nicht beschränkt werden, wenn die
beiden letzten Möglichkeiten der Unifikation einzelner Bindungen von
Variablenketten erlaubt werden. Aus diesem Grund werden die
Unifikationsmöglichkeiten von Bindungen aus Variablenketten
eingeschränkt: Einzelne durch die Anwendung von Split-Axiomen
abgespaltene Bindungen von Variablenketten werden nur mit Bindungen,
der gegenüberliegenden Umgebung unifiziert, 
die nicht von Variablenketten abgespalten sind. Somit wird für alle Ketten
$c_i$ (bzw. $c'_{i'}$) maximal $m'$-mal ($m$-mal) ein Split-Axiom
angewendet. 
Außerdem hat eine Variablenkette $c_i$ die Möglichkeit, mit
einer Kette $c'_{i'}$ oder der Umgebungsvariablen $e'$ unifiziert zu
werden (bzw. kann eine Kette $c'_{i'}$ mit der Umgebungsvariablen $e$
unifiziert werden). Diesen Unifikationsmöglichkeiten wenden wir uns in
Abschnitt \ref{sec:unif-von-ketten-ketten} zu.   
Die Beschränkung der Anwendung von Split-Axiomen für Variablenketten
kann durch die folgende Unifikationsregeln formuliert werden. 

\begin{definition}
\label{def:uni-regel-ketten}
Wir betrachten die Signatur $\sigmaLet$ mit dem
\emph{Cl}-Funktionssymbol $\setf{\cdot|\cdot}$ und dem Funktionssymbol
für Variablenketten $ch$, für das die Split-Axiome aus Definition
\ref{def:sigmaLet-ketten} gelten. Die Transformationsregeln zur
Unifikation in regulären Signaturen mit Sorten (Definition
\ref{def.unifikationsregeln}) werden um die Regeln aus den Abbildungen  
\ref{fig:uni-regeln-ketten-1} und \ref{fig:uni-regeln-ketten-2}
erweitert, um Terme mit Variablenketten zu unifizieren. 

Sind mehrere Transformationen auf ein Unifikationsproblem anwendbar,
wird eine beliebige ausgewählt. 
\end{definition}

\begin{figure}[p]
\fbox{
\begin{minipage}{0.98\textwidth}
\[\begin{array}{l}
\multicolumn{1}{l}{\mathbf{Split-R}} \\
\set{\setf{t|s}} \ue \set{\setf{t_1,\dots,ch(b(x_m,x_{m-1}),b(x_n,x_{n-1})),\dots, t_k|s'}} \uplus P \Rightarrow \\ 
  \begin{array}[t]{rl} 
    i)& \set{t \ue b(x_m,x_{m-1}), s \ue \setf{t_1,\dots,ch(b(z,x_m),b(x_n,x_{n-1}))^M,\dots, t_k|s'}} \cup P \\
        \multicolumn{2}{l}{\quad \text{wobei}\; z \; \text{eine neue Variable der Sorte} \; V \; \text{ist}.} \\
    ii)& \set{t \ue b(x_n,x_{n-1}), s \ue \setf{t_1,\dots,ch(b(x_m,x_{m-1}),b(x_{n-1},z)),\dots, t_k|s'}} \cup P \\
       \multicolumn{2}{l}{\quad \text{wobei}\; z \; \text{eine neue Variable der Sorte} \; V \; \text{ist}.} \\
    iii)& \set{t \ue b(z_3,z_2), s \ue \setf{t_1,\dots,ch(b(x_m,x_{m-1}),b(z_2,z_1)), \\
       & \phantom{\{t \ue b(z_3,z_2), s \ue \{} ch(b(z_4,z_3),b(x_n,x_{n-1}))^M,\dots, t_k|s'}} \cup P \\
       \multicolumn{2}{l}{\quad \text{wobei}\; z_1,z_2,z_3,z_4 \; \text{neue Variablen der Sorte} \; V \; \text{sind}.} \\      
  \end{array} \\
 \text{Für alle Transformationen muss gelten: $t$ ist ein Term der Sorte $B$ und} \\
 \text{\emph{tail$(s)$} sowie \emph{tail$(s')$} bezeichnen nicht die gleiche Kontextvariable $X$ der Sorte $U$.} \\

\multicolumn{1}{l}{\mathbf{Split-L}} \\
\set{\setf{t_1,\dots,ch(b(x_m,x_{m-1}),b(x_n,x_{n-1})),\dots, t_k|s}} \ue \set{\setf{t|s'}} \uplus P \Rightarrow \\ 
  \begin{array}[t]{rl} 
    i)& \set{t \ue b(x_m,x_{m-1}), s' \ue \setf{t_1,\dots,ch(b(z,x_m),b(x_n,x_{n-1}))^M,\dots, t_k|s}} \cup P \\
        \multicolumn{2}{l}{\quad \text{wobei}\; z \; \text{eine neue Variable der Sorte} \; V \; \text{ist}.} \\
    ii)& \set{t \ue b(x_n,x_{n-1}), s' \ue \setf{t_1,\dots,ch(b(x_m,x_{m-1}),b(x_{n-1},z)),\dots, t_k|s}} \cup P \\
        \multicolumn{2}{l}{\quad \text{wobei}\; z \; \text{eine neue Variable der Sorte} \; V \; \text{ist}.} \\
    iii)& \set{t \ue b(z_3,z_2), s' \ue \setf{t_1,\dots,ch(b(x_m,x_{m-1}),b(z_2,z_1)),\\
	& \phantom{\{t \ue b(z_3,z_2), s' \ue \{} ch(b(z_4,z_3),b(x_n,x_{n-1}))^M,\dots, t_k|s}} \cup P \\
      \multicolumn{2}{l}{\quad \text{wobei}\; z_1,z_2,z_3,z_4 \; \text{neue Variablen der Sorte} \; V \; \text{sind}.} \\      
  \end{array} \\
\text{Für alle Transformationen muss gelten: $t$ ist ein Term der Sorte $B$ und} \\
\text{\emph{tail$(s)$} sowie \emph{tail$(s')$} bezeichnen nicht die gleiche Kontextvariable $X$ der Sorte $U$.} \\
 
\multicolumn{1}{l}{\mathbf{U - Decomposition}} \\
\set{\setf{t|s} \ue \setf{t'|s'}} \uplus P \Rightarrow 
  \begin{array}[t]{rl} 
    i)& \set{t \ue t', s \ue s'} \cup P  \\
    \multicolumn{2}{l}{\quad \text{wenn}\; t,t' \; \text{Terme der Sorte} \; B \; \text{sind.}} \\
    ii)& \set{s \ue \setf{t'|N}, \setf{t|N} \ue s'} \cup P \\
    \multicolumn{2}{l}{\quad\text{wobei}\; N \; \text{eine neue Variable der Sorte} \; U \; \text{ist}.} \\
  \end{array}\\
\quad \text{Für beide Transformationen muss gelten, dass \emph{tail$(s)$} und \emph{tail$(s')$}} \\
\quad \text{nicht die gleiche Kontextvariable $X$ der Sorte $U$ bezeichnen.}\\
\end{array}\]
\end{minipage}}
\caption{Unifikationsregeln für Terme mit \letr-Umgebungen und
  Variablenketten (Teil 1). \label{fig:uni-regeln-ketten-1}}
\end{figure}

\begin{figure}[t]
\fbox{
\begin{minipage}{0.98\textwidth}
$\begin{array}{l}
\multicolumn{1}{l}{\mathbf{U - Decomposition*}} \\
\set{\setf{t|s} \ue \setf{t'|s'}} \uplus P \Rightarrow \set{\setf{t|\widehat{s}} \ue \setf{u|\widehat{s'}}} \cup P \\
\quad \text{wenn \emph{tail$(s)$}} = \emph{tail$(s') = X:U$.} \\  
\quad \widehat{s}, \widehat{s'} \; \text{sind gleich}\; s,s'\; \text{mit} \; \emph{tail}(s), \emph{tail}(s') \; \text{durch} \; \emptyset \; \text{ersetzt}.\\
\multicolumn{1}{l}{\mathbf{U - Fail}} \\

\set{\setf{t|s} \ue \setf{t'|s'}} \uplus P \Rightarrow \bot \\
\quad \text{wenn \emph{tail$(s)$}} = \emph{tail$(s')$} = \emptyset  
 \; \text{und} \; \\
\quad s,s' \; \text{nicht}\; \text{die gleiche Anzahl von Elementen besitzen.} \\
\end{array}$
\end{minipage}}
\caption{Unifikationsregeln für Terme mit \letr-Umgebungen und
  Variablenketten (Teil 2). \label{fig:uni-regeln-ketten-2}}
\end{figure}

Die Transformation \emph{Split-R} entspricht der Anwendung eines
Split-Axioms auf eine Variablenkette in einer \letr-Umgebung auf der
rechten Seite einer Unifikationsgleichung. Die abgespaltene Bindung
der Variablenkette wird direkt mit einer Bindung der
gegenüberliegenden Umgebung unifiziert, die nicht aus einer
Variablenkette abgespalten ist. Die Transformationsmöglichkeit $i)$
der \emph{Split-R}-Regel entspricht einer Anwendung des \emph{Split A}-Axioms. Die 
Transformationsmöglichkeiten $ii)$ und $iii)$ repräsentieren
Anwendungen des \emph{Split E}- und des \emph{Split M}-Axioms. 
Die \emph{Split-L}-Regel repräsentiert analog die Möglichkeiten der
Anwendung von Split-Axiomen auf Variablenketten, die in linken Seiten
von Unifikationsgleichungen vorkommen. 
Damit, falls die
Unifikation nicht fehlschlägt, die zu unifizierenden Terme syntaktisch
gleich sind, muss man sich die Anwendung des 
entsprechenden Split-Axioms merken, zusammen mit den dadurch neu
eingeführten Variablen (siehe dazu Beispiel \ref{bsp:lp-ketten}). 
Die Split-Regeln markieren alle Variablenketten mit $M$, die durch
Abspaltungen von Bindungen (\emph{Split-X $i)$}\footnote{
  \emph{Split-X} bezeichnet die beiden Regeln \emph{Split-R} und
  \emph{Split-L}.}) 
oder Aufteilen der 
Kette (\emph{Split-X $iii)$}) die Anfangsbindung der
ursprünglichen Variablenkette nicht mehr enthalten. Diese Markierungen werden
später verwendet, um die Unifikationsmöglichkeiten von
Variablenketten untereinander zu beschränken (siehe Abschnitt
\ref{sec:unif-von-ketten-ketten}). 

Die Regel \emph{U-Decomposition $i)$} wird nur auf Terme der Sorte $B$
angewendet. Dadurch wird zum jetzigen Zeitpunkt vermieden, dass
Variablenketten miteinander unifiziert werden. Die Regeln zur
Unifikation von Variablenketten untereinander werden in Abschnitt
\ref{sec:unif-von-ketten-ketten} beschrieben. 
\emph{U-Decomposition $ii)$} ist 
auch für Variablenketten anwendbar, wodurch die Vertauschbarkeit von
Ketten in Umgebungen gewährleistet wird. 
Für die Anwendung der Regeln \emph{U-Decomposition, Split-R} und
\emph{Split-L} muss gelten, dass die zu unifizierenden Umgebungen
nicht die gleiche Kontextvariable $X$ der Sorte $U$ enthalten. Ansonsten
wird die Regel \emph{U-Decomposition$*$} angewendet, die beide
Umgebungsvariablen durch die leere Umgebung $\emptyset$ ersetzt.
Die Regel \emph{U-Fail} behandelt den Fall, dass die zu unifizierenden
Umgebungen keine Umgebungsvariablen der Sorte $U$ enthalten und eine
verschiedene Anzahl von Elementen besitzen. In diesem Fall besitzt
die Unifikationsgleichung keine Lösung. 

Die Beschränkung der Anwendung der Split-Axiome führt dazu, dass
einzelne Bindungen von Variablenketten nicht mit Bindungen von anderen
Variablenketten unifiziert werden. Für eine Unifikationsgleichung der
Form $\setf{ch(b(x_m,x_{m-1}),b(x_n,x_{n-1}))|e} \ue \setf{ch(b(y_{m'},y_{m'-1}),b(y_{n'},y_{n'-1}))|d}$, wobei 
$e,d$ Variablen der Sorte $U$ sind, ist es bei der Unifikation mit
der \emph{Lazy Paramodulation}-Regel (aus Definition
\ref{def:lazy-paramodulation}) möglich, beliebig viele Bindungen aus
$ch(b(x_m,x_{m-1}),b(x_n,x_{n-1}))$ und
$ch(b(y_{m'},y_{m'-1}),b(y_{n'},y_{n'-1}))$ durch Anwendung von Split-Axiomen
abzuspalten und miteinander zu unifizieren. Die beschränkten
\emph{Split-R} und \emph{Split-L} Regeln erlauben dies nicht mehr. Aus
diesem Grund ist zu überlegen, wie Variablenketten mit anderen
Variablenketten zu unifizieren sind. Eine einfache Anwendung von
\emph{U-Decomposition} und \emph{Decomposition}, die für das Beispiel
folgendermaßen aussieht
\[\begin{array}{rl}
& \set{\setf{ch(b(x_m,x_{m-1}),b(x_n,x_{n-1}))|e} \ue \setf{ch(b(y_{m'},y_{m'-1}),b(y_{n'},y_{n'-1}))|d}} \\
\xrightarrow{\emph{U-Dec i)}} & \set{ch(b(x_m,x_{m-1}),b(x_n,x_{n-1})) \ue ch(b(y_{m'},y_{m'-1}),b(y_{n'},y_{n'-1})), e \ue d} \\
\xrightarrow{\emph{Dec}} & \set{b(x_m,x_{m-1}) \ue b(y_{m'},y_{m'-1}), b(x_n,x_{n-1}) \ue b(y_{n'},y_{n'-1}), e \ue d}, \\
\end{array}\]
verletzt die Vollständigkeit der Unifikationsprozedur, weil die
Möglichkeit besteht, dass nur einzelne Bindungen der beiden
Variablenketten gleich sind und die restlichen unterschiedlichen Teile
mit der Umgebungsvariablen $e$ oder $d$ der gegenüberliegenden
Umgebung unifiziert werden. 
Die Regel \emph{U-Decomposition $i)$} ist so formuliert, dass 
eine Anwendung auf zwei Variablenketten wie im obigen Beispiel
ausgeschlossen ist. 
%Durch eine Anwendung von \emph{Decomposition} auf die Gleichung 
%$ch(b(x_m,x_{m-1}),b(x_n,x_{n-1})) \ue
%ch(b(y_{m'},y_{m'-1}),b(y_{n'},y_{n'-1}))$
%wird nur die Möglichkeit betrachtet, dass die beiden Ketten komplett
%gleich sind. Eine Anwendung von \emph{U-Decomposition $ii)$} anstatt
%der Transformation \emph{U-Decomposition $i)$} berücksichtigt noch
%den Fall, dass die beide Variablenkette disjunkt sind. 
Um die Möglichkeiten der teilweisen Gleichheit von
Variablenketten bei der Unifikation zu berücksichtigen, werden
zusätzliche Unifikationsregeln benötigt. 
Bevor wir uns den Transformationsregeln zur Unifikation
von Variablenketten mit Variablenketten zuwenden, betrachten wir
die Form eines Unifikationsproblems zwischen Umgebungen nach einer
Folge von Transformationen mit den Regeln aus Definition
\ref{def:uni-regel-ketten}.

Die Terme, die zur Berechnung von Überlappungen unifiziert werden
müssen, enthalten maximal eine Variablenkette pro
Umgebung und genau eine Umgebungsvariable der Sorte $U$. 
Die Unifikationsgleichungen zwischen Umgebungen sind zu
Beginn einer Folge von Transformationen von der Form 
\begin{equation}
\label{eqq2}
\set{\setf{b_1, \dots, b_m, c |e} \ue \setf{b'_1, \dots, b'_{m'}, c'|e'}},
\end{equation}
wobei $b_i,b'_{i'}$ Terme der Sorte $B$ (\letr-Bindungen), $c,c'$
Variablenketten (die in den Umgebungen nicht vorhanden sein
müssen) und $e,e'$ Variablen der Sorte $U$ sind. 
Wir gehen hier von dem Fall aus, dass die Ketten $c$ und $c'$ in den
Umgebungen enthalten sind. 
Durch eine (beliebige) Folge von Transformationen mit den
Unifikationsregeln aus Definition \ref{def:uni-regel-ketten} kann das
Unifikationsproblem (\ref{eqq2}) in die Form:
\begin{equation}
\label{eq:3}
\begin{array}{l}
\set{\setf{c_{1},\dots,c_{n} |d} \ue \setf{c'_{1},\dots, c'_{n'}|d'}, 
%  \phantom{\{} \setf{c_{k 1},\dots,c_{k n} |X_k} \ue \setf{c'_{k 1},\dots, c'_{k n'}|Y_k}, \\
   s_1 \ue t_1, \dots s_l \ue t_l}
\end{array}\end{equation}
gebracht werden,
wobei $c_{i},c'_{i'}$ Variablenketten, die durch die
Anwendung \emph{Split-X $iii)$} 
aus $c$ bzw. $c'$ entstanden sind, und $d,d'$ Variablen der 
Sorte $U$ sind. Die Gleichungen $s_j \ue t_j$ sind Unifikationsgleichungen
in semi-gelöster Form und enthalten die $b_i,b'_{i'}$ (siehe
Definition \ref{def:semi-geloeste-form}).
Wir geben an dieser Stelle keinen Beweis für die Behauptung, dass eine
Unifikationsgleichung zwischen Umgebungen mit Variablenketten durch
eine beliebige Folge von Transformationen mit Regeln aus Definition
\ref{def:uni-regel-ketten} in die Form (\ref{eq:3}) gebracht werden
kann\footnote{Der Beweis ist ähnlich zum Beweis, dass eine
Unifikationsgleichung zwischen Umgebungen in semi-gelöste Form
gebracht werden kann (Lemma \ref{lemma:vollst.zerlegung.von.umg})}. 
Stattdessen geben wir ein Beispiel, wie eine solche Folge von
Transformationen für eine Unifikationsgleichung zwischen Umgebungen
mit Variablenketten aussehen kann. 
\begin{beispiel}
Wir betrachten ein Unifikationsproblem zwischen Umgebungen mit
Variablenketten mit den Variablensorten $b_i:B$, $x_i,y_{i'},z_i:V$ und
$e,d:U$. Eine Folge von Transformationen, die das gewählte Unifikationsproblem 
in die Form (\ref{eq:3}) bringt, sieht folgendermaßen aus:  
\begin{longtable}{rl}
& $ \set{\setf{b_1,b_2,ch(b(x_2,x_1),b(x_n,x_{n-1}))|e} \ue \setf{b_3,ch(b(y_2,y_1),b(y_{n'},y_{n'-1}))|d}}$ \\
$ \xrightarrow{\emph{Split-R iii)}}$ & $ \set{b_1 \ue b(z_3,z_2), \setf{b_2,ch(b(x_2,x_1),b(x_n,x_{n-1}))|e} \ue $ \\
  & $ \phantom{\{} \setf{b_3,ch(b(y_2,y_1),b(z_2,z_1)),ch(b(z_3,z_4),b(y_{n'},y_{n'-1}))|d}} $ \\
$ \xrightarrow{\emph{Split-L i)}}$ & $ \set{b_1 \ue b(z_3,z_2), b_3 \ue b(x_2,x_1), \setf{b_2,ch(b(z_5,x_2),b(x_n,x_{n-1}))|e} \ue $ \\
  & $ \phantom{\{} \setf{ch(b(y_2,y_1),b(z_2,z_1)),ch(b(z_3,z_4),b(y_{n'},y_{n'-1}))|d}} $ \\
$ \xrightarrow{\emph{U-Dec ii)}}$ & $ \set{b_1 \ue b(z_3,z_2), b_3 \ue b(x_2,x_1), \setf{ch(b(z_5,x_2),b(x_n,x_{n-1}))|e} \ue $ \\
  & $ \phantom{\{} \setf{ch(b(y_2,y_1),b(z_2,z_1))|N_1}, \setf{b_2|N_1} \ue \setf{ch(b(z_3,z_4),b(y_{n'},y_{n'-1}))|d}} $ \\
$ \xrightarrow{\emph{U-Dec ii)}}$ & $ \set{b_1 \ue b(z_3,z_2), b_3 \ue b(x_2,x_1), \setf{ch(b(z_5,x_2),b(x_n,x_{n-1}))|e} \ue $ \\
  & $ \phantom{\{} \setf{ch(b(y_2,y_1),b(z_2,z_1))|N_1}, N_1 \ue \setf{ch(b(z_3,z_4),b(y_{n'},y_{n'-1}))|N_2}, $ \\
  & $ \phantom{\{} \setf{b_2|N_2} \ue d} $ \\
$ \xrightarrow{\emph{Elim $N_1$}}$ & $ \set{b_1 \ue b(z_3,z_2), b_3 \ue b(x_2,x_1), \setf{ch(b(z_5,x_2),b(x_n,x_{n-1}))|e} \ue $ \\
  & $ \phantom{\{} \setf{ch(b(y_2,y_1),b(z_2,z_1)),ch(b(z_3,z_4),b(y_{n'},y_{n'-1}))|N_2}, $ \\
  & $ \phantom{\{} N_1 \ue \setf{ch(b(z_3,z_4),b(y_{n'},y_{n'-1}))|N_2},\setf{b_2|N_2} \ue d} $ \\
\end{longtable}
Nach einem \emph{Orient}-Schritt für $d$ entspricht das letzte Unifikationsproblem der Form (\ref{eq:3}). 
\end{beispiel}

Die 
%Terme der Sorte $B$ 
\letr-Bindungen zweier zu unifizierender Umgebungen können
also durch eine beliebige Folge von \emph{U-Decomposition-, Split-R-,
Split-L-, Variable Elimination-} und \emph{Orientation}-Transformationen
in Unifikationsgleichungen in semi-gelöster Form "`verschoben"'
werden, so dass nur die Gleichungen zwischen Umgebungen nur noch von
der Form 
$\setf{c_{1},\dots,c_{n} |d} \ue \setf{c'_{1},\dots, c'_{n'}|d'}$
%$\set{\setf{c_{1_1},\dots,c_{1_n} |X_1} \ue \setf{c'_{1_1},\dots, c'_{1_{n'}}|Y_1}, \dots, 
%\phantom{\{} \setf{c_{k_1},\dots,c_{k_n} |X_k} \ue \setf{c'_{k_1},\dots, c'_{k_{n'}}|Y_k}}$
sind. Wir wenden uns nun den Unifikationsregeln zur Lösung solcher
Gleichungen zu. 

\subsection{Unifikation von Variablenketten mit Variablenketten}
\label{sec:unif-von-ketten-ketten}
Wir betrachten zunächst den vereinfachten Fall, dass jede
Umgebung nur eine Variablenkette enthält.
Prinzipiell müssen zur Lösung einer Unifikationsgleichung der 
Form 
\[\setf{ch(b(x_m,x_{m-1}),b(x_n,x_{n-1}))|e} \ue \setf{ch(b(y_{m'},y_{m'-1}),b(y_{n'},y_{n'-1}))|d}\]
alle Möglichkeiten betrachtet werden, wie einzelne Bindungen der
beiden Ketten untereinander unifiziert werden können. Bindungen einer
Kette, die dabei nicht mit Bindungen der anderen Kette unifiziert
werden, können mit der Umgebungsvariablen der gegenüberliegenden
Umgebung unifiziert werden. 
Im Folgenden sollen zwei Kriterien vorgestellt werden, die es
ermöglichen, die Anzahl der zu betrachtenden
Unifikationsmöglichkeiten bei der Unifikation von Variablenketten
untereinander zu beschränken. 
Das erste Kriterium wird anhand des folgenden Beispiels eingeführt. 
\begin{beispiel}
\label{bsp:kreuzunifikation}
Wir betrachten ein Unifikationsproblem zwischen konkreten
Variablenketten, d.h. Ketten die nicht durch das $ch$-Funktionssymbol
dargestellt werden. Die Variablen $x_i,y_i$ haben die Sorte $V$ und 
$e,d$ sind Variablen der Sorte $U$. 
\[\setf{b(x_2,x_1),b(x_3,x_2),b(x_4,x_3)|e} \ue
  \setf{b(y_2,y_1),b(y_3,y_2),b(y_4,y_3)|d} \]
Unifiziere folgendermaßen (über Kreuz): 
\[\begin{array}{l}
\set{b(x_2,x_1) \ue b(y_3,y_2),b(x_3,x_2) \ue b(y_2,y_1), \\
      \wklammer e \ue \setf{b(y_4,y_3)|N}, d \ue \setf{b(x_4,x_3)|N}} \end{array}\]
Die Anwendung von \emph{Decomposition}- und \emph{Variable Elimination}-Transformationen 
resultiert in der Substitution $\sigma$:
\[\sigma =\set{x_1 \mapsto y_2,
               x_2 \mapsto y_1,
	       x_3 \mapsto y_2,
	       y_3 \mapsto y_1,
	       e \mapsto \setf{b(y_4,y_1)|N},
	       d \mapsto \setf{b(x_4,y_2)|N}}\]
Die Anwendung der Substitution $\sigma$ auf einen der beiden Ausgangsterme
\[\sigma(\setf{b(x_2,x_1),b(x_3,x_2),b(x_4,x_3)|e}) =
  \setf{b(y_1,y_2),b(y_2,y_1),b(x_4,y_2),b(y_4,y_1)|N} \]
ergibt eine Umgebung, mit einer Schleife in der Variablenkette, 
%durch die beiden Bindungen $b(y_1,y_2),b(y_2,y_1)$, 
die dazu führt,
dass eine Redex-Suche, die über die Variablenketten läuft, für diesen
Term nicht terminiert:  
Wir betrachten den Resultatterm in $\Lambda^{let}$\footnote{Die
  Abbildung $\transl{\;}^-$ übersetzt einen Term aus $\sigmaLet$ nach
  $\Lambda^{let}$.}
\[\transl{\setf{b(y_1,y_2),b(y_2,y_1),b(x_4,y_2),b(y_4,y_1)|N}}^- =
\set{y_1=y_2,y_2=y_1,x_4=y_2,y_4=y_1|N}\]
und nehmen an, dass der Unwind Algorithmus zur Redex-Suche (aus Definition \ref{def:unwind})
die rechte Seite einer Bindung markiert hat:
\[\begin{array}{rl}
& \set{y_1=y_2,y_2=y_1,x_4=y_2,y_4=y_1^S|N} \\
\xrightarrow{Unwind} & \set{y_1=y_2^S,y_2=y_1,x_4=y_2,y_4=y_1^W|N} \\
\xrightarrow{Unwind} & \set{y_1=y_2^W,y_2=y_1^S,x_4=y_2,y_4=y_1^W|N} \\
\end{array}\]
In der letzten Zeile versucht Unwind die rechte Seite der Bindung 
$y_1 = y_2^W$ zu markieren, die bereits mit $W$ markiert ist. 
Dabei bricht der Algorithmus mit einem Fehler ab. 
\end{beispiel}

\sloppy
Generell kommt es zur Schleifenbildung innerhalb einer
Variablenkette, die aus der Unifikation zweier Variablenketten
$ch(b(x_{m},x_{m-1}),b(x_{n},x_{n-1}))$ und
$ch(b(y_{m'},y_{m'-1}),b(y_{n'},y_{n'-1}))$ resultiert, wenn
(mindestens) vier Bindungen 
folgendermaßen unifiziert werden: $b(x_{i},x_{i-1}) \ue b(y_{i'},y_{i'-1})$ und
$b(x_{j},x_{j-1}) \ue b(y_{j'},y_{j'-1})$ für $i < j, j' < i'$, wie in folgender 
Abbildung zu sehen:

\[\xymatrix@C=0.5cm{
b(x_{m},x_{m-1}) & \dots & b(x_{i},x_{i-1}) \ar@{-}[drr]^{\ue} & \dots & b(x_{j},x_{j-1}) \ar@{-}[dll]^{\ue} & \dots & b(x_{n},x_{n-1}) \\
b(y_{m'},y_{m'-1}) & \dots & b(y_{j'},y_{j'-1}) & \dots & b(y_{i'},y_{i'-1}) & \dots & b(y_{n'},y_{n'-1}) \\
}\]

Diese Art der Unifikation von Variablenkettenbindungen untereinander
bezeichnen wir als Kreuzunifikation.
Bei der Unifikation von Umgebungen mit Variablenketten werden alle Fälle
ausgeschlossen, bei denen einzelne Bindungen der Ketten miteinander
kreuz-unifiziert werden.

Das zweite Kriterium, das verwendet wird, um bestimmte
Unifikationsmöglichkeiten von Kettenbindungen untereinander
auszuschließen, benutzt die Tatsache, dass
Variablenketten Bestandteile von \texttt{letrec}-Umgebungen sind.
D.h. für sie muss nach der Syntaxdefinition von $\Lambda^{let}$
gelten, dass alle in Kettenbindungen auf der linken Seite 
vorkommenden Variablen sowie alle anderen in der Umgebung auf
linken Seiten von Bindungen vorkommenden Variablen paarweise disjunkt sind. 
Die Forderung, dass alle Binder einer \letr-Umgebung verschiedene
Namen haben, wird bei der Syntaxdefinition des 
Ursprungskalküls aufgestellt. Sie stellt sicher, dass von der
Normalordnung ein eindeutiger Redex gefunden werden kann. 
Die Unifikation von Umgebungen mit Variablenketten kann diese
Bedingung für zu unifizierende Termen verletzen, da sie als Ziel hat,
Terme syntaktisch gleich zu 
machen, und nicht auf syntaktische Nebenbedingungen des Kalküls achtet. 
Terme, die nach der Unifikation syntaktisch gleich sind, aber 
nicht der Disjunktheitsanforderung der Variablen in \letr-Umgebungen
genügen, sind nicht von Interesse, da sie i.A. keinen eindeutigen
Normalordnungsredex besitzen. 

\begin{definition}%[Syntaktisch korrekte \texttt{letrec}-Umgebungen]
\label{def:syntaktisch-korrekte-umg}
Sei
\[\begin{array}{l}
\setf{b(x_1,s_1),\dots, b(x_l,s_l), \\
  \phantom{\{}ch(b(y_{m_1},y_{{(m_1-1)}}),b(y_{n_1},y_{{(n_1-1)}})),\dots,ch(b(y_{m_k},y_{{(m_k-1)}}),b(y_{n_k},y_{{(n_k-1)}}))|e} \\
\end{array}\]
eine \letr-Umgebung, wobei $e$ eine
Variable der Sorte $U$ oder $\emptyset$ ist. 
Die Umgebung wird als \emph{syntaktisch korrekt} bezeichnet, wenn 
alle $x_i, y_{m_j}, y_{n_j}$ für $1 \leq i \leq l, 1 \leq j \leq k$ 
paarweise disjunkt sind. 
Ist eine \letr-Umgebung nicht syntaktisch korrekt, sprechen wir davon,
dass sie einen \emph{syntaktischen Fehler} enthält. 
\end{definition}

\begin{lemma}
\label{lem.mittelstaendige}
Es seien zwei Umgebungen $\setf{ch(b(x_m,x_{m-1}),b(x_n,x_{n-1}))|e}$ und
$\setf{ch(b(y_{m'},y_{m'-1}),b(y_{n'},y_{n'-1}))|d}$, 
wobei $e,d$ Variablen der Sorte $U$ sind, sowie
beliebige Bindungen der Variablenketten 
$b(x_{i},x_{i-1}) \in ch(b(x_{m+1},x_{m}),b(x_n,x_{n-1}))$ und  
$b(y_{i'},y_{i'-1}) \in ch(b(y_{m'+1},y_{m'}),b(y_{n'},y_{n'-1}))$
ungleich der Anfangsbindung der jeweiligen Kette gegeben. Sei außerdem 
\[\begin{array}{lll}
\sigma = \set{ & x_{i} \mapsto y_{i'}, x_{i-1} \mapsto y_{i'-1}, & \\
               & d \mapsto \setf{ch(b(x_m,x_{m-1}),b(x_{i-1},x_{i-2})),ch(b(x_{i+1},x_{i}),b(x_n,x_{n-1}))|N}, & \\                  
               & e \mapsto \setf{ch(b(y_{m'},y_{m'-1},b(y_{i'-1},y_{i'-2})),ch(b(y_{i'+1},y_{i'}),b(y_{n'},y_{n'-1}))|N} & }\\
\end{array}\]
die Substitution (wobei $N$ eine neue Variablen der Sorte $U$ ist), die durch die Unifikation von 
\[\begin{array}{l}
\set{ b(x_{i},x_{i-1}) \ue b(y_{i'},y_{i'-1}), \\ 
\phantom{\{} \setf{ch(b(x_m,x_{m-1}),b(x_{i-1},     x_{i-2})),ch(b(x_{i+1},x_{i}),   b(x_n,x_{n-1}))|e} \ue \\
\phantom{\{} \setf{ch(b(y_{m'},y_{m'-1},b(y_{i'-1},y_{i'-2})),ch(b(y_{i'+1},y_{i'}),b(y_{n'},y_{n'-1}))|d} }
\end{array}\] 
entsteht. 
Dann sind $\sigma(\setf{ch(b(x_m,x_{m-1}),b(x_n,x_{n-1}))|e})$ und 
$\sigma(\setf{ch(b(y_{m'},y_{m'-1}),b(y_{n'},y_{n'-1}))|d})$ 
keine syntaktisch korrekten \letr-Umgebungen.
\end{lemma}
\begin{beweis} Durch Anwenden der Substitution $\sigma$:
\[\begin{array}{rl}
%\sigma(\setf{ch(b(x_m,x_{m-1}),b(x_n,x_{n-1}))|e}) = \\
%\setf{\sigma(ch(b(x_m,x_{m-1}),b(x_n,x_{n-1}))),\sigma(ch(b(y_{m'},y_{m'-1},b(y_{i'-1},y_{i'-2}))),\sigma(ch(b(y_{i'+1},y_{i'})),b(y_{n'},y_{n'-1}))|N} \\
& \sigma(\setf{ch(b(y_{m'},y_{m'-1}),b(y_{n'},y_{n'-1}))|d}) \\
= & \setf{\sigma(ch(b(y_{m'},y_{m'-1}),b(y_{n'},y_{n'-1})))|\sigma(d)}) \\
= & \setf{\sigma(ch(b(y_{m'},y_{m'-1}),b(y_{n'},y_{n'-1}))),\\
&  \phantom{\{\!|}\sigma(ch(b(x_m,x_{m-1}),b(x_{i-1},x_{i-2}))),\sigma(ch(b(x_{i+1},x_{i}),b(x_n,x_{n-1})))|N} \\
= & \setf{ch(\sigma(b(y_{m'},y_{m'-1})),\sigma(b(y_{n'},y_{n'-1}))),\\
&  \phantom{\{\!|}ch(\sigma(b(x_m,x_{m-1})),\sigma(b(x_{i-1},x_{i-2}))),ch(\sigma(b(x_{i+1},x_{i})),\sigma(b(x_n,x_{n-1})))|N} \\
= & \setf{ch(b(\sigma(y_{m'}),\sigma(y_{m'-1})),b(\sigma(y_{n'}),\sigma(y_{n'-1}))),\\
&  \phantom{\{\!|}ch(b(\sigma(x_m),\sigma(x_{m-1})),b(\sigma(x_{i-1}),\sigma(x_{i-2}))),\\
& \phantom{\{\!|}ch(b(\sigma(x_{i+1}),\sigma(x_{i})),b(\sigma(x_n),\sigma(x_{n-1})))|N} \\
= & \setf{ch(b(y_{m'},y_{m'-1}),b(y_{n'},y_{n'-1})),\\
&  \phantom{\{\!|}ch(b(x_m,x_{m-1}),\underline{b(y_{i'-1},x_{i-2})}),ch(b(x_{i+1},x_{i}),b(x_n,x_{n-1}))|N} \\
\end{array}\]

Im resultierenden Term in der letzten Zeile sind die
Bindungen $b(y_{i'-1},x_{i-2})$ und $b(y_{i'-1},y_{i'-2})$ (in der Variablenkette
$ch(b(y_{m'},y_{m'-1}),b(y_{n'},y_{n'-1}))$\footnote{Die Bindung
    $b(y_{i'-1},y_{i'-2})$ ist im resultierenden Term nicht unmittelbar
    sichtbar. Sie wird dies aber, wenn die Aufspaltung der
    Variablenkette $ch(b(y_{m'},y_{m'-1}),b(y_{n'},y_{n'-1}))$ zu 
    $ch(b(y_{m'},y_{m'-1},b(y_{i'-1},y_{i'-2})),b(y_{i'},y_{i'-1}),ch(b(y_{i'+1},y_{i'}),b(y_{n'},y_{n'-1}))$ 
    nachvollzogen wird.}) enthalten. 
D.h. in der \letr-Umgebung kommt zweimal 
die Variable $y_{i'-1}$ vor und 
deshalb ist die Umgebung nicht syntaktisch korrekt. $\qed$
\end{beweis}

Das Lemma zeigt, dass bestimmte Arten der Unifikation von
Variablenkettenbindungen untereinander in Unifikatoren resultieren, die
die Variablenketten zwar syntaktisch gleich machen, aber gleichzeitig
einen syntaktischen Fehler in die Umgebungen einführen, in denen die
Variablenketten enthalten sind. 
Das folgende Beispiel illustriert weitere Fälle, durch die
syntaktische Fehler bei der Unifikation eingeführt werden können. 

\begin{beispiel}
\label{bsp:syntaktische-Fehler}
Wir betrachten ein Unifikationsproblem zwischen \letr-Umgebungen mit
konkreten Variablenketten  
\[\setf{b(x_2,x_1),b(x_3,x_2),b(x_4,x_3)|e} \ue 
\setf{b(y_2,y_1),b(y_3,y_2),b(y_4,y_3),b(y_5,y_4)|d}\] 
mit den Variablensorten $x_i,y_i:V$ und $e,d:U$. 
Die Bindungen der Variablenketten werden nach folgendem Schema unifiziert: 
\[\xymatrix@C=0.5cm@R=1cm{
& \setf{ b(x_2,x_1), \ar@{-}[drrr] & b(x_3,x_2), \ar@{-}[d] & b(x_4,x_3) \ar@{-}[d] &| e } \\
\setf{b(y_2,y_1), \ar@{-}[urrrr] & b(y_3,y_2), \ar@{-}[urrr] & b(y_4,y_3), & b(y_5,y_4) &| d} \\
}\]
Daraus ergibt sich die Substitution 
\[\sigma =\set{x_2 \mapsto y_3,
               x_3 \mapsto y_4,
	       x_4 \mapsto y_5,
	       e \mapsto \setf{b(y_2,y_1),b(y_3,y_2)|N},
	       d \mapsto \setf{b(y_3,x_1)|N}}.\]
Die Anwendung dieser Substitution auf einen der Ausgangsterme resultiert
in einer Umgebung, die nicht syntaktisch korrekt ist:
\[\begin{array}{rl}
& \sigma(\setf{b(x_2,x_1),b(x_3,x_2),b(x_4,x_3)|e}) \\
= & \setf{\underline{b(y_3,x_1)},b(y_4,y_3),b(y_5,y_4),b(y_2,y_1),\underline{b(y_3,y_2)}|N}
\end{array}\]

Die Einführung eines syntaktischen Fehlers durch die Substitution
kann vermieden werden, indem mindestens eine 
Anfangsbindung einer der beiden Variablenketten unifiziert wird. 
Beispielsweise ergibt die Unifikation nach dem Schema
\[\xymatrix@C=0.5cm@R=1cm{
& \setf{ b(x_2,x_1), \ar@{-}[d] & b(x_3,x_2), \ar@{-}[d] & b(x_4,x_3) \ar@{-}[d] &| e } \\
\setf{b(y_2,y_1), \ar@{-}[urrrr] & b(y_3,y_2), & b(y_4,y_3), & b(y_5,y_4) &| d} \\
}\]
die Substitution 
\[\sigma =\set{x_1 \mapsto y_2,
               x_2 \mapsto y_3,
               x_3 \mapsto y_4,
	       x_4 \mapsto y_5, 
	       e \mapsto \setf{b(y_2,y_1)|N}},\]
die keinen syntaktischen Fehler in die substituierte \letr-Umgebung einführt:
\[\begin{array}{rl}
& \sigma(\setf{b(x_2,x_1),b(x_3,x_2),b(x_4,x_3)|e}) \\
= & \setf{b(y_3,y_2),b(y_4,y_3),b(y_5,y_4),b(y_2,y_1)|N}. \\
\end{array}\]

Um die Einführung eines syntaktischen Fehlers durch einen Unifikator
zu vermeiden, müssen die Bindungen einer Variablenkette außerdem 
durchgehend linearen unifiziert werden. 
Beispielsweise resultiert die Unifikation nach dem Schema
\[\xymatrix@C=0.5cm@R=1cm{
& \setf{ b(x_2,x_1), \ar@{-}[d] & b(x_3,x_2), \ar@{-}[drr] & b(x_4,x_3) \ar@{-}[d] &| e } \\
\setf{b(y_2,y_1), \ar@{-}[urrrr] & b(y_3,y_2), & b(y_4,y_3), \ar@{-}[urr] & b(y_5,y_4) &| d}, \\
}\]
in der Substitution 
\[\begin{array}{l}
\sigma =\set{x_1 \mapsto y_2,
               x_2 \mapsto y_3,
               x_3 \mapsto y_4,
	       x_4 \mapsto y_5, \\
\phantom{\sigma = \{} e \mapsto \setf{b(y_2,y_1),b(y_4,y_3)|N},
                        d \mapsto \setf{b(y_4,y_3)|N}}. \end{array}\]
die einen syntaktischen Fehler in die Umgebung einführt
\[\begin{array}{rl}
& \sigma(\setf{b(x_2,x_1),b(x_3,x_2),b(x_4,x_3)|e}) \\
= & \setf{b(y_3,y_2),\underline{b(y_4,y_3)},b(y_5,y_4),b(y_2,y_1),\underline{b(y_4,y_3)}|N}. \\
\end{array}\]
\end{beispiel}

Folgende Bedingungen lassen sich aus dem Verbot der Kreuzunifikation 
(Beispiel \ref{bsp:kreuzunifikation}) Lemma \ref{lem.mittelstaendige}
und Beispiel \ref{bsp:syntaktische-Fehler} für die Unifikation von
Umgebungen mit Variablenketten ableiten: Es sollen zwei Umgebungen 
$\setf{ch(b(x_m,x_{m-1}),b(x_n,x_{n-1}))|e}$ und 
$\setf{ch(b(y_{m'},y_{m'-1}),b(y_{n'},y_{n'-1}))|d}$,
die jeweils eine Variablenkette enthalten, unifiziert werden. 
Es gilt entweder:
\begin{enumerate}
\item Beide Variablenketten werden jeweils mit den 
  gegenüberliegenden Umgebungsvariablen $e$ bzw. $d$ unifiziert.
\item Oder: Wird eine Kettenbindung 
  $b(x_i,x_{i-1}) \in ch(b(x_m,x_{m-1}),b(x_n,x_{n-1}))$ mit einer
  anderen Kettenbindung  $b(y_{i'},y_{i'-1}) \in ch(b(y_{m'},y_{m'-1}),b(y_{n'},y_{n'-1}))$
  unifiziert, so müssen die jeweiligen Vorgängerbindungen (falls diese
  existieren) ebenfalls miteinander unifiziert werden:
  \[b(x_i,x_{i-1}) \ue b(y_{i'},y_{i'-1}) \Rightarrow b(x_{i-1},x_{i-2}) \ue b(y_{i'-1},y_{i'-2}).\]
  Dies geschieht solange, bis die Anfangsbindung einer der beiden
  Ketten  erreicht ist. D.h. mindestens eine Anfangsbindung 
  ist in diesem Fall an der Unifikation der Variablenkettenbindungen
  beteiligt, wie in folgender Abbildung schematisch zu sehen ist:
\[\newcommand{\due}{\ar@{-}[d]|{\ue}}
\xymatrix@=0.5cm{
&       & b(x_m,x_{m-1}) \due & \dots \due &  b(x_i,x_{i-1}) \due & \dots \\
b(y_{m'},y_{m'-1}) & \dots & b(y_{j'},y_{j'-1})   & \dots      &  b(y_{i'},y_{i'-1})   & \dots \\
}\]
bzw. 
\[\newcommand{\due}{\ar@{-}[d]|{\ue}}
\xymatrix@=0.5cm{
b(x_m,x_{m-1}) & \dots  & b(x_j,x_{j-1}) \due & \dots \due &  b(x_i,x_{i-1}) \due & \dots \\
&    & b(y_{m'},y_{m'-1})   & \dots      &  b(y_{i'},y_{i'-1})   & \dots \\
}\]
\end{enumerate}

Werden die beiden Variablenketten der Umgebungen so unifiziert, 
dass keine der beiden Bedingungen gilt, ist das Resultat ein
Unifikator $\sigma$, der einen syntaktischen Fehler in die beiden
Umgebungen einführt. 

Aus diesen Überlegungen ergeben sich 13 Möglichkeiten,
zwei Umgebungen 
$\setf{ch(b(x_m,x_{m-1}),b(x_n,x_{n-1}))|e}$ und 
$\setf{ch(b(y_{m'},y_{m'-1}),b(y_{n'},y_{n'-1}))|d}$
mit Variablenketten, die keine 
weiteren Bindungen enthalten, zu unifizieren. Dazu werden die
Variablenketten in Teilketten zerlegt. 

\begin{definition}%[uni regeln ketten ketten]
\label{def:uni-regeln-ketten-ketten}
Wir erweitern die Unifikationsregeln aus Definition
\ref{def:uni-regel-ketten} um die Regeln aus 
Abbildung \ref{fig:regel-ketten-ketten-1} und 
Abbildung \ref{fig:regel-ketten-ketten-2} zur Unifikation von 
Gleichungen der Form 
\[\setf{ch(b(x_m,x_{m-1}),b(x_n,x_{n-1}))|e} \ue 
\setf{ch(b(y_{m'},y_{m'-1}),b(y_{n'},y_{n'-1}))|d},\]
wobei $e,d$ Variablen der Sorte $U$ sind. 

Die Aufteilung der Ketten bei der Anwendung einer bestimmten
Transformationsmöglichkeit, muss man sich zusammen mit den
verwendeten neuen Variablen merken, damit die substituierten Terme
syntaktisch gleich sind (siehe dazu auch Definition
\ref{def:uni-regel-ketten} sowie die Beispiele \ref{bsp:lp-ketten} und
\ref{bsp:mehr-syntaktische-fehler}). 
\end{definition}

\begin{figure}[ht]
\fbox{
\begin{minipage}{0.98\textwidth}
\[\begin{array}{l}
\multicolumn{1}{l}{\mathbf{Unify-CH-KMB}} \\ %\footnote{Der Suffix \emph{KMB} im Namen der Regel stehe für: Keine Markierung in beiden Ketten}.
\set{\setf{ch(b(x_m,x_{m-1}),b(x_n,x_{n-1}))|e} \ue \setf{ch(b(y_{m'},y_{m'-1}),b(y_{n'},y_{n'-1}))|d}} \uplus P 
\Rightarrow \\
  \begin{array}[t]{rl} 
    i)& \set{ch(b(x_m,x_{m-1}),b(x_n,x_{n-1})) \ue  ch(b(y_{m'},y_{m'-1}),b(y_{n'},y_{n'-1})), e \ue d} \cup P \\
    ii)& \set{d \ue \setf{ch(b(x_m,x_{m-1}),b(x_n,x_{n-1}))|N}, \\
       & \phantom{\{} e \ue \setf{ch(b(y_{m'},y_{m'-1}),b(y_{n'},y_{n'-1}))|N}} \cup P  \\
    iii)& \set{ch(b(x_{m},x_{m-1}),b(z_2,z_1)) \ue ch(b(y_{m'},y_{m'-1}),b(z'_2,z'_1)), \\ %v
       & \phantom{\{} d \ue \setf{ch(b(z_3,z_2),b(x_{n},x_{n-1}))|N}, \\ 
       & \phantom{\{} e \ue \setf{ch(b(z'_3,z'_2),b(y_{n'},y_{n'-1}))|N}} \cup P  \\
    iv)& \set{ch(b(x_{m},x_{m-1}),b(z_2,z_1)) \ue ch(b(y_{m'},y_{m'-1}),b(y_{n'},y_{n'-1})), \\ %viii
       & \phantom{\{} d \ue \setf{ch(b(z_3,z_2),b(x_{n},x_{n-1}))|e}} \cup P \\ 
    v)& \set{ch(b(x_{m},x_{m-1}),b(x_{n},x_{n-1})) \ue ch(b(y_{m'},y_{m'-1}),b(z'_2,z'_1)), \\ %ix
       & \phantom{\{} e \ue \setf{ch(b(z'_3,z'_2),b(y_{n'},y_{n'-1}))|d}} \cup P \\ 
  \end{array} \\
    {\quad\text{Für alle Transformationsmöglichkeiten muss gelten:}} \\
    {\quad\text{Nicht beide Variablenketten sind mit $M$ markiert.}} \\
    {\quad\text{$z_i,z'_i, 1 \leq i \leq 3$ sind jeweils neue Variablen der Sorte $V$}} \\
    {\quad\text{und $N$ ist eine neue Variable der Sorte $U$.}} \\

%\quad \text{Für alle Transformationsmöglichkeiten sind  $z_i,z'_i, 1 \leq i \leq 6$ } \\
%\quad \text{jeweils neue Varialen der Sorte $V$ und $N$ ist eine neue Variable der Sorte $U$.} \\
\end{array}\]
\end{minipage}}
\caption{Unifikationsregeln für \letr-Umgebungen mit jeweils
    eine Variablenkette pro Umgebung (Teil 1). \label{fig:regel-ketten-ketten-1}}
\end{figure}

\begin{figure}[p]
\fbox{
\begin{minipage}{0.98\textwidth}
\[\begin{array}{l}
\multicolumn{1}{l}{\mathbf{Unify-CH-KMR}} \\ %\footnote{\emph{KMR} steht für: Keine Markierung der Kette auf der rechten Seit der Unifikationsgleichung.}
\set{\setf{ch(b(x_m,x_{m-1}),b(x_n,x_{n-1}))|e} \ue \setf{ch(b(y_{m'},y_{m'-1}),b(y_{n'},y_{n'-1}))|d}} \uplus P 
\Rightarrow \\
  \begin{array}[t]{rl}
    i)& \set{ch(b(z_3,z_2),b(x_{n},x_{n-1})) \ue ch(b(y_{m'},y_{m'-1}),b(z'_2,z'_1)), \\ %iii
       & \phantom{\{} d \ue \setf{ch(b(x_m,x_{m-1}),b(z_2,z_1))|N}, \\ 
       & \phantom{\{} e \ue \setf{ch(b(z'_3,z'_2),b(y_{m'},y_{m'-1}))|N}} \cup P  \\
    ii)& \set{ch(b(z_3,z_2),b(z_5,z_4)) \ue ch(b(y_{m'},y_{m'-1}),b(z'_2,z'_1)), \\ %vi
       & \phantom{\{} d \ue \setf{ch(b(x_{m},x_{m-1}),b(z_2,z_1)),ch(b(z_6,z_5),b(x_{n},x_{n-1}))|N}, \\ 
       & \phantom{\{} e \ue \setf{ch(b(z'_3,z'_2),b(y_{n'},y_{n'-1}))|N}} \cup P  \\
    iii)& \set{ch(b(z_3,z_2),b(z_5,z_4)) \ue ch(b(y_{m'},y_{m'-1}),b(y_{n'},y_{n'-1})), \\ %x
       & \phantom{\{} d \ue \setf{ch(b(x_{m},x_{m-1}),b(z_2,z_1)),ch(b(z_6,z_5),b(x_{n},x_{n-1}))|e}} \cup P  \\
    iv)& \set{ch(b(z_3,z_2),b(x_{n},x_{n-1})) \ue ch(b(y_{m'},y_{m'-1}),b(y_{n'},y_{n'-1})), \\ %xii
       & \phantom{\{} d \ue \setf{ch(b(x_{m},x_{m-1}),b(z_2,z_1))|e}} \cup P  \\
  \end{array}\\
    {\quad\text{Für alle Transformationsmöglichkeiten muss gelten:}} \\
    {\quad\text{Die Variablenkette $ch(b(y_{m'},y_{m'-1}),b(y_{n'},y_{n'-1}))$ ist nicht mit $M$ markiert.}} \\
    {\quad\text{$z_i,z'_i, 1 \leq i \leq 6$ sind jeweils neue Variablen der Sorte $V$}} \\
    {\quad\text{und $N$ ist eine neue Variable der Sorte $U$.}} \\
\multicolumn{1}{l}{\mathbf{Unify-CH-KML}} \\ %\footnote{\emph{KML} steht für: Keine Markierung der Kette auf der linken Seit der Unifikationsgleichung.}
\set{\setf{ch(b(x_m,x_{m-1}),b(x_n,x_{n-1}))|e} \ue \setf{ch(b(y_{m'},y_{m'-1}),b(y_{n'},y_{n'-1}))|d}} \uplus P 
\Rightarrow \\
  \begin{array}[t]{rl}
    i)& \set{ch(b(x_{m},x_{m-1}),b(z_2,z_1)) \ue ch(b(z'_3,z'_2),b(y_{n'},y_{n'-1})), \\ %iv
       & \phantom{\{} d \ue \setf{ch(b(z_3,z_2),b(x_{n},x_{n-1}))|N}, \\ 
       & \phantom{\{} e \ue \setf{ch(b(y_{m'},y_{m'-1}),b(z'_2,z'_1))|N}} \cup P  \\
    ii)& \set{ch(b(x_{m},x_{m-1}),b(z_2,z_1)) \ue ch(b(z'_3,z'_2),b(z'_5,z'_4)), \\ %vii
       & \phantom{\{} d \ue \setf{ch(b(z_3,z_2),b(x_{n},x_{n-1}))|N}, \\ 
       & \phantom{\{} e \ue \setf{ch(b(y_{m'},y_{m'-1}),b(z'_2,z'_1)),ch(b(z'_6,z'_5),b(y_{n'},y_{n'-1}))|N}} \cup P  \\
    iii)& \set{ch(b(x_{m},x_{m-1}),b(x_{n},x_{n-1})) \ue ch(b(z'_3,z'_2),b(z'_5,z'_4)), \\ %xi
       & \phantom{\{} e \ue \setf{ch(b(y_{m'},y_{m'-1}),b(z'_2,z'_1)),ch(b(z'_6,z'_5),b(y_{n'},y_{n'-1}))|d}} \cup P  \\
    iv)& \set{ch(b(x_{m},x_{m-1}),b(x_{n},x_{n-1})) \ue ch(b(z'_3,z'_2),b(y_{n'},y_{n'-1})), \\ %xiii
       & \phantom{\{} e \ue \setf{ch(b(y_{m'},y_{m'-1}),b(z'_2,z'_1))|d}} \cup P  \\
  \end{array}\\
    {\quad\text{Für alle Transformationsmöglichkeiten muss gelten:}} \\
    {\quad\text{Die Variablenkette $ch(b(x_m,x_{m-1}),b(x_n,x_{n-1}))$ ist nicht mit $M$ markiert.}} \\
    {\quad\text{$z_i,z'_i, 1 \leq i \leq 6$ sind jeweils neue Variablen der Sorte $V$}} \\
    {\quad\text{und $N$ ist eine neue Variable der Sorte $U$.}} \\
\end{array}\]
\end{minipage}}
\caption{Unifikationsregeln für \letr-Umgebungen mit jeweils
    einer Variablenkette pro Umgebung (Teil 2). \label{fig:regel-ketten-ketten-2}}
\end{figure}

Die Markierung $M$ wird verwendet, um bestimmte
Unifikationsmöglichkeiten auszuschließen, durch die Unifikatoren
berechnet werden, die syntaktische Fehler in die zu unifizierenden
Umgebungen einführen. 
Da nach unseren Überlegungen immer die Anfangsbindung einer der
beiden Variablenketten an der Unifikation beteiligt sein muss, werden
die Fälle von der Unifikation ausgeschlossen, bei denen mit der
Anfangsbindung einer Kette unifiziert wird, die mit $M$ markiert ist,
d.h. diese Kette enthält nicht mehr die Anfangsbindung der
ursprünglichen Ketten. Weshalb es in diesen Fällen zu der
Einführung eines syntaktischen Fehlers durch die berechnete
Unifikation kommt, ist in Beispiel \ref{bsp:mehr-syntaktische-fehler}
erläutert. 

Die Transformationsmöglichkeiten für Unifikationsgleichungen der
Form 
$\setf{ch(b(x_m,x_{m-1}),b(x_n,x_{n-1}))|e} \ue \setf{ch(b(y_{m'},y_{m'-1}),b(y_{n'},y_{n'-1}))|d}$
aus Definition \ref{def:uni-regeln-ketten-ketten}
können durch Diagramme veranschaulicht werden. 
Dabei entspricht die Abbildung
\[\xymatrix@C=0.07cm@R=0.4cm{
b(x_{m},x_{m-1})\ar@{|-}[rr] & & b(z_2,z_1) & b(z_3,z_2)\ar@{-}[rr] & & b(z_5,z_4) & b(z_6,z_5)\ar@{->}[rr] & & b(x_{n},x_{n-1})
}\]
der Variablenkette $ch(b(x_m,x_{m-1}),b(x_n,x_{n-1}))$,
die in 3 Teilketten zerlegt wurde:
Das Anfangsstück der Kette ist $ch(b(x_m,x_{m-1}),b(z_2,z_1))$, 
das in der Abbildung durch den Pfeil $\xymatrix@C=0.32cm{\ar@{|-}[r]& }$ 
zwischen Anfangs- und Endbindung der Teilkette gekennzeichnet ist. 
Das Mittelstück der Kette ist $ch(b(z_3,z_2),b(z_5,z_4))$.
Die Anfangs- und Endbindung dieser Teilkette sind durch einen einfachen 
Strich $\xymatrix@C=0.32cm{\ar@{-}[r]& }$ verbunden. 
Das Endstück der Kette ist $ch(b(z_6,z_5),b(x_{n},x_{n-1}))$.
Hier sind Anfangs- und Endbindung durch den Pfeil $\xymatrix@C=0.32cm{\ar@{->}[r]& }$  
verbunden. Das Diagramm  
\[\xymatrix@C=0.07cm@R=0.6cm{
b(x_{m},x_{m-1}) \ar@{|-}[rr] & & b(z_2,z_1) & b(z_3,z_2) \aue{d}{\ue} \ar@{-}[rr] & & b(z_5,z_4) \aue{d}{\ue} & 
    b(z_6,z_5) \ar@{->}[rr]        & & b(x_{n},x_{n-1}) \\ 
& & & b(y_{m'},y_{m'-1}) \ar@{|-}[rr] & & b(z'_2,z'_1) & b(z'_3,z'_2) \ar@{->}[rr] & & d(y_{n'},y_{n'-1}) 
}\]
symbolisiert dann die Transformationsmöglichkeiten $vi)$ aus Definition
\ref{def:uni-regeln-ketten-ketten}, bei der die Teilketten 
$ch(b(z_3,z_2),b(z_5,z_4))$ und
$ch(b(y_{m'},y_{m'-1}),b(z'_2,z'_1))$
miteinander und die restlichen Teilketten mit der
Umgebungsvariablen der gegenüberliegenden Umgebung unifiziert
werden. Wir geben die entsprechenden Diagramme für die einzelnen 
Transformationsmöglichkeiten der Regel aus Definition
\ref{def:uni-regeln-ketten-ketten} an.

\paragraph{\emph{Unify-CH-KMB}}
Die Diagramme, die die einzelnen Transformationsmöglichkeiten der Regel 
\emph{Unify-CH-KMB} beschreiben, sind:

\renewcommand{\labelenumi}{\roman{enumi})}
\begin{enumerate}
\item %1
$\xymatrix@C=0.14cm@R=0.6cm{
b(x_m,x_{m-1}) \aue{d}{\ue} \ar@{|->}[rr] & & b(x_n,x_{n-1}) \aue{d}{\ue} \\
b(y_{m'},y_{m'-1})           \ar@{|->}[rr] & & b(y_{n'},y_{n'-1})   \\ }$ 
\item %2
$\xymatrix@C=0.14cm@R=0.2cm{
b(x_m,x_{m-1}) \ar@{|->}[rr] & & b(x_n,x_{n-1}) & & & \\
                    & &        & b(y_{m'},y_{m'-1}) \ar@{|->}[rr] & &
b(y_{n'},y_{n'-1}) \\} $ 
\item %5
$\xymatrix@C=0.07cm@R=0.6cm{
b(x_m,x_{m-1}) \aue{d}{\ue} \ar@{|-}[rr] & & b(z_2,z_1) \aue{d}{\ue} & b(z_3,z_2)  \ar@{->}[rr] & & b(x_n,x_{n-1}) \\ 
b(y_{m'},y_{m'-1})  \ar@{|-}[rr]              & & b(z'_2,z'_1)             & b(z'_3,z'_2) \ar@{->}[rr] & & b(y_{n'},y_{n'-1}) 
%\save "1,4"."1,6"*[F.]\frm{}
%\ar"1,6" \ar"2,7" 
%\restore
%\save "2,4"."2,6"*[F.]\frm{}
%\ar"2,6" \ar"1,7" 
%\restore 
}$
\item %8
$\xymatrix@C=0.07cm@R=0.6cm{
b(x_m,x_{m-1}) \aue{d}{\ue} \ar@{|-}[rr] & & b(z_2,z_1) \aue{d}{\ue} & b(z_3,z_2) \ar@{->}[rr] & & b(x_n,x_{n-1}) \\  
b(y_{m'},y_{m'-1}) \ar@{|->}[rr]          & & b(y_{n'},y_{n'-1})             & & & \\}$ 
\item %9
$\xymatrix@C=0.07cm@R=0.6cm{
b(x_m,x_{m-1})   \aue{d}{\ue} \ar@{|->}[rr] & & b(x_n,x_{n-1}) \aue{d}{\ue} & & & \\
b(y_{m'},y_{m'-1})  \ar@{|-}[rr]               & & b(z'_2,z'_1) & b(z'_3,z'_2) \ar@{->}[rr] & & b(y_{n'},y_{n'-1}) \\ }$ 
\end{enumerate}

\paragraph{\emph{Unify-CH-KMR}}
Die Diagramme, die die einzelnen Transformationsmöglichkeiten der Regel 
\emph{Unify-CH-KMR} beschreiben, sind:

\begin{enumerate}
\item %3
$\xymatrix@C=0.07cm@R=0.6cm{
b(x_m,x_{m-1}) \ar@{|-}[rr] & & b(z_2,z_1) & b(z_3,z_2) \aue{d}{\ue} \ar@{->}[rr] & & b(x_n,x_{n-1}) \aue{d}{\ue} & & & \\
& & & b(y_{m'},y_{m'-1}) \ar@{|-}[rr]            & & b(z'_2,z'_1)   & b(z'_3,z'_2) \ar@{->}[rr] & & b(y_{n'},y_{n'-1}) \\ }$ 
\item %6
$\xymatrix@C=0.07cm@R=0.6cm{
b(x_m,x_{m-1}) \ar@{|-}[rr] & & b(z_2,z_1) & b(z_3,z_2) \aue{d}{\ue} \ar@{-}[rr] & & b(z_5,z_4) \aue{d}{\ue} & b(z_6,z_5) \ar@{->}[rr]        & & b(x_n,x_{n-1}) \\ 
& & & b(y_{m'},y_{m'-1}) \ar@{|-}[rr]  & & b(z'_2,z'_1)             & b(z'_3,z'_2) \ar@{->}[rr] & & b(y_{n'},y_{n'-1})  
%\save "1,1"."1,3"*[F]\frm{}
%\ar @{-} "2,2"
%\restore
%\save "1,7"."1,9"*[F.]\frm{}
%\ar @{-} "2,2" 
%\restore
%\save "2,7"."2,9"*[F.]\frm{}
%\ar @/_/ "1,10" 
%\restore 
}$
\item %10
$\xymatrix@C=0.07cm@R=0.6cm{
b(x_m,x_{m-1}) \ar@{|-}[rr] & & b(z_2,z_1) & b(z_3,z_2) \aue{d}{\ue} \ar@{-}[rr] & & b(z_5,z_4) \aue{d}{\ue} & b(z_6,z_5) \ar@{->}[rr]& & b(x_n,x_{n-1}) \\  
     & & & b(y_{m'},y_{m'-1}) \ar@{|->}[rr]          & & b(y_{n'},y_{n'-1})                        & & \\}$ 
\item %12
$\xymatrix@C=0.07cm@R=0.6cm{
b(x_m,x_{m-1}) \ar@{|-}[rr] & & b(z_2,z_1) & b(z_3,z_2)  \aue{d}{\ue} \ar@{->}[rr] & & b(x_n,x_{n-1}) \aue{d}{\ue} \\  
                               & & & b(y_{m'},y_{m'-1}) \ar@{|->}[rr]             & & b(y_{n'},y_{n'-1}) \\}$
\end{enumerate}

\paragraph{\emph{Unify-CH-KML}}
Die Diagramme, die die einzelnen Transformationsmöglichkeiten der Regel 
\emph{Unify-CH-KML} beschreiben, sind:

\begin{enumerate}
\item %4
$\xymatrix@C=0.07cm@R=0.6cm{
& & & b(x_m,x_{m-1}) \aue{d}{\ue} \ar@{-}[rr] & & b(z_2,z_1) \aue{d}{\ue} & b(z_3,z_2) \ar@{->}[rr] & & b(x_n,x_{n-1})   \\ 
b(y_{m'},y_{m'-1}) \ar@{|-}[rr] & & b(z'_2,z'_1) & b(z'_3,z'_2) \ar@{->}[rr]  & & b(y_{n'},y_{n'-1})               & & & \\}$ 
\item %7
$\xymatrix@C=0.07cm@R=0.6cm{
& & & b(x_m,x_{m-1}) \aue{d}{\ue} \ar@{|-}[rr] & & b(z_2,z_1) \aue{d}{\ue} & b(z_3,z_2) \ar@{->}[rr] & & b(x_n,x_{n-1}) \\  
b(y_{m'},y_{m'-1}) \ar@{|-}[rr] & & b(z'_2,z'_1) & b(z'_3,z'_2) \ar@{-}[rr] & & b(z'_5,z'_4) & b(z'_6,z'_5) \ar@{->}[rr]  & & b(y_{n'},y_{n'-1}) \\}$ 
\item %11
$\xymatrix@C=0.07cm@R=0.6cm{
& & & b(x_m,x_{m-1}) \aue{d}{\ue} \ar@{|->}[rr] & & b(x_n,x_{n-1} \aue{d}{\ue})  & & \\
b(y_{m'},y_{m'-1}) \ar@{|-}[rr] & & b(z'_2,z'_1) & b(z'_3,z'_2) \ar@{-}[rr]  & & b(z'_5,z'_4) & b(z'_6,z'_5) \ar@{->}[rr] & & b(y_{n'},y_{n'-1}) \\ }$
\item %13
$\xymatrix@C=0.07cm@R=0.6cm{
 & & & b(x_m,x_{m-1}) \aue{d}{\ue} \ar@{|->}[rr]  & & b(x_n,x_{n-1}) \aue{d}{\ue} \\
b(y_{m'},y_{m'-1})  \ar@{|-}[rr]  & & b(z'_2,z'_1) & b(z'_3,z'_2) \ar@{|->}[rr] & & b(y_{n'},y_{n'-1}) \\ }$ 
\end{enumerate}


Wir benötigen noch Regeln, um Gleichungen zwischen Umgebungen zu
unifizieren, die mehrere Variablenketten pro Umgebung enthalten, 
wobei alle vorkommenden Ketten durch die Aufspaltung einer
Ursprungskette (durch Anwendung von \emph{Split-X $iii)$})
entstanden sind. D.h. es müssen Gleichungen der Form 
\[\set{\setf{c_{1},\dots,c_{n} |e} \ue \setf{c'_{1},\dots, c'_{n'}|d}}\] 
unifiziert werden, wobei $c_i,c'_{i'}$ Variablenketten sind, von denen 
maximal eine Kette nicht mit $M$ markiert ist. Diese nicht markierte
Variablenkette enthält die Anfangsbindung der ursprünglichen 
Variablenkette. 
Durch die Aufspaltung der Variablenketten liegen die Teilketten in
einer Umgebung in der Form:
\[\xymatrix@C=0.5cm@R=0.6cm{
\ar@{|-}[rr]^{c_1} & & & \dots & & \ar@{-}[rr]^{c_i^M} & & & \dots & & \ar@{->}[rr]^{c_n^M}  & &  \\ }\]
linear hintereinander.
Eine Unifikation der Teilketten nach dem Schema
\[\xymatrix@C=0.5cm@R=0.6cm{
\ar@{-}[rr]^{c_i} & \aue{d}{\ue} &  & \ar@{-}[rr]^{c_{i+1}^M}  & \aue{d}{\ue} &  \\ 
 & \ar@{-}[rrr]^{c'_{i'}} & & & &  \\}\] 
wobei die Teilketten $c_i$ und $c'_{i'}$ mit $M$ markiert sein
können, ist nicht möglich, da durch die resultierende Substitution
ein syntaktischer Fehler in die Umgebungen eingeführt wird. 
Es werden also jeweils einzelne Teilketten miteinander unifiziert. 
Dabei darf immer nur höchstens eine Teilkette mit $M$ markiert sein. 

\begin{definition}
\label{def:uni-regeln-ketten-ketten-2}
Die Regeln zur Unifikation von Termen mit je einer Variablenkette pro
Umgebung aus Definition \ref{def:uni-regel-ketten} und Definition
\ref{def:uni-regeln-ketten-ketten} werden um die Regel  
aus Abbildung \ref{fig:regel-ketten-ketten-3} erweitert, um
Unifikationsgleichungen der Form 
\[\set{\setf{c_{1},\dots,c_{n} |e} \ue \setf{c'_{1},\dots, c'_{n'}|d}}\]
zu lösen. Dabei sind $c_i,c'_{i'}$ Variablenketten, die jeweils durch die
Anwendung von \emph{Split-X $iii)$} aus einer Ursprungskette
entstanden sind, und $e,d$ sind Variablen der Sorte $U$. 
\end{definition}

\begin{figure}[ht]
\fbox{
\begin{minipage}{0.98\textwidth}
\[\begin{array}{l}
\multicolumn{1}{l}{\mathbf{Unify-CHS}} \\
\set{\setf{c_1, \dots, c_n|e} \ue \setf{c'_1, \dots, c'_{n'}|d}} \uplus P 
\Rightarrow \\
  \begin{array}[t]{rl} 
    i)& \set{\setf{c_i|N_1} \ue \setf{c'_{i'}|N_2}, e \ue \setf{c'_1, \dots, c'_{i'-1}, c'_{i'+1}, \dots, c'_{n'}|N_1}, \\
      & \phantom{\{} d \ue \setf{c_1, \dots, c_{i-1},c_{i+1}\dots, c_n|N_2}} \cup P \\
    \multicolumn{2}{l}{\quad \text{wenn eine der beiden Variablenketten $c_i,c'_{i'}$ oder beide Ketten}} \\
    \multicolumn{2}{l}{\quad \text{nicht mit $M$ markiert sind. $N_1,N_2$ sind neue Variablen der Sorte $U$.}} \\
    ii)& \set{e \ue \setf{c'_1, \dots, c'_{n'}|N}, d \ue \setf{c_1, \dots, c_n|N}} \cup P \\
    \multicolumn{2}{l}{\quad \text{wenn alle Variablenketten $c_i,c'_{i'}$ mit $M$ markiert sind.}} \\
    \multicolumn{2}{l}{\quad \text{$N$ ist eine neue Variable der Sorte $U$.}} \\
%    ii)& \set{, \\
%       & \phantom{\{} } \cup P  \\
  \end{array}
\end{array}\]
\end{minipage}}
\caption{Unifikationsregel für \letr-Umgebungen mit mehreren 
    Teilketten pro Umgebung, die durch Aufspaltung einer
    Ursprungskette entstanden sind. \label{fig:regel-ketten-ketten-3}}
\end{figure} 

Die Transformationsmöglichkeit $i)$ der \emph{Unify-CHS}-Regel 
behandelt den Fall, dass die Teilkette, die die Anfangsbindung der
ursprünglichen Variablenkette enthält (und deshalb nicht mit $M$
markiert ist) mit einer beliebigen Teilkette der gegenüberliegenden
Umgebung unifiziert wird. Die resultierende Gleichung 
$\setf{c_i|N_1} \ue \setf{c'_{i'}|N_2}$ kann anschließend mit einer der 
Regeln \emph{Unify-CH-KMB, Unify-CH-KMR} oder \emph{Unify-CH-KML}
transformiert werden. 
Die restlichen Teilketten der Umgebung
werden mit der Umgebungsvariablen der gegenüberliegenden Umgebung
unifiziert. Der Fall $\setf{c_i^M|N_1} \ue \setf{c'^M_{i'}|N_2}$ dass
beide Variablenkette mit $M$ markiert sind, muss nicht betrachtet werden, da
keine der beiden Ketten die Anfangsbindung der ursprünglichen Kette
enthält, führt die berechnete Substitution für diesen Fall einen
syntaktischen Fehler in die Umgebungen ein. 
Die Transformationsmöglichkeit $ii)$ deckt den Fall ab, 
dass die Variablenketten der beiden Umgebungen disjunkt sind. 

\begin{beispiel}
\label{bsp:mehr-syntaktische-fehler}
Wir geben ein Beispiel, wie die Unifikation einer Variablenkette, die
nicht mit $M$ markiert ist, mit einer Variablenkette, die mit $M$
markiert ist, in einem Unifikator resultiert, der einen syntaktischen
Fehler in die Umgebungen einführt, in denen die Ketten enthalten
sind. 
Die Sorten der Variablen des Unifikationsproblems sind 
$x_i,y_i,z_i:V$, $e,d:U$ und $b_1: B$. 

\begin{longtable}{rl}
& $\set{\setf{ch(b(x_2,x_1),b(x_n,x_{n-1}))|e} \ue \setf{b_1,ch(b(y_2,y_1),b(y_{n'},y_{n'-1}))|d}}$ \\
$\xrightarrow{\emph{Split-L $iii)$}}$ & $\set{b_1 \ue b(z_3,z_2),$ \\
  & $\phantom{\{} \setf{ch(b(y_2,y_1),b(y_{n'},y_{n'-1}))|d} \ue $ \\ 
  & $\phantom{\{} \setf{ch(b(x_2,x_1),b(z_2,z_1)),ch(b(z_4,z_3),b(x_n,x_{n-1}))^M|e}}$ \\
$\xrightarrow{\emph{Unify-CHS i)}}$ & $\set{b_1 \ue b(z_3,z_2),$ \\
  & $\phantom{\{} \setf{ch(b(y_2,y_1),b(y_{n'},y_{n'-1}))|N_1} \ue \setf{ch(b(z_4,z_3),b(x_n,x_{n-1}))^M|N_2}$ \\
  & $\phantom{\{} e \ue N_2, d \ue \setf{ch(b(x_2,x_1),b(z_2,z_1))|N_1}}$ \\ 
$\xrightarrow{\emph{U-CH-KMR $iv)$}}\footnote{Die Regel \emph{Unify-CH-KMR $iv)$} wird auf die Variablenkette 
    $ch(b(z_4,z_3),b(x_n,x_{n-1}))^M$ angewendet, die auf der rechten Seite einer Unifikationsgleichung steht und mit $M$ 
    markiert ist. Nach Defintion \ref{def:uni-regeln-ketten-ketten} 
    der Unifikationsregeln ist diese Anwendung nicht zulässig. Das Beispiel soll illustrieren, weshalb 
    eine solche Anwendung der \emph{Unify-CH-KMR}-Regel durch die Definition der Regel ausgeschlossen wird.}$ 
    & $\set{b_1 \ue b(z_3,z_2),$ \\
  & $\phantom{\{} ch(b(z_7,z_6),b(y_{n'},y_{n'-1})) \ue ch(b(z_4,z_3),b(x_n,x_{n-1}))^M$ \\
  & $\phantom{\{} N_2 \ue \setf{ch(b(y_2,y_1),b(z_6,z_5))|N_1}$ \\
  & $\phantom{\{} e \ue N_2, d \ue \setf{ch(b(x_2,x_1),b(z_2,z_1))|N_1}}$ \\ 
$\xrightarrow{\emph{Dec}}$ & $\set{b_1 \ue b(z_3,z_2),$ \\
  & $\phantom{\{} b(z_7,z_6) \ue b(z_4,z_3), b(y_{n'},y_{n'-1}) \ue b(x_n,x_{n-1})$ \\
  & $\phantom{\{} N_2 \ue \setf{ch(b(y_2,y_1),b(z_6,z_5))|N_1}$ \\
  & $\phantom{\{} e \ue N_2, d \ue \setf{ch(b(x_2,x_1),b(z_2,z_1))|N_1}}$ \\ 
$\xrightarrow{\emph{Dec}\;\times 2}$ & $\set{b_1 \ue b(z_3,z_2),$ \\
  & $\phantom{\{} z_7 \ue z_4, z_6 \ue z_3, y_{n'} \ue x_n, y_{n'-1} \ue x_{n-1}$ \\
  & $\phantom{\{} N_2 \ue \setf{ch(b(y_2,y_1),b(z_6,z_5))|N_1}$ \\
  & $\phantom{\{} e \ue N_2, d \ue \setf{ch(b(x_2,x_1),b(z_2,z_1))|N_1}}$ \\ 
$\xrightarrow{\emph{Elim}\; z_6,N_2}$ & $\set{b_1 \ue b(z_3,z_2),$ \\
  & $\phantom{\{} z_7 \ue z_4, z_6 \ue z_3, y_{n'} \ue x_n, y_{n'-1} \ue x_{n-1}$ \\
  & $\phantom{\{} N_2 \ue \setf{ch(b(y_2,y_1),b(z_3,z_5))|N_1}$ \\
  & $\phantom{\{} e \ue \setf{ch(b(y_2,y_1),b(z_3,z_5))|N_1}, d \ue \setf{ch(b(x_2,x_1),b(z_2,z_1))|N_1}}$ \\ 
\end{longtable}
Das Unifikationsproblem in der letzten Zeile ist in gelöster Form 
und repräsentiert einen Unifikator $\sigma$. 
Im Term $\setf{b_1, ch(b(y_2,y_1),b(y_{n'},y_{n'-1}))|d}$ wird die
Kette analog zur Anwendung der Regel \emph{Unify-CH-KMR $iv)$} bei
der Unifikation
zu $\setf{b_1,ch(b(y_2,y_1),b(z_6,z_5)),ch(b(z_7,z_6),b(y_{n'},y_{n'-1}))|d}$
aufgespalten. 
Jetzt kann $\sigma$ angewendet werden:
\[\begin{array}{rl}
& \sigma(\setf{b_1,ch(b(y_2,y_1),b(z_6,z_5)),ch(b(z_7,z_6),b(y_{n'},y_{n'-1}))|d}) \\
%= & \setf{\sigma(b_1),\sigma(ch(b(y_2,y_1),b(z_6,z_5))),\sigma(ch(b(z_7,z_6),b(y_{n'},y_{n'-1})))|\sigma(d)} \\
%= & \setf{b(z_3,z_2),ch(\sigma(b(y_2,y_1)),\sigma(b(z_6,z_5))),\sigma(ch(b(z_7,z_6),b(y_{n'},y_{n'-1})))|\sigma(d)} \\
= & \setf{\underline{b(z_3,z_2)},ch(\sigma(b(y_2,y_1)),\underline{b(z_3,z_5)}),\sigma(ch(b(z_7,z_6),b(y_{n'},y_{n'-1})))|\sigma(d)}. \\
\end{array}\]
Die unterstrichenen Bindungen markieren die Stellen, 
an denen $\sigma$ einen syntaktischen Fehler in die \letr-Umgebung einführt. 
\end{beispiel}

\subsection{Terminierung}
\label{sec:terminierung-ketten}
Die Unifikationsprozedur, die durch die Transformationsregeln aus den
Definitionen \ref{def:uni-regel-ketten},
\ref{def:uni-regeln-ketten-ketten} und
\ref{def:uni-regeln-ketten-ketten-2} beschrieben wird, terminiert für 
Unifikationsprobleme mit Termen, die maximal eine Variablenkette pro
Umgebung enthalten. Außerdem dürfen in den zu unifizierenden Termen 
alle Variablen der Sorte $U,K$ oder $M$ nur genau einmal vorkommen, 
damit es durch eine Anwendung von \emph{Variable Elimination} nicht zu
einer Vervielfachung von Variablenketten in einer Umgebung kommen
kann.\footnote{Die Unifikationsprobleme, die zur Berechnung von
  Überlappungen gelöst werden müssen, erfüllen diese
  Beschränkung. Siehe hierzu auch: Definition
  \ref{def:eingschraenktes-unifikationsproblem} von eingeschränkten
  Unifikationsproblemen.} 
Die Überlegung zur Terminierung der Unifikationsprozedur für solche
eingeschränkten Unifikationsprobleme ist folgende:
Zur Unifikation von Termen die eine Variablenkette enthalten, müssen
Unifikationsprobleme der Form 
\[\set{\setf{b_1, \dots, b_m, c |e} \ue \setf{b'_1, \dots, b'_{m'}, c'|e'}}\]
gelöst werden, wobei $b_i,b'_{i'}$ \letr-Bindungen, $c,c'$
Variablenketten und $e,e'$ Variablen der Sorte $U$ sind. 
Dazu wird zunächst eine Folge von Transformationen mit Regeln aus 
Definition \ref{def:uni-regel-ketten} auf das Unifikationsproblem
angewendet, die die Bindungen $b_i,b'_{i'}$ nach dem Schema der
\emph{Cl}-Unifikation unifizieren (dieser Prozess terminiert nach Satz
\ref{satz:term-von-unify-p}) oder die Bindungen werden durch die Anwendung von 
\emph{Split-X} mit Bindungen aus Variablenketten unifiziert. 
Die Anwendung von \emph{Split-X} auf eine Kette $c$ oder $c'$
ist dabei durch die Anzahl der Bindungen in der
gegenüberliegenden Umgebung beschränkt. Auch diese Folge von Transformationen
terminiert, da die Anzahl der enthalten Bindungen $m$ und $m'$ endlich
ist. Durch diese Folge von Transformationen wird das
Unifikationsproblem in die Form
\[\set{\setf{c_{1},\dots,c_{n} |d} \ue \setf{c'_{1},\dots, c'_{n'}|d'}, 
%  \phantom{\{} \setf{c_{k 1},\dots,c_{k n} |X_k} \ue \setf{c'_{k 1},\dots, c'_{k n'}|Y_k}, \\
   s_1 \ue t_1, \dots s_l \ue t_l}.\]
gebracht.
$c_{i},c'_{i'}$ sind durch die Anwendung von \emph{Split-X $iii)$} 
aus $c$ bzw. $c'$ entstandenen Teilketten und $d,d'$ sind Variablen der 
Sorte $U$. Die Gleichungen $s_j \ue t_j$ sind Unifikationsgleichungen
in semi-gelöster Form (Definition \ref{def:semi-geloeste-form}) und enthalten die $b_i,b'_{i'}$.
Ein Unifikationsproblem in dieser Form enthält maximal eine
Variablenkette pro Umgebung, die nicht mit $M$ markiert ist, und kann
durch eine Anwendung von \emph{Unify-CHS} u.U. gefolgt von der 
Anwendung einer der Regeln aus Definition
\ref{def:uni-regeln-ketten-ketten} und einer endlichen Folge von 
\emph{Variable Elimination}-Schritten in semi-gelöste Form gebracht
werden. 

\paragraph{Ausblick}
Die Behandlung der Unifikation von Termen mit Variablenketten in
diesem Kapitel ist eher informell. An vielen Stellen, an den
eigentlich Beweise von Aussagen nötig sind, werden lediglich
Beispiele gegeben. Insbesondere die Vollständigkeit der
Unifikationsprozedur wird nicht ausführlich untersucht. 
Es wird vermutet, dass die beschriebene Unifikationsprozedur, die sich
aus der Beschränkung von Anwendungen der Split-Axiome ergibt, eine
Eigenschaft besitzt, die man als Überlappungs-Vollständigkeit
bezeichnen könnte. Damit ist gemeint, dass für die alle f\"ur die
Berechnung von Überlappungen relevanten Unifikator von der
Unifikationsprozedur gefunden werden. 

\chapter{Unifikation von Termen mit Kontextvariablen in $\sigmaLet$}
\label{cha:unif-von-kontexten}
$\Lambda^{let}$-Reduktionsregeln enthalten Kontextvariablen als zusätzliches
Konstrukt, das bisher nicht behandelt wurde.
Diese müssen auch in $\sigmaLet$ dargestellt
und bei der Unifikation berücksichtigt werden. Das kann geschehen,
indem eine zusätzliche Menge von Kontextvariablen betrachtet wird.
Terme mit Kontextvariablen sind aufgebaut wie wohlsortierte Terme mit
zusätzlichen Kontextvariablen. Kontexte sind Terme, die an einer
Position einen speziellen Loch-Operator $(\square)$ enthalten, in den
Terme oder Kontexte eingesetzt werden können. Kontextvariablen in
Termen können von Substitutionen durch Kontexte ersetzt werden. 
Syntaktisch können Kontextvariablen wie
Funktionssymbole der Stelligkeit 2 behandelt werden. 
Da wir Signaturen mit Sorten
betrachten, besitzen Kontexte und Kontextvariablen eine Sorte 
$R \rightarrow S$. 

Unifikation von Termen mit Kontextvariablen ist eine Variante der
Unifikation zweiter Ordnung, da Kontexte 
als $\lambda$-Terme mit genau einem Vorkommen einer gebundenen
Variablen betrachtet werden können. D.h. ein Kontext $c$ entspricht dem
Term $\lambda \square. t$, 
wobei die gebundene Variable $\square$ genau einmal in $t$ vorkommt. 
Unifikation zweiter Ordnung ist (ebenso wie Unifikation höherer
Ordnung) als unentscheidbar bekannt
\cite{goldfarb_undecidability_1981}. 
Die Entscheidbarkeit der Unifikation von Termen mit Kontextvariablen
ist ein offenes Problem. Gelten für ein Unifikationsproblem mit
Kontextvariablen bestimmte Einschränkungen, kann die Entscheidbarkeit
gezeigt werden. 
\citeA{schmidt-schauss_unification_1994} zeigt, dass unter bestimmten 
Strukturbeschränkungen der Unifikationsgleichungen (so genannte
stratifizierte Gleichungen) das Unifikationsproblem entscheidbar wird. 
Das Unifikationsproblem ist auch entscheidbar, wenn nur zwei
Kontextvariablen vorkommen \cite{schmidt-schauss_solvability_2002}
oder wenn alle Kontextvariablen maximal zweimal in einem
Unifikationsproblem vorkommen \cite{levy_linear_1996}. 
\citeA{comon_completion_1998-1} zeigt, dass Unifikation mit
Kontextvariablen entscheidbar ist, 
wenn alle in einem Unifikationsproblem vorkommenden Kontextvariablen 
$C$ auf den gleichen Term $t$ angewandt werden. 

In diesem Kapitel beschäftigen wir uns mit der Unifikation von Termen
mit Kontextvariablen in $\sigmaLet$. Das
Kapitel ist folgendermaßen aufgebaut:
In Abschnitt \ref{sec:kontexte-und-kontextvar} werden Kontexte,
Kontextvariablen und Terme mit Kontexten eingeführt. Diese Konstrukte
werden bezüglich einer Signatur mit Sorten definiert. Die Signatur
$\sigmaLet$ wird erweitert, um die
entsprechenden Kontextvariablen (für allgemeine Kontexte,
Oberflächen-, Reduktions- und schwache Reduktionskontexte) aus
$\Lambda^{let}$ darstellen zu können. 
Durch die Definition von Kontextvariablen für Terme mit Sorten 
existieren in $\sigmaLet$ mehr
Kontextvariablen als im Ursprungskalkül $\Lambda^{let}$. Einige
Probleme, die sich daraus ergeben, werden kurz diskutiert. 
Um diesen Problemen zu begegnen, werden \emph{zulässige
  $\sigmaLet$-Terme} definiert, die nur
bestimmte Kontextvariablen enthalten dürfen. 


Im anschließenden Abschnitt \ref{sec:wohlstr-subst} werden
Substitutionen erweitert zu Abbildungen, die Variablen auf Terme und
Kontextvariablen auf Kontexte abbilden. Wir werden sehen, dass
Wohlsortiertheit einer Substitution $\sigma$ in
$\sigmaLet$ als Kriterium nicht ausreicht, um
alle Einschränkungen, die für
$\sigmaLet$-Kontexte nach der Definition von
Kontexten in $\Lambda^{let}$ gelten müssen, darzustellen. 
Als wesentliches Kriterium für (wohlsortierte) Substitutionen wird 
\emph{Wohlstrukturiertheit} eingeführt. Diese verlangt, dass für alle
Komponenten $\set{C \mapsto c}$ einer Substitution die Struktur des
Kontextes $c$ der Sorte der Kontextvariablen $C$ entspricht. 

In Abschnitt \ref{sec:unif-von-sigmaLet-mit-kontextVar} befassen wir
uns mit der Unifikation von
$\sigmaLet$-Termen, die Kontextvariablen
enthalten. Das Vorgehen ist analog zum Bisherigen: Ein
Unifikationsproblem wird schrittweise in gelöste Form transformiert. 
Es wird festgestellt, dass alle
$\sigmaLet$-Unifikationsprobleme, die zur
Berechnung (kritischer) Überlappungen 
%linker Seiten von Reduktionsregeln 
gelöst werden müssen, einer Beschränkung unterliegen, unter der sie
entscheidbar sind (der {Be\-schränk\-ung} von
\citeA{comon_completion_1998-1}). 
Im Anschluss daran wird der Unifikationsprozess für
$\sigmaLet$-Terme mit Kontextvariablen
beschrieben, der in zwei Schritten abläuft: Zuerst wird mit
Unifikationsregeln, die sich an den Regeln von \citeauthor{comon_completion_1998-1}
orientieren, ein wohlsortierter Unifikator für ein Unifikationsproblem
berechnet. Die Vollständigkeit und die Terminierung dieser
Unifikationsprozedur wird hier nur angedeutet, der komplette Beweis
wird nicht gegeben (er ist in der zitierten Arbeit von
\citeauthor{comon_completion_1998-1} zu finden). Anschließend wird
der berechnete Unifikator an Einschränkungen 
angepasst, die sich durch die Definition von Kontexten in
$\Lambda^{let}$ ergeben. Dieser Prozess der \emph{Wohlstrukturierung}
wird in Abschnitt \ref{sec:wohlstr-von-sigm} beschrieben. 
Abschließend wird ein ausführliches Beispiel für die Berechnung
einer vollständigen Menge von Unifikatoren für ein
$\sigmaLet$-Unifikationsproblem gegeben. 

In diesem Kapitel wird die Links-Kommutativität des Funktionssymbols
$\setf{\cdot|\cdot}$ ignoriert. Es wird als zweistelliges
Funktionssymbol behandelt, für das weiter keine Bedingungen gelten.
Des weiteren werden in diesem Kapitel keine Variablenketten
betrachtet. Die Signatur $\sigmaLet_{\setf{\cdot|\cdot}}$ wird im
verk\"urzt als $\sigmaLet$ geschrieben. 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Kontexte und Kontextvariablen}
\label{sec:kontexte-und-kontextvar}

Um Terme mit Kontextvariablen darzustellen, wird
als zusätzliches  syntaktisches Konstrukt eine Menge von
Kontextvariablen $\CX$ benötigt. Kontextvariablen werden durch die 
Symbole $C,C_1,C'D,E,\dots$ bezeichnet. 
Alle Kontextvariablen $C \in \CX$ haben die Stelligkeit 2. 
%Die Funktion $\mathbb{S}: X \rightarrow S_\Sigma$, 
%die jeder Variablen eine Sorte zuordnet wird erweiterte zu der
%Abbildung
Signaturen mit Sorten werden erweitert um die Abbildung 
$\mathbb{S}_{\CX}: \CX \rightarrow S_{\Sigma} \times S_\Sigma$, die
jeder Kontextvariablen ein Paar von Sorten zuordnet. 
Im weiteren Verlauf schreiben wir $\mathbb{S}$ und meinen 
damit entweder die
Abbildung $\mathbb{S}_X: X \rightarrow S_\Sigma$ oder 
$\mathbb{S}_{\CX}: \CX \rightarrow S_{\Sigma} \times S_\Sigma$, je
nachdem ob das Argument eine Variable oder eine Kontextvariable ist.
Ist $C$ eine Kontextvariable, so dass $\mathbb{S}(C) = (R,S)$, dann
schreiben wir auch $C_{(R,S)}$ oder $C:R \rightarrow S$. 
F\"ur eine Signatur $\Sigma$ mit Sorten enthält die Menge der
Kontextvariablen für alle Sortensymbole $R,S \in S_{\Sigma}$ abzählbar
unendliche viele Kontextvariablen der Sorte $(R,S)$. 

%Die Sorte einer Kontextvariable $X:(R,S)$ wird auch geschrieben als $R \rightarrow S$.
Für Paare $(R,S)$ von Sorten definieren wir $\sseq$ folgendermaßen:
\[(R,S) \sseq (R',S') \; \text{gdw.}\; R \sseq R' \; \text{und} \; S \sseq S'.\] 
Wir bezeichnen mit $\undertilde{\sqsubset}_{\Sigma}$ den reflexiven, transitiven
Abschluss von $\undertilde{\sqsubset}_{\Sigma}$ und schreiben wie gewohnt
kurz $\undertilde{\sqsubset}$. 

Die Definition der $\Sigma$-Terme der Sorte $S$ wird um
Kontextvariablen erweitert. 
\begin{definition}%[sigma terme mit kontextvar
\label{def:sigma-terme-mit-kontext-var}
Sei $\Sigma$ eine Signatur mit Sorten, $X$ eine Menge von Variablen und
$\CX$ eine Menge von Kontextvariablen, so dass 
$\Sigma \cap X \cap \CX = \emptyset$. 
Die Menge $T(\Sigma,S,X,\CX)$ aller 
\emph{$\Sigma$-Terme der Sorte $S$} über $X$ und $\CX$ ist induktiv definiert durch
\begin{enumerate}
\item $x \in T(\Sigma,S,X,\CX)$, wenn $x \in X$ mit $\mathbb{S}(x) \sseq S$.
\item $t \in T(\Sigma,S,X,\CX)$, wenn $t:R \in \Sigma$ und $R \sseq S$.
\item $\set{x \mapsto r} t \in T(\Sigma,S,X,\CX)$, wenn 
  $t \in T(\Sigma,S,X,\CX)$, $r \in T(\Sigma,R,X,\CX)$ und $R \sseq \mathbb{S}(x)$.
\item $C(t) \in T(\Sigma,S,X,\CX)$, wenn $C \in \CX$ eine Kontextvariable ist mit
  $\mathbb{S}_{\CX}(C) = (R',S')$, so dass $S' \sseq S$ und 
  $t \in T(\Sigma,R,X,\CX)$, so dass $R \sseq R'$. 
\end{enumerate}
%{\color{red}{($\sseq$ sieht schlimm aus, evtl '\;'
%    einfügen)}}
\end{definition}
Die ersten drei Punkte der Definition entsprechen der bisherigen
Definition von $\Sigma$-Termen. Neu hinzu kommt, dass $\Sigma$-Terme
der Sorte $S$ gebildet werden können, durch die Anwendung einer
Kontextvariablen $C \in \CX$ der Sorte $(R',S')$ 
auf einen Term mit einer Sorte kleiner oder gleich $R'$. 
Dabei muss $S'$ eine Subsorte von $S$ sein. 

\begin{definition}%[kontexte]
\label{def:kontexte}
Sei $\Sigma$ eine Signatur mit Sorten, $X$ eine Menge von Variablen und
$\CX$ eine Menge von Kontextvariablen, so dass 
$\Sigma \cap X \cap \CX = \emptyset$. 
Die Menge $C(\Sigma,(R,S),X,\CX)$ aller 
\emph{$\Sigma$-Kontext der Sorte $(R,S)$} über $X$ und $\CX$ ist
induktiv definiert durch
\begin{enumerate}
\item $\square \in C(\Sigma,(R,S),X,\CX)$, für alle $R,S \in S_{\Sigma}$.
\item $C \in C(\Sigma,(R,S),X,\CX)$, wenn $C \in \CX$ mit
  $\mathbb{S}_{\CX}(C) \sseq (R,S)$. 
\item $t[\square]_{p} \in C(\Sigma,(R,S),X,\CX)$, wenn 
  $t \in T(\Sigma,S',X,\CX)$ keine Variable $x \in X$ ist, so dass $S' \sseq S$ und  
  $p \in \Pos(t)$, so dass $t|_{p} = s : R' \sseq R$. 
%\item $t[C]_{p} \in C(\Sigma,(R,S),X,\CX)$, wenn 
%  $t \in T(\Sigma,S',X,\CX)$ keine Variable $x \in X$ ist, so dass $S' \sseq S$ und  
%  $p \in \Pos(t)$, so dass $t|_{p} = s : R'$ und $C \in \CX$,
%  so dass $\mathbb{S}(C) \sseq (R,R')$.
\end{enumerate}

\end{definition}
Kontexte der Sorte $(R,S)$ sind entweder Kontextvariablen mit einer
Sorte $(R',S')$ kleiner gleich $(R,S)$, oder der spezielle (leere) 
Kontext $\square$, der für alle Sorten $R,S$ alle Paare 
$(R,S)$ als Sorte besitzt.  
Ein neuer Kontext der Sorte $(R,S)$ kann aus einem
Term $t$ der Sorte $S'$ kleiner oder gleich $S$ konstruiert werden
Dies geschieht, indem in $t$ 
(an einer Position $p$) ein Subterm $s$ mit einer Sorte $R'$ kleiner oder
gleich $R$ durch den Kontext $\square$ ersetzt wird.  
D.h. ein Kontext ist entweder eine Kontextvariable, oder ein Term mit 
(genau) einem Loch $\square$.
Um Kontexte zu bezeichnen, verwenden wir die Symbole
$c,c_1,c',d,\dots$. 
%oder ein Term, in dem an genau einer Position eine Kontextvariable
%ohne Argument vorkommt. 

Im Gegensatz zu Variablen $x \in X$, die in der Baumdarstellung eines
Terms nur als Blätter vorkommen, können Kontextvariablen als
beliebige Knoten im Baum (mit maximal einem Kind) vorkommen. 
In Abbildung \ref{fig:kontext-als-baum} ist ein beispielhafter Kontext in
seiner Baumdarstellung zu sehen.
%in dem eine Kontextvariablen ohne Argument $(D)$ vorkommt. 

\begin{figure}[!htb]
\center
\includegraphics*{pictures/Abb.Term.Pos.CX.eps}
\caption{Baumdarstellung des $\Sigma$-Kontextes
  $f(x,f(C(y),D(\square)))$. 
  %Kontexvariablen können als Knoten im Termbaum vorkommen. 
\label{fig:kontext-als-baum}}
\end{figure}

Aus der Definition der Subsorten-Quasiordung auf Tupel von Sorten und
der Definition von Kontexten folgt, direkt:
\begin{korollar}
\label{kor:subsort-kontext}
Sei $\Sigma$ eine Signatur mit Sorten.
\begin{enumerate}
\item Für alle Paare von Sorten $(R,S),(R',S')\in S_{\Sigma} \times S_{\Sigma}$ 
  gilt: $(R',S') \sqsubset (R,S)$ impliziert 
  $C(\Sigma,(R',S'),X,\CX) \subseteq C(\Sigma,(R,S),\CX)$.
\item Für Kontextvariablen gilt: $C \in T(\Sigma,(R,S),X) \Leftrightarrow \mathbb{S}(C) \sseq (R,S)$.
\end{enumerate}
\end{korollar}

In das Loch eines Kontextes können Terme oder Kontexte 
(einer entsprechenden Sorte) eingesetzt werden. 
\begin{definition}%[Konkatenation]
\label{def:konkatenation}
Sei $t[\square]_{p}: R \rightarrow S$ ein $\Sigma$-Kontext, und 
$s:R' \sseq R$ ein $\Sigma$-Term. 
\begin{itemize}
\item 
  Wenn $p \neq \epsilon$ gilt, 
  dann ergibt die Anwendung des Kontextes auf den Term 
  \[t[\square]_{p}(s) := t[s]_{p}\] 
  einen $\Sigma$-Term der Sorte $S$. 
  Wenn $s:R' \rightarrow S'$ ein $\Sigma$-Kontext ist, so 
  dass $S' \sseq R$, dann ergibt die Anwendung 
  einen $\Sigma$-Kontext der Sorte $R' \rightarrow S$. 
\item Wenn $p = \epsilon$ gilt, dann ergibt die Anwendung des
  Kontextes auf den Term 
  \[\square(s):= s\]
  ein Term der Sorte $R'$.  
  Ist $s$ ein Kontext der Sorte $R' \rightarrow S'$, dann  
  ergibt die Anwendung ein Kontext der Sorte $R' \rightarrow S'$.
\end{itemize}
\end{definition}
Wenn $c_1$ und $c_2$ Kontexte sind, dann bezeichnen wir $c_1(c_2)$
als Kontextschachtelung. 

\begin{definition}
\label{def:sorten-von-kontexten}
Wir definieren die \emph{Menge $T(\Sigma,X,\CX)$ aller wohlsortierten
$\Sigma$-Terme},
%wie bisher 
die um eine Menge von Kontextvariablen erweitert ist, als
\[\bigcup_{S \in S_{\Sigma}} \set{T(\Sigma,S,X,\CX)}\] 
und die \emph{Menge $C(\Sigma,X,\CX)$ aller wohlsortierten $\Sigma$-Kontexte} als  
\[\bigcup_{S \in (S_{\Sigma} \times S_{\Sigma})} \set{C(\Sigma,S,X,\CX)}.\] 

Die \emph{Sorte eines Kontextes} $c$ ist definiert als die Menge 
\[S_{\Sigma}(c):= \set{S \in (S_{\Sigma} \times S_{\Sigma}) \; | \; c \in T(\Sigma,S,X,\CX)}\]
 
und die \emph{Sorte einer Kontextvariablen} $C$ ist definiert als
\[S_{\Sigma}(C) = \set{S \in (S_{\Sigma} \times S_{\Sigma}) \; | \; \mathbb{S}(C) \sseq S}.\]
%Für jede Variable $x \in X$ besitzt die Menge $S_{\Sigma}(x)$ ein
%kleinstes Element, nämlich $\mathbb{S}(x)$. 
\end{definition}

Eine Signatur $\Sigma$ wird als \emph{regulär} bezeichnet, 
wenn $(S_{\Sigma},\sseq)$ und $(S_{\Sigma} \times S_{\Sigma}, \sseq)$
partiell geordnete Mengen sind und für jeden Term $t$ und jeden
Kontext $c$ die Mengen $S_{\Sigma}(t)$ und $S_{\Sigma}(c)$ ein
kleinstes Element besitzen. Das kleinste Element wird mit $\ls{t}$ bzw. 
$\ls{c}$ bezeichnet. Ist eine Signatur regulär, so schreiben wir
für die partielle Ordnung auf der Menge der Sortensymbole
$\sqsubseteq$ anstatt $\sseq$. 
Wir beschränken uns im weiteren Verlauf dieses Kapitels auf die
Betrachtung regulärer Signaturen. 

\begin{definition}
\label{def:sigmaLet-erweiterung}
Die Signatur $\sigmaLet$ wird verändert, %und erweitert, 
um die entsprechenden Kontextklassen aus $\Lambda^{let}$
darstellen zu können. 
Dazu werden neue Sorten $L,Ap$ für \letr-Terme und 
Applikationen eingeführt. Die Sorte $A$, die bisher Abstraktionen
repräsentierte, wird in $Ab$ umbenannt. 
Die Funktionsdeklarationen werden entsprechend angepasst. 
Als neue Sorten werden außerdem eingeführt:
\begin{itemize}
\item 
Die Sorte $ST$ repräsentiert $\Lambda^{let}$-Oberflächenkontexte, in
die ein Term mit einer 
Subsorte von $T$ eingesetzt wurde. $\sigmaLet$-Oberflächenkontexte sind
$\sigmaLet$-Kontexte der Sorte $R \rightarrow S$ mit $(R,S) \sqsubseteq
(T,ST), S \neq V$. Eine $\sigmaLet$-Oberflächenkontextvariable ist
eine Kontextvariable $D \in \CX$ der Sorte $T \rightarrow ST$.
\item 
Die Sorte $RT$ repräsentiert
$\Lambda^{let}$-Reduktionskontexte, in die ein Term mit einer Subsorte
von $T$
eingesetzt wurde. $\sigmaLet$-Reduktionskontexte sind
$\sigmaLet$-Kontexte der Sorte $R \rightarrow S$ mit 
$(R,S) \sqsubseteq (T,RT),  S \neq V$. 
Eine $\sigmaLet$-Reduktionskontextvariable ist
eine Kontextvariable $D \in \CX$ der Sorte $T \rightarrow RT$.
\item 
Die Sorte $RWT$ dient zur Darstellung von schwachen
$\Lambda^{let}$-Reduktionskontexten, in die ein Term mit einer
Subsorte von $T$
eingesetzt wurde. Wir bezeichnen $\sigmaLet$-Kontexte der Sorte $R
\rightarrow S$ mit $(R,S) \sqsubseteq (T,RWT), S \neq V$ als schwache
$\sigmaLet$-Reduktionskontexte.
Eine schwache $\sigmaLet$-Reduktionskontextvariable ist
eine Kontextvariable $D \in \CX$ der Sorte $T \rightarrow RWT$.
\item 
Zur Darstellung von allgemeinen $\Lambda^{let}$-Kontexten in
$\sigmaLet$ wird keine zusätzliche Sorte benötigt. Sie werden durch 
$\sigmaLet$-Kontexte der Sorte $R \rightarrow S$ mit $(R,S) \sqsubseteq (T,T),
S \neq V$ repräsentiert. 
Eine allgemeine $\sigmaLet$-Kontextvariable ist
eine Kontextvariable $D \in \CX$ der Sorte $T \rightarrow T$.
\end{itemize}
Für alle $\sigmaLet$-Kontexte der Sorte $(R,S)$ wird $S = V$
verboten, weil es keine Funktionsdeklaration der Sorte $V$ in
$\sigmaLet$ gibt. 
%Für die einzelnen Kontextklassen werden die Sorten 
%$ST$ für Oberflächenkontexte, $RT$ für Reduktionskontext und
%$RWT$ für schwache Reduktionskontexte eingeführt. Für allgemeine
%Kontexte, wird keine zusätzlicher Sorte benötigt, da hier die Sorte 
%$T$ verwendet werden kann. 
Die Subsortendeklarationen werden so getroffen, dass sie der Semantik
des $\Lambda^{let}$-Kalküls entsprechen. So ist beispielsweise 
die Sorte der schwachen Reduktionskontexte eine (echte) Subsorte der 
Sorte der Reduktionskontexte. 

%Die Menge der Sortsymbole $S_{\Sigma}^{let}$, die verwendet werden, um
%das Kalkül $\Lambda^{let}$ mit den Konstrukten Abstraktion, Applikation und \letr $\;$
%in ein Kalkül erster Ordnung mit Sortinformation zu transformieren,
%sei folgendermaßen definiert: 
%\begin{enumerate}
%\item [\bf{T}] repräsentiert den Sort für Terme (Ausdrücke des Ursprungskalküls),
%\item [\bf{A}] repräsentiert den Sort für Abstraktionen,
%\item [\bf{V}] repräsentiert den Sort für Variablen,
%\item [\bf{U}] repräsentiert den Sort für \letr-Umgebungen,
%\item [\bf{B}] repräsentiert den Sort für \letr-Bindungen,
%%\item [\bf{K}] repräsentiert den Sort für Ketten von \letr-Bindungen.
%\end{enumerate}
\newcommand{\fktsort}[3]{#1 \rightarrow #2 \rightarrow #3}
\[\begin{array}{rllr}
\sigmaLet = \set{ 
& \multicolumn{2}{l}{\mathbf{Subsortdeklarationen:}} \\
%& A, V, \sqsubset T, \\ %\; B \sqsubset U& \\
& Ab, Ap, V, L \sqsubset T, & \\
& Ap, L \sqsubset ST \sqsubset T, & \\
& Ap, L \sqsubset RT \sqsubset ST, & \\
& Ap \sqsubset RWT \sqsubset RT, & \\
& B \sqsubset U, & \\
%& B \sqsubset U,  & \\
& \multicolumn{2}{l}{\mathbf{Funktionsdeklarationen:}} \\
&  abs : \fktsort{V}{T}{Ab} & \mathsf{(Abstraktion)}, \\
&  app : \fktsort{T}{T}{Ap} & \mathsf{(Applikation)}, \\
&  letrec : \fktsort{U}{T}{L} & \mathsf{(\letr)}, \\
& \setf{\cdot|\cdot} : \fktsort{B}{U}{U} & \mathsf{(\letr-Umgebung)}, \\
&  bind : \fktsort{V}{T}{B} & \mathsf{(\letr-Bindung)},  \\
&  \emptyset : U & \mathsf{(leere \; \letr-Umgebung)} & } \\
%%&  kette : \fktsort{B}{B}{U} & \mathsf{(Kette \; von \; Bindugen)} \\
\end{array}\]

Die erweiterte Signatur ist immer noch \emph{einfach}, 
erfüllt die \emph{maximal-sorts-condition} und hat den \emph{Grad 1}, d.h. 
ihr Unifikationstyp (ohne Kontextvariablen) ist eindeutig (siehe
Kapitel \ref{cha:unif-fur-terme-mit-sorten}).  
Abbildung \ref{fig:hasse-diagramm-sortstruk-sigmaLet} zeigt ein
Hasse-Diagramm der Sortstruktur. 

\begin{figure}[ht]%[hasse diagramm sortstruktur]
\label{fig:hasse-diagramm-sortstruk-sigmaLet}
\[\xymatrix@C=0.15cm@R=0.5cm{
& T \ar@{-}[dl] \ar@{-}[d] \ar@{-}[dr] & & & U \ar@{-}[d] \\
V & ST \ar@{-}[dl] \ar@{-}[d] & Ab & & B  \\
L & RT \ar@{-}[d] & & & \\
  & RWT \ar@{-}[d] & & & \\
  & App & & & \\
}\]
\caption{Hasse-Diagramm der Sortstruktur von $\sigmaLet$.}
\end{figure}


Die in Abschnitt \ref{sec:wohlsortierte-terme} %\ref{sortedsec:wohlsortierte-terme} 
definierte Abbildung 
$\transl{\;} : \Lambda^{let} \rightarrow T(\Sigma^{let},X)$ 
%die Ausdrücke des Ursprungskalküls $\Lambda^{let}$ 
%(ausgenommen Variablenketten und Kontextvariablen) 
%übersetzt in $\Sigma^{let}$-Terme erster Ordnung mit Sortinformation,
wird folgendermaßen zu einer Abbildung 
$\transl{\;} : \Lambda^{let} \rightarrow T(\Sigma^{let}_{\setf{\cdot|\cdot}},X)$
erweitert, um Kontextvariablen zu übersetzen:
%(Es wird noch einmal darauf
%hingewiesen, dass Kontextvariablen und Ketten  
%hier noch nicht behandelt werden.)
\[\begin{array}{rcl}
\transl{C[s]}        & = & \transl{C}(\transl{s}) \quad \text{(analog für $S,R$ oder $R^-$)}\\
\transl{C}           & = & C:  T \rightarrow T \\
\transl{S}           & = & S:  T \rightarrow ST \\
\transl{R}           & = & R:  T \rightarrow RT \\
\transl{R^-}         & = & R^-: T \rightarrow RWT \\ 
%\transl{\lambda x.s} & = & abs(\transl{x},\transl{s}) \\
\end{array}\]
Die Übersetzung, die $\sigmaLet$-Terme in $\Lambda^{let}$-Ausdrücke
abbildet, wird mit $\transl{\;}^-$ bezeichnet. 
\end{definition}

%Wir sind vornehmlich an den $\sigmaLet$-Kontextvariablen interessiert, 
%die eine Entsprechung in $\Lambda^{let}$ besitzen. 
%\begin{itemize}
%\item Allgemeine Kontextvariablen $C$ der Sorte $\mathbb{S}(C)= (T,T)$.  
%\item Oberflächenkontextvariablen $S$ der Sorte $\mathbb{S}(S)= (T,ST)$.
%\item Reduktionskontextvariablen $R$ der Sorte $\mathbb{S}(R)= (T,RT)$ und
%\item Kontextvariablen für schwache Reduktionskontexte $R^-$ der Sorte
%  $\mathbb{S}(R^-)= (T,RWT)$. {Kontexte der Sorte $(T,RWT)$
%  werden als schwache ($\sigmaLet$-) Reduktionskontexte bezeichnet.} 
%\end{itemize}

\begin{bemerkung}
\label{bem:probleme-kontexte-sigmaLet-lambdaLet}
Der Kontextbegriff in $\sigmaLet$ weist bezüglich des Kontextbegriffs
in $\Lambda^{let}$ eine Reihe von Problemen auf:
\begin{enumerate}
%\item 
% Der Ursprungskalkül $\Lambda^{let}$ verfügt lediglich über
%  vier Kontextklassen: Allgemeine Kontexte, Oberflächenkontexte,
%  Reduktionskontexte und schwache Reduktionskontexte. Nach der Definition
%  von Kontexten und Kontextvariablen existieren in $\sigmaLet$ Kontexte,
%  die sich keiner dieser vier Kontextklassen zuordnen lassen. 
%%  als diese vier, nämlich für alle Sortensymbole $R,S$ eine
%%  Kontextklasse der Sorte $(R,S)$. 
%  %Nach Definition der übersetzung 
%  %(\ref{def:uebersetzung-kontextvar}) ist klar, dass
%  D.h. $\sigmaLet$-Kontexte einer bestimmten Sorte
%  besitzen keine Entsprechung in $\Lambda^{let}$: 
%  \begin{itemize}
%  \item Für alle $\sigmaLet$-Kontexte der Sorte $(R,S)
%    \sqsubseteq (T,T)$ mit $R,S \neq V$ gibt es Kontexte in
%    $\Lambda^{let}$.
%    %\footnote{Manche Kontextvariablen der Sorte $(R,S)
%    %  \sqsubseteq (T,T), S \neq V$ besitzen keine entsprechenden
%    %  Kontextvariablen in $\Lambda^{let}$, wie beispielsweise $C: T
%    %  \rightarrow Ab$, oder $D: L \rightarrow T$. Die Sorten dieser
%    %  Kontextvariablen sind allerdings Subsorten von Sorten, für die 
%    %  in $\Lambda^{let}$ Kontextvariablen existieren. Solche Kontexte
%    %  stellen kein Problem da, weil bei der Unifikation für
%    %  Unifikationsprobleme die nur .... HIER MUSS NOCH WAS HIN.
%    %  {Evtl. hoch zur Definition von $\transl{\;}^-$.}}
%    %In diesem Fall ist $\transl{c}^- \in \Lambda^{let}$.
%  \item Für alle $\sigmaLet$-Kontexte der Sorte $(R,S)
%    \sqsubseteq (\Top,U\;\text{oder} \; V)$ 
%    bzw. $(R,S) \sqsubseteq (U,\Top)$
%    gibt es keine Kontexte in $\Lambda^{let}$, wobei $\Top$
%    eine Sorte ist, so dass $S \sqsubseteq \Top$ für alle $S \in
%    S_{\Sigma}$ gilt. 
%    %In diesen Fall ist $\transl{c}^- \notin \Lambda^{let}$. 
%    Insbesondere sind Kontexte der Form
%    $letrec(\square,s)$ oder $letrec(\setf{\square|s},t)$ keine
%    $\Lambda^{let}$-Kontexte. 
%  \end{itemize}
%%  Kontexte der Sorte $R \rightarrow V$ 
%%  %eine bliebigeSorte aus $S_{\sigmaLet}$ ist, 
%%  haben für $R \sqsubseteq T$ zwar
%%  eine Subsorte von $\sigmaLet$ Kontexten, allerdings gibt es
%%  keine entsprechenden Kontexte in $\Lambda^{let}$.
%  In $\Lambda^{let}$ gibt es nur Kontextvariablen für
%  $\sigmaLet$-Kontexte der Sorten $(T,T)$, $(T,ST)$, $(T,RT)$ und $(T,RWT)$.
%  %Sie werden aus diesem Grund aus der Betrachtung ausgekalmmert.   
%  %da aber keine
%  %Funktionsdeklaration mit $V$ als Resultatsorte existitert, wirken
%  %sie wie ein Operator zur Umwandlung der Sorte $R$ zur Sorte $V$. 
\item 
  Nach Korollar \ref{kor:subsort-kontext} ist $abs(\square,s): V \rightarrow Ab$  
  wegen $(V,Ab) \sqsubset (T,T)$ auch ein Kontext der Sorte $T
  \rightarrow T$, 
  die nach unserem Verständnis allgemeine Kontexte repräsentiert.
  Allerdings darf nach Definition \ref{def:allg-kontext} das Loch in einem
  allgemeinen Kontext
  nicht an einer Position in einem Ausdruck vorkommen, an der nur
  Variablen stehen dürfen. So ist beispielsweise auch 
  $letrec(b(\square,s),t): V \rightarrow T$ eine Instanz eine
  $\sigmaLet$-Kontextes, die keine Entsprechung eines
  $\Lambda^{let}$-Kontextes besitzt. Diesem Problem kann man begegnen,
  indem man Löcher in $\sigmaLet$-Termen an Positionen verbietet, 
  an denen nur Terme der Sorte $V$ stehen dürfen. 
  Allerdings kann man damit nicht das allgemeine Problem lösen, das
  auch für andere Kontextklassen gilt. Beispielsweise ist 
  $app(s,\square):T \rightarrow Ap$ in $\sigmaLet$ wegen $(T,Ap)
  \sqsubseteq (T,RT)$ ein 
  $RT$- und ein $RWT$-Kontext, aber in $\Lambda^{let}$ stellt der Kontext
  keinen gültigen Reduktionskontext dar. 
%  Die Kontextklassen in $\sigmaLet$ entsprechen nicht den Kontextklassen
%  in $\Lambda^{let}$, sondern erlauben mehr Kontexte. 
%  Bei der Übersetzung macht das kein Problem, da nur eingeschränkte
%  Kontexte aus $\Lambda^{let} $ übersetzt werden. 
%  Bei der Unifikation von Termen mit Kontextvariablen k\"onnen
%  allerdings neue Kontextvariablen eingef\"uhrt werden, die 
%  eine Sorte besitzen, die keine Entsprechung in $\Lambda^{let}$
%  besitzen. 
%  %werden allerdings durch die größeren
%  %Kontextklassen zu viele Unifikatoren berechnet,
%  insbesondere Unifikatoren die bezüglich der
%  $\Lambda^{let}$-Definition von Kontexten keine zulässigen Lösungen
%  darstellen. Entweder berechnet man diese größere Menge von
%  Unifikatoren und sortiert diejenigen anschließend aus, die Kontexte
%  enthalten, die keine Entsprechung in $\Lambda^{let}$ haben. Oder man
%  modifiziert die Unifikationsprozedur entsprechend, dass nur 
%  zulässige $\Lambda^{let}$-Kontexte berücksichtigt werden, 
%  dann kann man allerdings nicht auf eine allgemeine
%  Unifikationsprozedur zurückgreifen, sonder muss einen speziell auf
%  die Signatur $\sigmaLet$ zugeschnittenen Unifikationsalgorithmus
%  verwenden. 
\item Das Einsetzen in Löcher und die Definition von Kontexten 
  erlauben es in $\sigmaLet$, Kontexte zu 
  konstruieren, die zwar die (Sub-) Sorte einer bestimmten
  Kontextklasse haben, aber im Sinne der $\Lambda^{let}$-Kontexte
  keine Kontexte der 
  entsprechenden Kontextklasse mehr sind. Betrachte beispielsweise die 
  $\sigmaLet$-Kontexte $c_1 = app(\square,s): T \rightarrow Ap$ und 
  $c_2 = abs(x,\square) : T \rightarrow Ab$. Einsetzen von $c_2$ in
  $c_1$ ergibt $app(abs(x,\square),t) : T \rightarrow Ap$ (nach
  Definition \ref{def:konkatenation}). Diese Sorte ist in $\sigmaLet$
  eine Subsorte  
  der Sorte von Oberflächen- und (schwachen) Reduktionskontexten. 
  Der Kontext $c_1(c_2)$ ist aber in $\Lambda^{let}$  
  weder ein Oberflächenkontext noch ein (schwacher) Reduktionskontext. 
  In $\sigmaLet$ lässt sich für Kontexte $c_1 : R_1 \rightarrow S_1$,
  $c_2 : R_2 \rightarrow T_2$ die Sorte der Anwendung $c_1(c_2) : R
  \rightarrow S$, die der
  $\Lambda^{let}$-Kontextklasse entspricht, folgendermaßen bestimmen:
  Nach Definition \ref{def:konkatenation} gilt $R = R_2$
  %Da in alle Kontexte beliebige Terme der Subsorte $T$ anstelle des
  %Lochs eingesetzt werden dürfen, ist $R = T$ 
  und für die Sorte $S$
  haben wir $S = lub(S_1,S_2)$.
  Für die Anwendung $app(abs(x,\square),t)$
  obiger Beispielkontexte ergibt sich so die Sorte
  $(T,lub(Ap,Ab))=(T,T)$, die der Sorte der Kontextvariablen
  entspricht, die allgemeine $\Lambda^{let}$-Kontexte
  repräsentieren. 
%  Diese Problem lässt sich lösen, indem Definition \ref{def:konkatenation}
%  angepasst wird: 
%  \begin{definition}
%  \label{def:konkatenation.staerker}  
%  Die Anwendung eines Kontextes $c_1: R \rightarrow S$
%  auf einen Kontext $c_2: R' \rightarrow S'$ ergibt einen Kontext 
%  $c_1(c_2):R'\rightarrow S$,, gdw.\ $S' \sseq R,S$.
%  \end{definition}
%  {Diese restriktiver Definition führt allerdings dazu, dass
%    sich in manchen Fällen kein Unifikator berchnen lässt. Ausserdem
%    wird i.A. kein allgemeinster Unifikator berchnet: Berechnete
%    Unifikatoren werden zu speziell.}
\item Eine Unterscheidung zwischen $ST$ und $RT$ Kontexten ist nur
  anhand der Sorten in $\sigmaLet$ nicht möglich.
  %in $\sigmaLet$ sind die beiden Kontextklassen äquivalent.
\end{enumerate}
\end{bemerkung}

Um einigen der geschilderten Problemen zu begegnen, definieren wir: 
%schliessen wir alle
%$\sigmaLet$-Kontexte $c$ aus der Betrachtung aus, für die keine
%für die gilt $\transl{c}^- \notin \Lambda^{let}$.
\begin{definition}%[zulaessige sigmaLet terme]
\label{def:zulaessige-sigmaLet-terme}
Ein $\sigmaLet$-Term $t$ wird als \emph{zulässig} bezeichnet, gdw.\ 
für alle Kontextvariablen $C$ in $t$ gilt 
$\mathbb{S}(C) = (T,T)$ oder 
$\mathbb{S}(C) = (T,ST)$ oder 
$\mathbb{S}(C) = (T,RT)$ oder 
$\mathbb{S}(C) = (T,RWT)$.

Ein $\sigmaLet$-Kontext $c$ wird als \emph{zulässig} bezeichnet, gdw.\
für einen zulässigen Term $t$, der Term $c(t)$ zulässig ist und $c$
keine Löcher an Positionen besitzt, an denen nur Variablen der Sorte
$V$ oder Terme einer Subsorte von $U$ stehen dürfen. D.h. 
$\forall p \in \Pos(c): c|_p = abs(x,s) 
\Rightarrow x \neq \square$ und $c|_{p} = bind(x,s) \Rightarrow x \neq \square$,
sowie $c|_p = letrec(s,t) \Rightarrow s \neq \square$ und 
$c|_p = \setf{s|t} \Rightarrow s \neq \square, t \neq \square$. 
\end{definition}

Das erste Problem aus Bemerkung
\ref{bem:probleme-kontexte-sigmaLet-lambdaLet} wird durch diese
Definition gelöst:
% das zweite nur teilweise:
Es werden nur Kontextvariablen in zul\"assigen $\sigmaLet$-Termen
erlaubt, die eine Entsprechung in $\Lambda^{let}$ besitzen
(d.h. Kontextvariablen f\"ur allgemeine Kontexte, f\"ur
Oberfl\"achenkontexte, und (schwache) Reduktionskontexte).
Außerdem sind Löcher an Positionen in Termen, an denen ausschließlich
Variablen der Sorte $V$ oder Terme mit einer Subsorte von $U$ stehen
dürfen, in zulässigen Termen und Kontexten verboten.
%allerdings hat der
%Kontextes $app(s,\square):T \rightarrow Ap$ immer noch eine Subsorte
%der Sorte der (schwachen) Reduktionskontextvariablen.  

Für zulässige Terme und Kontexte gilt, dass sie eine Entsprechung in
$\Lambda^{let}$-Ausdrücken besitzen. 
\begin{lemma}
\label{lemma:t-zulaessig-t-lambdaLet}
Sei $t$ ein zulässig $\sigmaLet$-Term, dann ist $\transl{t}^- \in \Lambda^{let}$. 
\end{lemma}
\begin{beweis}
Durch strukturelle Induktion über den Aufbau von zulässigen Termen
und Kontexten und der Anwendung von $\transl{\;}^-$. $\qed$
\end{beweis}

Im folgenden Abschnitt wenden wir uns den 
Problemen 2 und 3 aus Bemerkung \ref{bem:probleme-kontexte-sigmaLet-lambdaLet}
zu. 

%\begin{definition}%[var-t]
%\label{def:var-t}
%Sei $t$ ein $\Sigma$-Term oder $\Sigma$-Kontext, dann 
%ist die Menge der Variablen von $t$ definiert durch
%\[\begin{array}{rcl}
%\Var_{X}(t) & := & \set{x \in X \; | \; es \; gibt \; p \in Pos(t), \; so \; dass \; t|_p = x}, \\
%\Var_{\CX}(t) & := & \set{C \in \CX \; | \; es \; gibt \; p \in Pos(t), so \; dass \; t|_p = C \; oder\\
%  & & \phantom{\{C \in \CX \; | \;} t|_p = C(s), \; für \; einen\; beliebigen\; Term\; oder\; Kontext\; s} \\
%\Var(t) & := & \Var_{X}(t) \cup \Var_{\CX}(t). \\
%\end{array}\]
%\end{definition}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Wohlstrukturierte Substitutionen in $\sigmaLet$}
\label{sec:wohlstr-subst}

Es werden Substitutionen für Terme und Kontexte mit Kontextvariablen
eingeführt zunächst für den Fall einer Signatur $\overline{\Sigma}$
ohne Sorten. 
\begin{definition}%[context substitution]
\label{def:context-subs}
Analog zu einer Substitution 
$\sigma_1 : X \rightarrow T(\overline{\Sigma},X,\CX)$, die Variablen auf Terme
abbildet, definieren wir eine Substitution 
$\sigma_2 : \CX \rightarrow C(\overline{\Sigma},X,\CX)$, die Kontextvariablen auf
Kontexte abbildet, so dass die Menge 
$\set{C \in \CX \; | \; \sigma_2 C \neq C}$ endlich ist. 
Ein Paar von Substitutionen $(\sigma_1,\sigma_2)$ wird erweitert zu 
$\widehat{\sigma} : T(\overline{\Sigma},X,\CX) \rightarrow T(\overline{\Sigma},X,\CX)$ 
und 
$\widetilde{\sigma} : C(\overline{\Sigma},X,\CX) \rightarrow C(\overline{\Sigma},X,\CX)$,
so dass
\begin{itemize}
\item $\widehat{\sigma}|_X = \sigma_1$ und $\widetilde{\sigma}|_{\CX} = \sigma_2$,
\item $\widehat{\sigma}(f (t_1, \dots, t_n)) = f(\widehat{\sigma}t_1, \dots, \widehat{\sigma}t_n)$
  für alle $t_1, \dots, t_n \in T(\overline{\Sigma},X,\CX)$ und alle $f \in \overline{\Sigma}^n$,
\item $\widetilde{\sigma}(f (t_1, \dots,t_{i-1}, c, t_{i+1}, \dots t_n)) = 
      f(\widehat{\sigma}t_1,\dots,\widehat{\sigma}t_{i-1}, \widetilde{\sigma}c, \widehat{\sigma}t_{i+1}, \dots \widehat{\sigma}t_n)$
      für alle $t_1,$ $\dots,$ $t_n \in T(\overline{\Sigma},X,\CX)$, alle $c \in C(\overline{\Sigma},X,\CX)$, 
      alle $f \in \overline{\Sigma}^n$ und alle $1 \leq i \leq n$,
\item $\widetilde{\sigma}( c (\widehat{\sigma} t)) = \widehat{\sigma}(c(t))$ und 
  $\widetilde{\sigma}( c_1 (\widetilde{\sigma} c_2)) = \widetilde{\sigma}(c_1(c_2))$ 
  für alle $c,c_1,c_2 \in C(\overline{\Sigma},X,\CX)$ und $t \in T(\overline{\Sigma},X,\CX)$, 
\item $\widetilde{\sigma}(\square) = \square$.
\end{itemize}
\end{definition}
Im weiteren Verlauf wird zur Vereinfachung der Notation nicht
zwischen $(\sigma_1,\sigma_2)$ und 
$(\widetilde{\sigma}$,$\widehat{\sigma})$ unterschieden. Das Paar
wird kurz als $\sigma$ bezeichnet. 
Die \emph{Domain} von $\sigma$ ist definiert als die Vereinigung von 
$\Dom_{X}(\sigma) := \set{x \in X \; | \; \sigma x \neq x}$ und 
$\Dom_{\CX}(\sigma) := \set{C \in \CX \; | \; \sigma C \neq C}$. 
Die \emph{Range} von $\sigma$ ist die Menge der Terme in 
$T(\overline{\Sigma},X,\CX) \cup C(\overline{\Sigma},X,\CX)$, die Bilder der Variablen in 
$\Dom(\sigma)$ sind. Wir schreiben 
\[\set{x_1 \mapsto t_1, \dots, x_m \mapsto t_m, C_1 \mapsto c_1, \dots, C_n \mapsto c_n}\]
mit $t_1, \dots, t_m \in T(\overline{\Sigma},X,\CX)$ und $c_1, \dots, c_n \in C(\overline{\Sigma},X,\CX)$
für die Substitution mit der Domain $\set{x_1,\dots,x_m,C_1,\dots,C_n}$.
Die Menge aller unsortierten Substitutionen wird als
$\Sub_{\overline{\Sigma}}$ bezeichnet. 

Wir bemerken, dass Substitutionen keine Löcher in Terme einführen. 
D.h ein Term $t$ kann durch Anwendung einer Substitution $\sigma$
nicht zu einem Kontext gemacht werden. Ebenso wenig kann ein Kontext 
$c$ durch Anwendung von $\sigma$ zu einem Kontext mit mehr als einem 
Loch gemacht werden. 
Wir definieren unter welcher Bedingung Substitutionen
\emph{wohlsortiert} sind.   

\begin{definition}
\label{def:wohlsortierte-subs}
Die Menge der \emph{wohlsortierten Substitutionen} 
$Sub_{\Sigma}$ ist definiert als:
\[Sub_{\Sigma} := \set{\sigma = (\sigma_1,\sigma_2) \in Sub_{\overline{\Sigma}} \; | 
  \; \ssigf{\sigma_1 x} \supseteq \ssigf{x}, \ssigf{\sigma_2 C} \supseteq \ssigf{C}}.\]
Für reguläre Signaturen ist dies 
%nach Proposition \ref{prop.reg.sig}
gleichbedeutend mit
\[Sub_{\Sigma} := \set{\sigma = (\sigma_1,\sigma_2) \in Sub_{\overline{\Sigma}} \; | 
  \; \ls{\sigma_1 x} \sqsupseteq \ls{x}, \ls{\sigma_2 C} \sqsupseteq \ls{C}}.\]
\end{definition}

Unter Punkt 2 der Bemerkung
\ref{bem:probleme-kontexte-sigmaLet-lambdaLet} haben wir gesehen,
dass beispielsweise ein Kontext der Form 
$c = app(abs(x,\square),t) : T \rightarrow Ap$ 
eine Subsorte der Sorte von $\sigmaLet$-Oberflächen- und (schwachen)
Reduktionskontexten besitzt. Allerdings ist $c$ in $\Lambda^{let}$ weder
ein Oberflächenkontext noch ein (schwacher) Reduktionskontext. 
Das Kriterium der Wohlsortiertheit reicht an dieser Stelle nicht aus,
um beispielsweise eine Substitution der Form 
$\set{R_{(T,RT)} \mapsto app(abs(x,\square),t)}$, die bezüglich der
$\Lambda^{let}$-Kontextsyntax keine g\"ultig Lösung darstellt,
zu vermeiden. Wir definieren deshalb:
\begin{definition}%[wohlstrukturierte subs]

\label{def:wohlstrukturierte-subs}
Eine wohlsortierte Substitution 
\[\sigma = (\sigma_1:X \rightarrow T(\sigmaLet,X,\CX), 
\sigma_2:\CX \rightarrow C(\sigmaLet,X,\CX))\]
wird als \emph{wohlsortiert bezüglich der $\Lambda^{let}$-Kontextsyntax} 
(oder einfach kurz \emph{wohlstrukturiert}) bezeichnet, gdw.\
\begin{enumerate}
\item alle Terme und alle Kontexte der Range von $\sigma$ zulässig
  und alle Kontextvariablen in $\Dom(\sigma_2)$ zulässig sind. Und
\item für alle $C \in \Dom(\sigma_2)$ mit $\sigma_2(C) = c$ und
  für alle Kontexte $c_1,c_2$, deren Wurzelsymbole ungleich $bind$ und
  $\setf{\cdot|\cdot}$ sind, so dass $c = c_1(c_2)$, gilt  
%  \[lub(snd(LS_{\sigmaLet}(c_1)),snd(LS_{\sigmaLet}(c_2))) \sqsupseteq snd(\mathbb{S}(C)).\footnote{{evtl. Notation vereinfachen indem dem ganzen 
%      Ding ein Name gegebgen wird.}}\]
  \[snd(LS_{\sigmaLet}(c_1)) \sqsupseteq snd(\mathbb{S}(C)) \text{
   und }snd(LS_{\sigmaLet}(c_2)) \sqsupseteq snd(LS_{\sigmaLet}(C))\]
  Wobei $snd$ eine Funktion ist, die wenn ein Tupel gegeben ist, das zweite
  Element des Tupels zurück gibt, $snd(R,S) = S$. Und
\item für alle $C \in \Dom(\sigma_2)$ der Sorte $(R,S) \sqsubseteq
  (T,ST)$ mit $\sigma_2(C) = c$ gilt, 
  wenn $c|_p = abs(x,t)$, dann enthält $t$ kein Loch, d.h. $t \in T(\sigmaLet,X,\CX)$
  für alle $p \in \Pos(c)$. Und
  %und für alle Kontexte $c_1,c_2$, so
%  %dass $c = c_1(c_2)$ gilt $c_1 \neq abs(x,\square)$ und 
%  %$c_2 \neq abs(x,\square)$. 
\item für alle $C \in \Dom(\sigma_2)$ der Sorte $(R,S) \sqsubseteq
  (T,RT)$ mit $\sigma_2(C) = c$ gilt, wenn $c|_p = app(s,t)$, dann
  enthält $t$ kein Loch für alle $p \in Pos(c)$. Und
  %und für alle Kontexte $c_1,c_2$, so
  %dass $c = c_1(c_2)$ gilt $c_1 \neq app(s,\square)$ und 
  %$c_2 \neq app(s,\square)$.
\item für alle $C \in \Dom(\sigma_2)$ der Sorte $(T,RT)$
  mit $\sigma_2(C) = c$ gilt, wenn $c|_p = letrec(s,t)$ und
  einer der beiden Terme $s,t$ ein Kontext ist, dann ist $p =
  \epsilon$. 
  Außerdem wird die Bedingung 2 verschärft zu:
  Für alle Kontexte $c_1,c_2$, deren Wurzelsymbole ungleich $bind$
  und $\setf{\cdot|\cdot}$ sind, so dass $c = c_1(c_2)$, gilt
  $snd(LS_{\sigmaLet}(c_1)), snd(LS_{\sigmaLet}(c_2)) \sqsupseteq RWT$. 
  
  %und für alle Kontexte $c_1,c_2$, so
  %dass $c = c_1(c_2)$ gilt $c_2 = letrec(\square,s)$, oder $c_2 = letrec(s,\square)$ 
  %impliziert $c_1 = \square$.  
\end{enumerate}
\end{definition}

Punkt 2 der Definition stellt sicher, dass in der Range
einer Substitution die Kontexte bezüglich der Sorte der
Kontextvariablen in der Domain und der 
$\Lambda^{let}$-Definition von Kontexten richtig geschachtelt sind.
%Beispielsweise darf ein schwacher Reduktionskontext als Subkontexte
%nur weitere Reduktionskontexte enthalten, enthält er Kontexte anderer
%Klassen ist er kein Reduktionskontext mehr. Da dies von der
%Kontextdefinition in $\sigmaLet$ nicht zugesichert wird
Die Bedingungen 3 und 4 der Definition stellen sicher, dass in
$\sigmaLet$-Kontexten die Löcher nicht an Positionen stehen, an denen
sie für die entsprechenden $\Lambda^{let}$-Kontexte nicht erlaubt
sind. Bedingung 5 garantiert, dass Reduktionskontexte $r$ in $\sigmaLet$
eine der folgenden zwei Formen haben:
Entweder $r = r_1(r_2)$ und alle Kontexte $r_1,r_2$ 
%haben eine Subsorte von $RWT$, 
sind schwache Reduktionskontexte (der Sorte $RWT$) 
oder $r = letrec(s,t)$ und $s$ oder $t$ enthalten
als Subkontexte 
%einer Subsorte von $RWT$.
nur schwache Reduktionskontexte.\footnote{Damit $r$ für den 
  Fall $r = letrec(s,t)$ einen Reduktionskontext gemäß der
  $\Lambda^{let}$-Definition von Reduktionskontexten darstellt, muss
  i.A. eine noch stärkere Bedingung gelten (siehe die Definition \ref{def:reduktionskontexte}
  von Reduktionkontexten in $\sigmaLet$). Da diese jedoch sehr
  umständlich zu formulieren ist, kommen wir zu einem 
  späteren Zeitpunkt noch einmal darauf zurück (in Beispiel
  \ref{bsp:wohlstrukturierung}).} 

\begin{beispiel}%[wohlstrukturierte subs]
\label{bsp:wohlstruk-subs}
Die Substitution $\set{R_{(T,RT)} \mapsto app(abs(x,\square),t)}$ ist
nicht wohlstrukturiert, da für $c_1 = app(\square,t), c_2 = abs(x,\square)$
%die kleinste obere Schranke $lub(Ap,Ab) = T$ keine Subsorte von $RT$ ist. 
gilt: $snd(LS_{\sigmaLet}(c_2)) = Ab \not\sqsubseteq RT =
snd(LS_{\sigmaLet}(R))$.
Die Substitution $\set{R_{(T,RT)} \mapsto app(C_{(T,T)}(\square),t)}$
ist nicht wohlstrukturiert wegen $T \not\sqsubseteq RT$. Im Gegensatz
zum vorhergehenden Beispiel kann sie zu einer wohlstrukturierten
Substitution gemacht werden, indem die Kontextvariable $C$ instantiiert
wird $\set{C \mapsto C'_{(T,RT)}}\set{R_{(T,RT)} \mapsto
    app(C_{(T,T)}(\square),t)}$. 
Die Substitution $\set{R_{(T,RT)} \mapsto app(s,\square)}$ ist nicht 
wohlstrukturiert, weil $app(s,\square)|_{\epsilon} = app(s,\square)$
gegen Bedingung 4 aus obiger Definition verstößt.
\end{beispiel}

%Bei der Prüfung ob in der Komponente $C_i \mapsto c_i$ einer
%Substitution für alle Subkontext $d_1(d_2) = c_i$ gilt, dass die 
%kleinste untere Schranke der Resultatsorten von $d_1$ und $d_2$ eine
%Subsorte von $\mathbb{S}(C_i)$ ist, werden keine Kontextschachtelungen
%betrachtet, bei denen $d_1$ oder $d_2$ an der Wurzelpositon eines der
%beiden Funktionssymbole $\setf{\cdot|\cdot}$ oder $bind$ besitzt. 
Die zweite Bedingung aus Definition \ref{def:wohlstrukturierte-subs}
berücksichtigt 
keine Kontextschachtelungen der Form $c_1(c_2)$,
wenn wenigstens einer der beiden Kontexte als Wurzelsymbol
$\setf{\cdot|\cdot}$ oder $bind$ besitzt. Der Grund dafür ist folgender:
Wie wir schon bemerkt haben (Bemerkung
\ref{bem:probleme-kontexte-sigmaLet-lambdaLet} 
und Definition \ref{def:zulaessige-sigmaLet-terme}) dürfen
in zulässigen Termen keine Löcher an Positionen auftauchen, an denen
ausschließlich Terme einer Subsorte von $U$ stehen können. 
Bei der Betrachtung aller Kontextschachtelungen können 
allerdings solche nicht zulässigen Kontexte 
auftreten.
%, die das Loch an einer solchen Position besitzen. 
Betrachte beispielsweise den Kontext 
$letrec(\setf{b(x,\square)|X},t)$, der sich in 
$c_1 = letrec(\square,t)$ und $c_2 = \setf{b(x,\square)|X}$ zerlegen
lässt, wobei 
%$snd(LS_{\sigmaLet}(c_2))) = U \not\sqsubseteq $ nicht existiert. 
$c_1$ kein zulässiger Kontext ist.
%(und damit keine Entsprechung in $\Lambda^{let}$ besitzen).
Deshalb wird nur die Zerlegung in zulässigen Kontexte 

$c_1 = letrec(\setf{b(x,\square)|X},t)$, $c_2 = \square$ betrachtet.
%Punkt 2 der Definition \ref{def:wohlstrukturierte-subs} berücksichtigt, 
Diese ist ausreichend um eine Schachtelung der Kontexte gemäß der 
$\Lambda^{let}$-Kontextsyntax sicherzustellen. 

%\begin{lemma}
%{DAS STIMMT SO NICHT: $R \mapsot app(R'(\square)_{T,RW},t)_{Ap}$
%  und $RW \not \sqsubseteq Ap$, es muss schon die $lub$ Bedingung sein.}
%Für eine wohlsortierte $\sigmaLet$-Substitution $\sigma$
%%$\sigma = \set{x_1 \mapsto t_1, \dots, x_m \mapsto t_n, C_1 \mapsto c_1, \dots,
%%  C_n \mapsto c_n}$ gilt die zweite Bedingung
%aus Definition \ref{def:wohlstrukturierte-subs}, gdw.\ 
%Für alle $C \in \Dom_{\CX}(\sigma), \sigma C = c$,  gilt
%$snd(LS_{\sigmaLet}(C)) \sqsubseteq  snd(LS_{\sigmaLet}(c))$ und für alle 
%Kontexte $c_1,c_2$ deren Wurzelsymbole ungleich $\setf{\cdot|\cdot},
%bind$ sind, so dass $c = c_1(c_2)$ gilt 
%$snd(LS_{\sigmaLet}(c_1)) \sqsubseteq snd(LS_{\sigmaLet}(c_2))$. 
%\end{lemma}

\begin{proposition}
\label{prop:anw-wohlsturk-subs-zulaess-term}
Sei $\sigma$ eine wohlstrukturierte Substitution und $t$ ein
zulässiger $\sigmaLet$-Term. 
Dann ist $\sigma t$ ein zul\"assiger $\sigmaLet$-Term.
%Dann gilt $\sigma t \in T(\sigmaLet,X,\CX)$. 
\end{proposition}
\begin{beweis}
Folgt direkt aus der Definition der wohlstrukturierten Substitutionen, da
sie keine Kontextvariablen einführen, die nicht zulässig sind 
und keine Löcher an Positionen einführen, an denen nur Variablen
der Sorte $V$ oder Terme einer Subsorte von $U$ erlaubt sind.
$\qed$
\end{beweis}

\begin{proposition}
\label{prop:wohlstrukturierte-subs}
\sloppy
Sei $t \ue s$ ein $\sigmaLet$-Unifikationsproblem zwischen zulässigen
Termen $s,t$ und $\sigma$ eine wohlstrukturierte Lösung des
Unifikationsproblems. Dann gilt 
$\transl{\sigma s}^-, \transl{\sigma t}^- \in \Lambda^{let}$.  
\end{proposition}
\begin{beweis}
Die wohlstrukturierte Substitution $\sigma$ erhält die Zulässigkeit
der Terme $s$ und $t$ (Proposition
\ref{prop:anw-wohlsturk-subs-zulaess-term}) und nach Lemma
\ref{lemma:t-zulaessig-t-lambdaLet} gilt für die zulässigen Terme
$\sigma s$ und $\sigma t$: $\transl{\sigma s}^- ,\transl{\sigma t}^- \in \Lambda^{let}$. $\qed$
%Durch Definition \ref{def:wohlstrukturierte-subs} wird sichergestellt,
%dass für einen wohlstrukturierten Unifikator $\sigma$ eines
%$\sigmaLet$-Unifikationsproblems zwischen zulässigen Termen $s \ue t$ 
%gilt $\transl{\sigma s}^{-1},\transl{\sigma t}^{-1} \in \Lambda^{let}$. 
%Dazu muss noch gezeigt werden, dass die Anwendung einer
%wohlstrukturierten Substitution auf einen zulässigen Term wieder
%einen zulässigen Term ergibt. 
\end{beweis}

\begin{proposition}
\label{prop:komposition-wohlstruk-subs}
Seien $\sigma$ und $\tau$ wohlstrukturierte Substitutionen. 
Dann ist auch $\sigma \tau$ eine wohlstrukturierte Substitution.
\end{proposition}
\begin{beweis}
\sloppy
Seien $\sigma = \set{x_1 \mapsto s_1, \dots, x_m \mapsto s_n, C_1
  \mapsto c_1, \dots, C_n \mapsto c_n}$ 
und $\tau = \set{y_1 \mapsto t_1, \dots, y_k \mapsto t_k, D_1
  \mapsto d_1, \dots, D_l \mapsto d_l}$ wohlstrukturiert. 
Dann ist $\sigma \tau = \set{y_1 \mapsto \sigma t_1, \dots, y_k
  \mapsto \sigma t_k, D_1 \mapsto \sigma d_1, \dots, D_l \mapsto \sigma d_l} \cup 
  \set{x_i \mapsto s_i, C_j \mapsto c_j \; | \; x_i,C_j \in \Dom(\sigma) - \Dom(\tau)}$.
Die Komponenten $\set{y_i \mapsto \sigma t_i}, 1 \leq i \leq k$ sind wohlstrukturiert,
weil $y_i,t_i$ zulässige Terme sind (nach Voraussetzung) und $\sigma$ 
wohlstrukturiert ist, und die Anwendung $\sigma t_i$ nach Proposition
\ref{prop:anw-wohlsturk-subs-zulaess-term} die Zulässigkeit der Terme
erhält. 

Jetzt ist noch zu zeigen, dass die Komponenten 
$\set{D_i \mapsto \sigma d_i \; |\; 1 \leq i \leq l}$ wohlstrukturiert sind, 
d.h. für alle $d'_1, d'_2$  deren Wurzelsymbole ungleich
$\setf{\cdot|\cdot}$ und $bind$ sind, mit $d'_1(d'_2) = d_i$ muss  
$snd(LS_{\sigmaLet}(\sigma d'_1)), snd(LS_{\sigmaLet}(\sigma d'_2)) \sqsupseteq D_i$ 
gelten. Falls $d'_1$ und $d'_2$ keine Kontextvariablen aus der Domain
von $\sigma$ sind, gilt die Bedingung, weil die Sorte von Kontexten in
einer einfachen Signatur nicht von der Sorte der Subterme abhängig
ist. Sei $d'_1 = C_j$ %$1 \leq j \leq n$
eine Kontextvariable aus der Domain von $\sigma$, dann folgt 
$snd(LS_{\sigmaLet}(\sigma d'_1))\sqsupseteq D_i$  
%snd(LS_{\sigmaLet}(\sigma d'_2)) 
aus der Wohlsortiertheit von $\sigma$: 
$snd(LS_{\sigmaLet}(\sigma d'_1)) = snd(LS_{\sigmaLet}(\sigma C_j)) \sqsubseteq
snd(LS_{\sigmaLet}(\sigma c_j))$. % = snd(LS_{\sigmaLet}(d'_1))$.
Die Überlegung ist analog, falls $d'_2$ eine Kontextvariable aus der Domain
von $\sigma$ ist, bzw. falls $d'_1, d'_2$ beides Kontextvariablen aus der
Domain von $\sigma$ sind. 

Außerdem gilt für alle Kontextvariablen $D_i \in \Dom(\tau)$, die eine
Subsorte von $(T,ST)$ besitzen, dass in $d_i$ nur Kontextvariablen
vorkommen, die eine Subsorte von $(T,ST)$ besitzen (da $\tau$
wohlstrukturiert ist; Punkt 2 von Definition
\ref{def:wohlstrukturierte-subs}). Da auch $\sigma$ wohlstrukturiert
ist, führt die Anwendung $\sigma d_i$ in $d_i$ keine Terme der
Form $abs(x,t)$, so dass $t$ ein Kontext ist. Die Überlegung gilt
gleichermaßen für die Bedingungen 4 und 5.  

D.h. für die Komposition $\sigma \tau$ zweier wohlstrukturierter
Substitutionen gelten die Bedingungen aus Definition
\ref{def:wohlstrukturierte-subs}, folglich ist $\sigma \tau$
wohlstrukturiert. $\qed$ 
\end{beweis}

%Wir definieren die Instantiierungs-Quasiordung auf der Menge der 
%wohlstrukturierten $\sigmaLet$-Substitutionen folgendermaßen:
\begin{definition}
\label{def:instant-quasi-wohlstruk}
Seien $\sigma$ und $\tau$ wohlsortierte Substitutionen
und $W \subseteq X \cup \CX$ eine Menge von Variablen. 
Die Substitution $\sigma$ ist \emph{allgemeiner auf W} als  
die Substitution $\tau$, geschrieben als 
$\sigma \lesssim_{\Sigma} \tau [W]$,
wenn es eine wohlsortierte $\sigmaLet$-Substitution $\delta$ gibt,
so dass gilt $\tau = \delta \sigma[W]$. 

Da die Komposition von wohlstrukturierten $\sigmaLet$-Substitutionen
$\sigma, \tau$ wieder wohlstrukturiert ist, kann man analog
definieren: $\sigma \lesssim_{\sigmaLet}^{wstr} \tau [W]$, gdw.\
es eine wohlstrukturierte Substitution $\delta$ gibt, so dass $\tau =
\delta \sigma [W]$. 
%Die Substitution $\tau$ wird als \emph{Instanz} von $\sigma$ und die
%Relation $\lesssim_{\Sigma}[W]$ als
%\emph{Instantiierungs-Quasiordnung} bezeichnet. 
\end{definition}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Unifikation von $\sigmaLet$-Termen mit Kontextvariablen}
\label{sec:unif-von-sigmaLet-mit-kontextVar}

Das Vorgehen zur Lösung eines Unifikationsproblems mit
Kontextvariablen ist analog zu den bisher vorgestellten Verfahren: 
Ein Unifikationsproblem wird durch sukzessive Anwendung
von Transformationen in gelöste Form gebracht, aus der ein Unifikator
für das Problem direkt abgelesen werden kann. 
Da die Terme nun Kontextvariablen enthalten, passen wir die
entsprechenden Begriffe dementsprechend an. 
Außerdem muss für
$\sigmaLet$-Unifikationsprobleme berücksichtigt werden, dass nur
wohlstrukturierte Substitutionen als Lösungen in Frage kommen. 

\begin{definition}%[kontext unifikationsproblem]
\label{def:kontext-unifikationsproblem}
Eine \emph{Termgleichung} ist eine Gleichung $s \ue t$ zwischen zwei
Termen $s,t \in T(\Sigma,X,\CX)$ und eine
\emph{Kontextgleichung} ist eine Gleichung $C \ue c$ zwischen einer
Kontextvariablen $C \in \CX$ und einem 
Kontext $c \in C(\Sigma,X,\CX)$.  
Ein \emph{$\Sigma$-Unifikationsproblem mit Kontextvariablen} 
ist eine endliche Menge von Term- und Kontextgleichungen 
$P=\set{s_1 \ue t_1, \dots, s_m \ue t_m, C_1 \ue c_1, \dots, C_n \ue c_n}$.
Ein \emph{$\Sigma$-Unifikator} von $P$ 
%(auch \emph{Unifikator} von $P$ genannt) 
ist eine wohlsortierte Substitution $\sigma$, so dass 
$\sigma t_1 = \sigma s_i$ für $i= 1, \dots, m$ und $\sigma C_j =
\sigma c_j$ für $j = 1, \dots, n$. Die Menge aller
wohlsortierten 
Unifikatoren von $P$ wird als $U_{\Sigma}(P)$ bezeichnet
\[ U_{\Sigma}(P) := \set{\sigma \in Sub_{\Sigma} | \; \sigma s_i = \sigma
  t_i \; \text{für} \; i = 1,\dots, n \; \text{und} \; C_j = c_j \;
  \text{für}\; j = 1, \dots, m}.\]
$P$ ist \emph{lösbar} wenn $U_{\Sigma}(P) \neq \emptyset$. 
Das spezielle Unifikationsproblem $\bot$ besitzt keine Lösung. 
Mit $\Var(P)$ wird die Menge der in $P$ auftauchenden Variablen und
Kontextvariablen bezeichnet.
%: $\Var(P):= \cup^{n}_{i=1} (\Var(s_i) \cup \Var(t_i))$.

Ist $P$ ein $\sigmaLet$-Unifikationsproblem, dann muss außerdem
gelten:
\begin{itemize}
\item Die Term- und Kontextgleichungen in $P$ enthalten nur zulässige
  Terme. 
\item Ein Unifikator $\sigma$ von $P$ ist eine wohlstrukturierte
  Substitution. 
\item Die Menge aller Unifikatoren von $P$ besteht aus der Menge aller
  wohlstrukturierten Unifikatoren, die $P$ lösen. 
\end{itemize}
\end{definition}

Man startet bei der Transformation eines Unifikationsproblems mit
Kontextvariablen immer mit einem Problem, das nur Termgleichungen
enthält. Während der Transformation können Kontextgleichungen
eingeführt werden, auf die als einzige Unifikationsregel die
Eliminierung von Kontextvariablen angewandt wird. 
Aus diesem Grund sind Kontextgleichungen auf die Form $C = c, C\in
\CX, c \in C(\Sigma,X,\CX)$ beschränkt. 
Wenn wir im weiteren Verlauf dieses Kapitels von Unifikationsproblemen 
sprechen, sind Unifikationsprobleme mit Kontextvariablen gemeint. 

Als einzige Änderung der Definition einer (minimalen)
vollständigen Menge von Unifikatoren für ein Unifikationsproblem mit  
Kontextvariablen, betrachten wir die Instantiierungs-Quasiordnung
modulo der Menge von Variablen und Kontextvariablen, die in einem
Unifikationsproblem vorkommen. 
\begin{definition}%[vollst min mgu menge]
\label{def:vollst-min-mgu-menge-kontextvar}
Eine \emph{vollständige Menge von Unifikatoren} für
ein $\Sigma$-{Uni\-fi\-ka\-ti\-ons\-pro\-blem} mit Kontextvariablen $P$ ist
eine Menge (wohlsortierter) Substitutionen $CU_{\Sigma}(P)$, so dass 
\begin{itemize}
\item $CU_{\Sigma}(P) \subseteq U_{\Sigma}(P)$ und 
\item für alle $\tau \in U_{\Sigma}(P)$ gibt es $\sigma \in CU_{\Sigma}(P)$,
  so dass $\sigma \lesssim_{\Sigma} \tau [\Var(P)]$. 
\end{itemize}

Eine \emph{minimale vollständige Menge von $\Sigma$-Unifikatoren} für ein
$\Sigma$-Unifikationsproblem mit Kontextvariablen $P$ ist eine
vollständige Menge von Unifikatoren $MU_{\Sigma}(P)$, so dass 
%die Substitutionen in $MU_{\Sigma}(P)$ bezüglich $\iqse [\Var(P)]$
%nicht vergleichbar sind:  
\begin{itemize}
\item für alle $\sigma, \tau \in MU_{\Sigma}(P)$ gilt: 
  $\sigma \lesssim_{\Sigma} \tau [\Var(P)]$ impliziert $\sigma =_{\Sigma} \tau [\Var(P)]$.
\end{itemize}
Eine Substitution $\sigma$ ist ein \emph{allgemeinster $\Sigma$-Unifikator} von $P$
%(kurz \emph{$\Sigma$-mgu}),
gdw. $\set{\sigma}$ eine minimale vollständige Menge von
Lösungen für $P$ ist.
%Eine vollständige, minimale Menge von Unifikatoren wird kurz als
%Menge von \emph{mgus} bezeichnet.

Ist $P$ ein $\sigmaLet$-Unifikationsproblem, dann muss außerdem
gelten, dass die (minimale) vollständige Menge nur wohlstrukturierte
Substitutionen enthält. 
\end{definition}

\begin{definition}%[Semi-gelöste Form]
\label{def:geloeste-form-kontextvar}
Ein Unifikationsproblem mit Kontextvariablen 
\[S=\set{x_1 \ue t_1, \dots x_m \ue t_m, C_1 \ue c_1, \dots C_n \ue c_n}\] 
ist in \emph{gelöster Form}, gdw.\
alle Variablen $x_i$ und Kontextvariablen $C_j$ paarweise verschieden
sind und nicht in $t_i$ und $c_j$ vorkommen 
und $\ls{x_i} \sqsubseteq \ls{t_i}, \ls{C_i} \sqsubseteq \ls{c_i}$ gilt.
In diesem Fall definiert man die Lösung von $S$ als
\[\sigma_{S}=\set{x_1 \mapsto t_1, \dots x_m \mapsto t_m, C_1 \mapsto c_1, \dots C_n \mapsto c_n}.\] 

Für ein $\sigmaLet$-Unifikationsproblem muss außerdem gelten, dass
die $S$ zugeordnete Lösung $\sigma_{S}$ eine wohlstrukturierte
Substitution ist. 
\end{definition}

Ein Unifikationsproblem in gelöster Form repräsentiert einen mgu
für dieses Problem. 

Die Entscheidbarkeit von Unifikationsproblemen mit Kontextvariablen ist
ein offenes Problem. Gelten bestimmte Einschränkungen für
Unifikationsprobleme, so kann deren Entscheidbarkeit gezeigt werden. Eine
Beschränkung, unter der Unifikationsprobleme mit Kontextvariablen
entscheidbar sind, ist folgende von \citeA{comon_completion_1998-1}
angegebene Bedingung (die so genannte Comon-Einschränkung):
Für alle Kontextvariablen $C$ eines Unifikationsproblems gilt, 
dass alle Vorkommen von $C$ auf denselben Term $t$ angewandt werden. 
\citeauthor{comon_completion_1998-1} gibt für solche eingeschränkten
Unifikationsprobleme einen vollständigen und terminierenden
Unifikationsalgorithmus an. Dabei berücksichtigt er auch Sorten,
allerdings ist sein Ansatz diesbezüglich schwer mit dem hier
gewählten vergleichbar, da er Sorten in Form von Constraints
verwendet, die zusätzliche Bestandteile von Unifikationsproblemen
sind. %\footnote{\cite{comon_completion_1998-1} -> Mehr zu seinem Ansatz.}  
Wir gehen daher hier nicht weiter auf seine Methode zur Behandlung von
Sorten ein, wollen uns aber an seinem Ansatz zur Unifikation von
Termen mit Kontextvariablen orientieren. 
Dazu halten wir zunächst fest, dass die
$\sigmaLet$-Unifikationsprobleme, an deren Lösung wir vornehmlich
interessiert sind, die Einschränkung von
\citeauthor{comon_completion_1998-1} erfüllen: Für alle linken Seiten der
$\Lambda^{let}$-Unifikationsregeln gilt, dass sie ausschließlich
paarweise verschiedene Kontextvariablen enthalten, d.h. die
Einschränkung von \citeauthor{comon_completion_1998-1}
ist offensichtlich erfüllt. Außerdem werden zur Berechnung von
Überlappungen die beiden zu unifizierenden Terme so umbenannt, dass
sie variablendisjunkt sind (siehe Abschnitt \ref{sec:berechnung-von-ueberlappungen-in-sigmaLet}).
%D.h. die Einschränkung von \citeauthor{comon_completion_1998-1} ist
Für alle $\sigmaLet$-Unifikationsprobleme, die zur Berechnung von
Überlappungen gelöst werden müssen, 
gilt sogar eine noch stärkere Einschränkung. 

\begin{definition}%[Eingeschränktes Unifikationsproblem]
\label{def:eingschraenktes-unifikationsproblem}
Sei $P$ ein $\sigmaLet$-Unifikationsproblem mit Kontextvariablen
zwischen zulässigen Termen. Das Problem $P$ wird als
\emph{eingeschränkt} bezeichnet, gdw.\ alle in $P$ vorkommenden
Kontextvariablen genau einmal in $P$ vorkommen und alle in $P$
vorkommenden Variablen, einer beliebigen Sorte $R$ ungleich $V$, 
genau einmal in $P$ vorkommen. 

\end{definition}
Variablen der Sorte $V$ dürfen in einem eingeschränkten
Problem mehr als einmal vorkommen. Das mehrfache Vorkommen von
Variablen dieser Sorte ist unproblematisch, weil es durch die
Elimination von Variablen der Sorte $V$ nicht zu einer Vervielfachung
von Kontextvariablen in einem Unifikationsproblem kommen kann
(da Termgleichungen der Form $x_V \ue C(t)$ nicht in wohlsortierter,
gel\"oster Form sind).
Unter obiger Beschränkung
wird somit bei der Transformation von
$\sigmaLet$-Unifikationsproblemen vermieden, dass sich
Kontextvariablen durch Elimination in einem Problem vervielfachen. 
Diese Tatsache stellt die Terminierung des Unifikationsalgorithmus
sicher.

\begin{proposition}
\label{prop:sigmaLet-uniprob-eingeschraenkt}
Alle $\sigmaLet$-Unifikationsprobleme, die zur Berechnung aller (kritischen)
Überlappungen von linken Seiten der $\Lambda^{let}$-Reduktionsregeln
gelöst werden müssen, sind eingeschränkte Unifikationsprobleme. 
\end{proposition}
\begin{beweis}
Folgt durch Betrachtung der linken Seiten der
$\Lambda^{let}$-Reduktionsregeln (bzw. der
$\sigmaLet$-Reduktionsregeln aus Kapitel \ref{cha:berechn-von-uberl})  
und weil die Regeln zur 
Berechnung von Überlappungen so umbenannt werden, dass
sie variablendisjunkt sind.  $\qed$
\end{beweis}

Wir betrachten nun die wesentlichen Unifikationsregeln zur
Transformation von Unifikationsproblemen mit Kontextvariablen nach
\citeA{comon_completion_1998-1}. 
Zur Vereinfachung der Notation wird angenommen, dass   
die zugrunde liegende Signatur einfach ist und alle Funktionssymbole
eine Stelligkeit von zwei besitzen (was in $\sigmaLet$ der Fall ist).
Die Unifikationsregeln, die \citeauthor{comon_completion_1998-1}
verwendet, kombinieren die Regeln \emph{Variable Elimination}
(für Variablen und Kontextvariablen)
und \emph{Decomposition} in einer \emph{Merge}-Regel, weil
eine Eliminierung von (Kontext-) Variablen im Allgemeinen die
Comon-Einschränkung von Unifikationsproblemen nicht erhält. 
Da wir für $\sigmaLet$-Unifikationsprobleme aber eine noch stärkere
Einschränkung (Def. \ref{def:eingschraenktes-unifikationsproblem})
als die von \citeauthor{comon_completion_1998-1} 
betrachten, können wir die Eliminierung von (Kontext-) Variablen beibehalten. 
%Der Grund hierfür ist Folgender: Da alle Kontextvariablen und alle
%Variablen, für die zulässige Kontexte in $\sigmaLet$ existieren, nur
%einmal in Unifikationsproblemen vorkommen, kann es durch eine
%Eliminierung von (Kontext-) Variablen nicht zu einer Vervielfachung
%von Kontextvariablen in Unifikationsproblemen kommen. 

\begin{definition}%[unifikationsregeln kontextvar ohne sorten]
\label{def:unifreg-kontextvar-ohne-sorten}
Sei $\Sigma$ eine einfache Signatur, so dass alle Funktionssymbole in
$\Sigma$ die Stelligkeit zwei besitzen und $P$ ein eingeschränktes 
$\Sigma$-Unifikationsproblem mit Kontextvariablen. 
Die Regeln zur Unifikation in regulären Signaturen aus Definition
\ref{def.unifikationsregeln} werden um die 
in Abbildung \ref{fig:regeln-comon} dargestellten Regeln erweitert.

\begin{figure}[htp]
\fbox{
\begin{minipage}{0.98\textwidth}
$\begin{array}{l}
\multicolumn{1}{l}{\mathbf{Split}} \\
\set{f(t_1,t_2) \ue C(s)} \uplus P \Rightarrow \\
\quad \begin{array}[t]{cl} 
	i)  & \set{C \ue \square, f(t_1,t_2) \ue s} \cup P  \\
	ii) & \set{C \ue f(C'(\square),t_2), t_1 \ue C'(s)} \cup P \\
	\multicolumn{2}{l}{\quad \text{wenn}\;f(x_1,x_2)\;\text{die Funktionsdeklaration von}\;f\;\text{ist und}\;\ls{C}=(R,S),}\\
	\multicolumn{2}{l}{\quad \text{dann ist}\; C':R \rightarrow \ls{x_1} \; \text{eine neue Kontextvariable.}}\\
	iii) & \set{C \ue f(t_1,C'(\square)), t_2 \ue C'(s)} \cup P \\
	\multicolumn{2}{l}{\quad \text{wenn}\;f(x_1,x_2)\;\text{die Funktionsdeklaration von}\;f\;\text{ist und}\;\ls{C}=(R,S),}\\
	\multicolumn{2}{l}{\quad \text{dann ist}\; C':R \rightarrow \ls{x_2}\; \text{eine neue Kontextvariable.}}\\
      \end{array} \\
\end{array}$ \\

$\begin{array}{l}
\multicolumn{1}{l}{\mathbf{Context \; Decompositon}} \\  
\set{C(s) \ue D(t)} \uplus P \Rightarrow \\
\quad \begin{array}[t]{cl} 
	i)  & \set{s \ue D'(t), D \ue C(D'(\square))} \cup P \\
	\multicolumn{2}{l}{\quad \text{wenn}\;\ls{C}=(R_C,S_C)\;\text{und}\;\ls{D}=(R_D,S_D),} \\
	\multicolumn{2}{l}{\quad\text{dann ist}\;D':R_D\rightarrow R_C\;\text{eine neue Kontextvariable.}}\\
	ii)  & \set{t \ue C'(s), C \ue D(C'(\square))} \cup P \\
	\multicolumn{2}{l}{\quad \text{wenn}\;\ls{C}=(R_C,S_C)\;\text{und}\;\ls{D}=(R_D,S_D),} \\
	\multicolumn{2}{l}{\quad\text{dann ist}\;C':R_C\rightarrow R_D\;\text{eine neue Kontextvariable.}}\\
	iii) & \set{C \ue E(f(C'(\square),D'(t))), D \ue E(f(C'(s),D'(\square)))} \cup P \\
	\multicolumn{2}{l}{\quad \text{wenn}\; glb(\ls{C(s)},\ls{D(t)}) = S\;\text{existiert,}\; f(x_1, x_2):S_f} \\
	\multicolumn{2}{l}{\quad \text{eine Funktionsdeklaration ist, und}\;\ls{C}=(R_C,S_C),\;\ls{D}=(R_D,S_D).}\\	
	\multicolumn{2}{l}{\quad \text{Dann sind}\;C':R_C \rightarrow \ls{x_1},\;D':R_D \rightarrow \ls{x_2}\; \text{und}} \\
	\multicolumn{2}{l}{\quad E: S_f \rightarrow S,\; \text{neue Kontextvariablen.}} \\
	iv) & \set{C \ue E(f(D'(t),C'(\square))), D \ue E(f(D'(\square),C'(s)))} \cup P \\
	\multicolumn{2}{l}{\quad \text{wenn}\; glb(\ls{C(s)},\ls{D(t)}) = S\;\text{existiert,}\; f(x_1, x_2):S_f} \\
	\multicolumn{2}{l}{\quad \text{eine Funktionsdeklaration ist, und}\;\ls{C}=(R_C,S_C),\;\ls{D}=(R_D,S_D).}\\	
	\multicolumn{2}{l}{\quad \text{Dann sind}\;C':R_C \rightarrow \ls{x_2},\;D':R_D \rightarrow \ls{x_1}\; \text{und}} \\
	\multicolumn{2}{l}{\quad E: S_f \rightarrow S,\; \text{neue Kontextvariablen.}} \\
      \end{array}
\end{array}$\\
$\begin{array}{l}
\multicolumn{1}{l}{\mathbf{Context \; Variable \; Elimination \; (sorted)}} \\  
\set{C \ue c} \uplus P \Rightarrow  \set{C \ue c} \cup \set{C \mapsto c} P \\
\quad \text{wenn} \; C \notin \Var(c) \;\text{und} \; \ls{c} \sqsubseteq \ls{C}. \\
\end{array}$
\end{minipage}}
\caption{Regeln zur Unifikation von eingeschränkten
  Unifikationsproblemen mit Kontextvariablen nach
  Comon (1998). \label{fig:regeln-comon}}
\end{figure}

\newpage
Weitere Regeln, die zur Unifikation benötigt werden sind: 

\fbox{
\begin{minipage}{0.98\textwidth}
$\begin{array}{l}
\multicolumn{1}{l}{\mathbf{Context \; Orientation}} \\  
\set{C(s) \ue t} \uplus P \Rightarrow  \set{t \ue C(s)} \cup P \\
\quad \text{wenn} \; t \; \text{ein Term ist, dessen Wurzelsymbol keine Kontextvariable ist.} \\
\end{array}$\\
%$\begin{array}{l}
%\multicolumn{1}{l}{\mathbf{Context \; Variable \; Occurs \; Check}} \\  
%\quad \text{{wird nicht gebracht, weil $P$ eingeschränkt ist.}}\\
%\end{array}$\\
%$\begin{array}{l}
%\multicolumn{1}{l}{\mathbf{Sorted \; Fail \; Context}} \\  
%\set{C \ue c} \uplus P \Rightarrow  \bot \\
%\quad \text{wenn} \; \ls{c} \not\sqsubseteq \ls{C}. \\
%\end{array}$\\
$\begin{array}{l}
\multicolumn{1}{l}{\mathbf{Context \; Weakening}} \\  
\set{x \ue C(s)} \uplus P \Rightarrow \\ % \set{C \ue c} \cup \set{C \mapsto c} P \\
\quad \text{wenn}\; x \notin C(s)\;\text{und}\;\ls{x} \not\sqsubseteq \ls{C(s)} \\
\quad \begin{array}[t]{cl} 
	i)  & \set{C \ue \square, x \ue s} \cup P \\
	ii)  & \set{x \ue f(x_1,x_2), f(x_1,x_2) \ue C(s)} \cup P \\
	\multicolumn{2}{l}{\quad \text{wenn}\; f(x_1,x_2):S \;\text{eine Funktionsdeklaration (mit neuen Variablen) ist,}} \\ 
	\multicolumn{2}{l}{\quad \text{so dass}\; S=glb(\ls{x},\ls{C(t)}).} \\
      \end{array}
\end{array}$\\
%$\begin{array}{lll}
%\multicolumn{3}{l}{\mathbf{Tautology}} \\
%\set{s \ue s} \uplus P \Rightarrow P \\
%\end{array}$\\
%$\begin{array}{l}
%\multicolumn{3}{l}{\mathbf{Orientation}} \\
%\set{t \ue x} \uplus P \Rightarrow \set{x \ue t} \cup P \\
%\quad \text{wenn} \; t \; \text{keine Variable ist.} \\
%\end{array}$\\
%$\begin{array}{l}
%\multicolumn{3}{l}{\mathbf{Decomposition}} \\
%\set{f(s_1, \dots, s_n) \ue f(t_1, \dots, t_n)} \uplus P \Rightarrow \set{s_1\ue t_1, \dots s_n \ue t_n} \cup P \\
%\end{array}$\\
%$\begin{array}{l}
%\multicolumn{3}{l}{\mathbf{Variable \; Elimination \; (sorted) }} \\
%%{\color{red}{oder besser unsorted?}} 
%\set{x \ue t} \uplus P \Rightarrow \set{x \ue t} \cup \set{x \mapsto t} P \\
%\quad \text{wenn}\; x \notin \Var(t) \; \text{und} \; \ls{t} \sqsubseteq \ls{x}. \\
%\end{array}$\\
%$\begin{array}{l}
%\multicolumn{3}{l}{\mathbf{Symbol \; Clash}} \\
%\set{f(s_1, \dots, s_n) \ue g(t_1, \dots, t_m)} \uplus P \Rightarrow \bot \\
%\end{array}$\\
%$\begin{array}{l}
%\multicolumn{3}{l}{\mathbf{Occurs \; Check}} \\
%\set{x \ue t} \uplus P \Rightarrow \bot \\
%\quad \text{wenn} \; x \in \Var(t) \; \text{und} \; x \neq t. \\ 
%\end{array}$\\
%$\begin{array}{l}
%\multicolumn{3}{l}{\mathbf{Subsort}} \\
%\set{x \ue y} \uplus P \Rightarrow \set{y \ue x} \cup P \\ 
%\quad \text{wenn} \; \ls{x} \sqsubset \ls{y} \\
%\end{array}$\\
%$\begin{array}{l}
%\multicolumn{3}{l}{\mathbf{Common \; Subsort}} \\
%\set{x \ue y} \uplus P \Rightarrow \set{x \ue z, y \ue z} \cup P \\
%\quad \text{wenn} \; \ls{x} \not\sqsubseteq \ls{y},  \ls{y} \not\sqsubseteq \ls{x} \; \text{und}\\
%\quad z:S \; \text{ist neue Variable mit Sort}\; S=glb(\ls{x},\ls{y}). \\
%\end{array}$\\
%$\begin{array}{l}
%\multicolumn{3}{l}{\mathbf{Sorted \; Fail \; Var}} \\
%\set{x \ue y} \uplus P \Rightarrow \bot \\
%\quad \text{wenn} \; \ls{x} \not\sqsubseteq \ls{y} \; \text{und} \; \ls{y} \not\sqsubseteq \ls{x} \\ 
%\quad \text{und} \; glb(\ls{x},\ls{y}) \; \text{existiert nicht.} \\
%\end{array}$\\
%$\begin{array}{l}
%\multicolumn{3}{l}{\mathbf{Weakening}} \\
%\set{x \ue f(t_1, \dots, t_n)} \uplus P \Rightarrow \set{x \ue f(s_1,\dots,s_n), t_1 \ue s_1, \dots, t_n \ue s_n} \cup P \\
%\quad \text{wenn} \; x \notin \Var(f(t_1, \dots, t_n)) \; \text{und} \;
%\ls{f(t_1,\dots,t_n)} \not\sqsubseteq \ls{x} \; \text{und} \; \\
%\quad f(s_1, \dots, s_n):S \; \text{ist Termdeklaration mit} \; S=glb(\ls{x},\ls{f(s_1, \dots, s_n)}). \\
%\end{array}$\\
%$\begin{array}{l}
%\multicolumn{3}{l}{\mathbf{Sorted \; Fail \; Fun}} \\
%\set{x \ue f(t_1, \dots, t_n)} \uplus P \Rightarrow \bot \\
%\quad \text{wenn} \; x \notin \Var(f(t_1, \dots, t_n)) \; \text{und} \;
%\ls{f(t_1,\dots,t_n)} \not\sqsubseteq \ls{x} \; \text{und} \\
%\quad \text{es gibt keine Termdeklaration} \; f(s_1, \dots,s_n):S \; \\
%\quad \text{mit} \; S=glb(\ls{x},\ls{f(s_1, \dots, s_n)}). \\ 
%\end{array}$
\end{minipage}}

Ist auf ein Unifikationsproblem eine Regel anwendbar, bei der mehr als
eine Transformationsmöglichkeit gegeben ist ($i,ii,\dots$), dann
wird eine beliebige Alternative ausgewählt, für die das
Unifikationsproblem die Voraussetzungen erfüllt. 

Die Sorten der neuen Kontextvariablen, eingef\"uhrt in den Regeln
\emph{Split} und \emph{Context Decomposition}, werden so
gewählt, dass sie der Definition von Kontexten (\ref{def:kontexte})
und der Einschränkung, die sich für die Sorten durch die Einsetzung 
in Kontexte ergibt (Definition \ref{def:konkatenation}), entsprechen.
\end{definition}

Die Unifikationsprozedur, die durch die Regeln aus Definition
\ref{def:unifreg-kontextvar-ohne-sorten} definiert ist, berechnet für ein
$\sigmaLet$-Unifikationsproblem mit Kontextvariablen $P$ einen
wohlsortierten Unifikator $\sigma$, der i.A. nicht wohlstrukturiert ist. 
Falls für $P$ ein wohlstrukturierter Unifikator existiert, kann dieser
berechnet werden, indem eine Substitution $\delta$ bestimmt wird, so
dass $\delta \sigma$ ein wohlstrukturierter Unifikator für $P$ ist
(ähnlich der Berechnung eines Weakenings für eine unsortierte
Substitution in Proposition \ref{prop:muw-in-reg-elem-sig}). 
Durch die Aufteilung der Berechnung von wohlstrukturierten
Unifikatoren in zwei Schritte, kann auch die Vollständigkeit und die
Terminierung der Unifikation 
% von wohlstrukturierten Unifikatoren 
in zwei Schritten gezeigt werden: Zuerst wird die Vollständigkeit und
Terminierung der durch die Regeln aus Definition
\ref{def:unifreg-kontextvar-ohne-sorten} beschriebenen
Unifikationsprozedur gezeigt. Da diese auf Einschränkungen der
Unifikationsregeln von \citeA{comon_completion_1998-1} basiert, kann
dazu auf dessen Beweise zurückgegriffen werden. 
Anschließend kann die Vollständigkeit und die Terminierung des
Verfahrens gezeigt werden, das versucht, einen berechneten  
nicht wohlstrukturierten Unifikator wohlzustrukturieren. 

Wie wir bereits bemerkt haben, ist Comons Ansatz bezüglich der
Behandlung von Sorten nicht direkt mit dem hier gewählten
vergleichbar. Um auf seinen Beweis der Vollständigkeit und
Terminierung zurückgreifen zu können, sollte deshalb eine
modifizierte Version der Unifikationsregeln aus Definition
\ref{def:unifreg-kontextvar-ohne-sorten} verwendet werden, die allen
neu eingeführten Kontextvariablen die $\Top$-Sorte einer Signatur
zuweist (vgl. Lemma \ref{lemma:top-sort}). Vollständigkeit und Terminierung kann dann mit
Comons Methoden gezeigt werden. Zur Wohlsortierung ist anschließend
noch die Berechnung eines Weakenings notwendig. 
%(die mit der Prozedur zur Wohlstrukturierung in $\sigmaLet$ gekoppelt werden kann).
Um die Präsentation des Verfahrens zur Wohlstrukturierung in
$\sigmaLet$ nicht zu kompliziert zu gestalten, wurden die
Unifikationsregeln in Definition
\ref{def:unifreg-kontextvar-ohne-sorten} direkt so formuliert, dass
eine Sorte für neu eingeführte Kontextvariablen gemäß Definitionen 
\ref{def:kontexte} und \ref{def:konkatenation} gewählt
wird.%\footnote{Zum formalen Beweis der Vollständigkeit und
%  Terminierung der Berechnung von wohlstrukturierten Unifikatoren in
%  $\sigmaLet$ sollte in drei Schritten vorgegangen werden: 
%  Berechnung eines (unsortieren) Unifikators $\sigma$ mit der Prozedur von
%  Comon; Berechung eines Weakenings $\omega$ für $\sigma$; Berechung
%  von $\delta$, so dass $\delta \omega \sigma$ wohlstrukturiert ist.
%  In der hier gewählten Präsentation sind die ersten beiden Schritte
%  der Einfachheit halber gekoppelt.}

Wir skizzieren kurz die Überlegung, weshalb die beiden Regeln
\emph{Split} und \emph{Context Decomposition} aus
Definition \ref{def:unifreg-kontextvar-ohne-sorten} eine vollständige
und terminierende Unifikationsprozedur beschreiben. Die kompletten
Beweise sind in \citeA{comon_completion_1998-1} zu finden. 
Auf die zusätzlichen Regeln, die wegen der expliziten
Berücksichtigung der Sorten vorhanden sind, wird ebenfalls kurz
eingegangen. 
\paragraph{Vollständigkeit}
Betrachte die Regel \emph{Split}.
Sei $\sigma$ eine Substitution, so dass $\sigma f(t_1, t_2) = \sigma
C(s) = \sigma C[\sigma s]_p$ gilt. Für $p = \epsilon$ muss 
$\sigma C = \square$ und $\sigma f(t_1,t_2) = \sigma s$ gelten (Fall $i)$
der \emph{Split}-Regel)\footnote{Diese Regel wird auch für die
  $\sigmaLet$-Unifikation von Gleichungen der Form $\emptyset \ue
  C(s)$ verwendet. Da das Konstantensymbol nullstellig ist
  $\emptyset$, d.h. es kann kein Loch enthalten.}. 
Ist $p = iq$ ungleich $\epsilon$, dann folgt $p = 12$ oder $p = 21$,
weil alle Funktionssymbole in $\Sigma$ zweistellig sind. 
Für den ersten Fall ist das Loch von $C$ in einem Subterm von $t_1$,
d.h. wir haben $\sigma C = \sigma f(C'(\square),t_2)$ und 
$\sigma t_1 = \sigma C'(s)$ 
(Fall $ii)$ der \emph{Split}-Regel). 
Der Fall $p = 21$ wird analog durch \emph{Split $iii)$} abgedeckt. 

Betrachte die Regel \emph{Context Decomposition}. Sei $\sigma$ eine
Substitution, so dass $\sigma C(s) = \sigma D(t)$ gilt. D.h. nach der
Definition von Substitutionen haben wir
$\sigma C(\sigma s) = \sigma D(\sigma t)$, was 
$\sigma C[\sigma s]|_{p_1} = \sigma D[\sigma t]|_{p_2}$ entspricht. 
Entweder sind $p_1$ und $p_2$
vergleichbare Positionen, oder die beiden Positionen sind nicht
vergleichbar. Falls die Positionen vergleichbar sind, haben wir 
$p_1 \leq p_2$, was \emph{Context Decomposition $i)$} entspricht, oder 
$p_2 \leq p_1$, was \emph{Context Decomposition $ii)$} entspricht. 
Sind die beiden Position $p_1,p_2$ der Löcher in $\sigma C$ und
$\sigma D$ parallel (d.h. nicht vergleichbar), dann sei $f$ das
Funktionssymbol, das an der kleinsten Position steht, an der $p_1$
und $p_2$ vergleichbar sind. Der Kontext $E$ steht direkt über dieser
Position. Die Terme $s$ und $t$ stehen dann an nicht vergleichbaren
Positionen unterhalb der Position von $f$ in neuen Kontexten 
$C'$ und $D'$. Dieser Fall wird durch die
Transformationsmöglichkeiten \emph{Context Decomposition $iii)$} und
$iv)$ abgedeckt.   

Die Anwendung der zusätzlichen Regeln \emph{Context Variable
Elimination}, \emph{Context Orientation} und \emph{Sorted Fail
Context} verändern die Menge der Lösungen nicht (die Regeln sind
analog zu den jeweiligen Regeln für Variablen aus Definition \ref{def.unifikationsregeln}).

Die Regel \emph{Context Weakening} behandelt den Fall, dass eine
Gleichung zwischen einer Variablen und der Anwendung einer
Kontextvariablen auf einen Term in gelöster, aber nicht wohlsortierter
Form ist. Dann kann entweder die Kontextvariable zum leeren Kontext
instantiiert werden ($i)$, oder es gibt eine Termdeklaration, deren Sorte eine
untere Schranke der Sorten der beiden Terme ist, so dass die Variable
instantiiert werden kann $(ii)$. In $\sigmaLet$ tritt dieser Fall
beispielsweise für Gleichungen der Form $x_{Ap} \ue C_{T,T}(t)$ auf. 
Durch Anwendung von \emph{Context Weakening} erhält man 
$\set{x_{Ap} \ue abs(y_V,s_T), abs(y_V,s_T) \ue C_{T,T}(t)}$. 

\paragraph{Terminierung}
Der Terminierungsbeweis von
\citeA{comon_completion_1998-1} wird hier nicht nachvollzogen. 
Wir wollen nur auf einen wichtigen Punkt hinweisen: Die
Eingeschränktheit
(Def. \ref{def:eingschraenktes-unifikationsproblem}) eines
Unifikationsproblems wird durch die Transformationen \emph{Split}
und \emph{Context Decomposition} i.A. nicht erhalten, weil neue
Kontextvariablen an zwei Positionen in ein Unifikationsproblem
eingeführt werden. Betrachte beispielsweise \emph{Split $ii)$}:
$\set{f(t_1,t_2) \ue C(t)} \uplus P \Rightarrow \set{C \ue
  f(C'(\square),t_2), t_1 \ue C'(s)}\cup P$.
Im zweiten Unifikationsproblem taucht die neue Kontextvariable $C'$
zweimal auf. Allerdings kann die Gleichung $C \ue f(C'(\square),t_2)$
eliminiert werden (oder das Problem besitzt keine Lösung). 
Da $C$ keine neu eingeführte Kontextvariable ist, kommt $C$ in $P$
wegen der Eingeschränktheit nicht mehr vor. D.h. die Eliminierung von
$C$ führt nicht zu einer Vervielfachung von $C'$, und da die
Gleichung in gelöster Form ist, hat nur noch das
(einzelne) Vorkommen von $C'$ in der Gleichung $t_1 \ue C'(s)$
Einfluss auf den weiteren Verlauf der Unifikation (das Teilproblem ohne
die Gleichungen in gelöster Form bleibt in beschränkter Form). 
%Ist $C$ eine
%Kontextvariable, die neu eingeführt wurde, dann kann $C$ noch einmal
%im Unifikationsproblem vorkommen, allerdings nur auf der rechten Seite
%einer Gleichung in gelöster Form. 
%In diesem Fall wird der Kontext, der
%$C'$ enth\"alt durch
%\emph{Context Variable Elimination} in eine rechte Seite einer
%Gleichung in gelöster Form kopiert. 
%In beiden Fällen beeinflusst das mehrfache Vorkommen von $C'$ den
%weiteren Verlauf der Unifikation nicht, da alle Auftreten von $C'$
%immer auf der rechten Seite einer Gleichung in gelöster Form liegt. 
Diese Überlegung gilt analog für die anderen Transformationen, die
neue Kontextvariablen mehr als einmal einführen. 

\subsection{Wohlstrukturierung von $\sigmaLet$-Unifikatoren}
\label{sec:wohlstr-von-sigm}
Für ein $\sigmaLet$-Unifikationsproblem $P$ wird durch die oben
beschriebene Unifikationsprozedur ein Unifikator
$\sigma$ aus der vollständigen Menge der Unifikatoren von $P$
berechnet, der wohlsortiert, aber i.A. nicht wohlstrukturiert ist. 
Es wird ein allgemeinster Unifikator $\sigma$ bezüglich der
Instantiierungs-Quasiordnung auf wohlsortierten Substitutionen
berechnet, jedoch nicht bezüglich der Ordnung auf wohlstrukturierten
Substitutionen. 
%Das Problem ist, dass $\sigma$ Kontextvariablen
%enthalten kann, die nicht zulässig sind. Ausserdem können  
Wenn $P$ einen wohlstrukturierten Unifikator besitzt, dann kann aus
$\sigma$ ein solcher gewonnen werden, indem eine Substitution
$\delta$\footnote{Die nicht wohlstrukturiert, insbesondere nicht
  wohlsortiert sein muss.}
berechnet wird, so dass $\delta \sigma$ eingeschränkt auf die in $P$
vorkommenden Variablen wohlstrukturiert ist. Dazu instantiiert 
die Substitution $\delta$ neu eingeführte 
Kontextvariablen  in $\Ran(\sigma)$, die gegen Bedingungen
aus Definition \ref{def:wohlstrukturierte-subs} verstoßen. 
\begin{lemma}
\label{lemma:prozess-wohlstrukturierung}
Sei $P$ ein eingeschränktes $\sigmaLet$-Unifikationsproblem und 
$\sigma$ ein (wohlsortierter) Unifikator von $P$. 
Wenn $P$ einen wohlstrukturierten Unifikator besitzt, dann kann eine
Substitution $\delta$ berechnet werden, so dass $\delta
\sigma|_{\Var(P)}$ ein wohlstrukturierter Unifikator von $P$ ist. 

\end{lemma}
\begin{beweis}
Sei $\sigma$ ein nicht wohlstrukturierter
Unifikator eines $\sigmaLet$-Unifikationsproblems $P$. Gehe
folgendermaßen vor, um $\sigma$ wohlzustrukturieren: 
\begin{enumerate}
\item \sloppy
  %Instantiierung der nicht zulässigen Kontextvariablen von
  %$\sigma$ durch zulässige Kontexte.
  Sei $D$ eine Kontextvariable in $\Ran(\sigma)$, 
  die nicht zulässig ist. 
  Wenn $LS_{\sigmaLet}(D)$ eine Subsorte von $(T,T),(T,ST),(T,RT)$
  oder $(T,RWT)$ ist, dann sei $(R',S')$ die kleinste dieser vier Sorten
  für die $LS_{\sigmaLet}(D) \sqsubseteq (R',S')$ gilt und sei
  $D'$ eine neue Kontextvariable der Sorte $(R',S')$. Setze $\delta =
  \set{D \mapsto D'}$ und starte erneut bei Punkt 1 mit $\delta \sigma$.   
  Ist $LS_{\sigmaLet}(D)$ keine Subsorte einer der Sorten
  $(T,T),(T,ST),(T,RT)$ oder $(T,RWT)$, dann
  wähle eine Funktionsdeklaration $f(x_1,x_2)$ aus $\sigmaLet$, so dass
  $LS_{\sigmaLet}(D) \sqsubseteq LS_{\sigmaLet}(f(\square,x_2))$ oder
  $LS_{\sigmaLet}(D) \sqsubseteq
  LS_{\sigmaLet}(f(x_1,\square))$.\footnote{Die Wahl ist für
  alle nicht zulässigen Kontextvariablen eindeutig (wegen der
  Struktur von $\sigmaLet$).}
  Existiert für $D$ keine Funktionsdeklaration mit dieser
  Eigenschaft, dann stoppe mit der Antwort: $P$ besitzt keine
  wohlstrukturierte Lösung. 
  Wir gehen o.B.d.A. vom ersten Fall aus, der zweite funktioniert
  analog. Unterscheide folgende Fälle:
  \begin{itemize}
  \item Wenn die Sorte $S$ von $f(x_1,x_2)$ eine Subsorte von $T$ ist ($S
    \sqsubseteq T$), dann sei $D':S \rightarrow S_D$, mit $(R_D,S_D) =
    LS_{\sigmaLet}(D)$, eine neue Kontextvariable und $\delta = \set{D
    \mapsto D'(f(\square,x_2))}$. 
    Beginne den Prozess der Wohlstrukturierung erneut mit $\delta \sigma$.
  \item Wenn die Sorte von $f(x_1,x_2)$ keine Subsorte von $T$ ist, dann 
    sei $D':R_D \rightarrow \ls{x_1}$ eine neue Kontextvariable mit 
    $(R_D,S_D)= LS_{\sigmaLet}(D)$ und $\delta = \set{D \mapsto
    f(D'(\square),x_2))}$. Beginne den Prozess der Wohlstrukturierung
    erneut mit $\delta \sigma$. 
  \end{itemize}
  Sind alle Variablen in der Range von $\sigma$ zulässig, dann fahre mit
  folgendem Punkt fort. 
\item \"Uberpr\"ufe für alle Kontextvariablen $D$ 
  in $\Dom(\sigma)$ mit $\set{D \mapsto d}$ und $LS_{\sigmaLet}(D) =
  (R,S)$, ob die Bedingungen 3 und 4 aus Definition der 
  wohlstrukturierten Substitutionen
  (Def. \ref{def:wohlstrukturierte-subs}) %für $\set{D \mapsto d}$
  erfüllt sind. Ist eine der Bedingungen nicht erfüllt, dann breche
  mit der Antwort ab: $P$ besitzt keine wohlstrukturierte Lösung. 
  Wenn $D$ eine Kontextvariable der Sorte $(T,RT)$
  ist, dann prüfe, ob die Bedingung 5 aus Definition
  \ref{def:wohlstrukturierte-subs} für $d$ gilt 
  ($\forall p \in \Pos(d): d_p = letrec(s,t) \Rightarrow p =
  \epsilon$, wenn $s$ oder $t$ ein Kontext ist). 
  Gilt die Bedingung
  nicht, sei $p$ die Position in $\Pos(d)$, so dass $d|_{p} = letrec(s,t)$
  und einer der beiden Terme $s,t$ ist ein Kontext. Wenn alle Terme an
  Positionen $q < p$ als Wurzelsymbole Kontextvariablen $C_1, C_2,
  \dots \notin \Var(P)$ besitzen, dann sei $\delta = \set{C_1 \mapsto
  \square, C_2 \mapsto \square, \dots}$ und starte den Prozess der
  Wohlstrukturierung erneut mit $\delta \sigma$. Steht an einer
  Position $q$ ein Kontext mit einem Funktionssymbol als Wurzelsymbol,
  dann stoppe mit der Antwort: $P$ besitzt keinen wohlstrukturierten Unifikator. 
  
  Als Letztes ist noch zu prüfen, ob die Subkontexte in $d$ bezüglich
  der $\Lambda^{let}$-Kontextsyntax richtig geschachtelt sind 
  (Bedingung 2 und Bedingung 5 aus Definition \ref{def:wohlstrukturierte-subs}).
  Wenn für alle Kontexte $d_1,d_2$ mit
  Wurzelsymbolen ungleich $\setf{\cdot|\cdot}$ oder $bind$, so dass
  $d = d_1(d_2)$ die Bedingung
  $snd(LS_{\sigmaLet}(d_1)), snd(LS_{\sigmaLet}(d_2)) \sqsupseteq S$
  gilt, dann stoppe und gebe $\sigma|_{\Var(P)}$ als
  wohlstrukturierte Substitution zurück. 
  Seien $d_1,d_2$ Kontexte, für die diese Bedingung nicht gilt, dann 
  unterscheide folgende Fälle:
  \begin{itemize}
  \item $d_1$ ist ein Kontext der Sorte $R_1\rightarrow S_1$,
    so dass $S_1 \sqsubseteq S$ gilt.
    Wenn $d_2$ als Wurzelsymbol eine Kontextvariable $D_2:R_2
    \rightarrow S_2$ besitzt, so dass $D_2 \notin \Var(P)$ gilt
    und $glb(R_1,S)$ = $S'$ existiert, 
    dann sei $D'_2:R_2 \rightarrow S'$\footnote{Hat die
    Kontextvariable $D$ für die betrachtete Komponente $\set{D \mapsto d}$ 
    die Sorte $T \rightarrow RT$ und $glb(R_1,RWT)$ existiert, dann
    sei $D'_2$ eine neue Kontextvariable der Sorte $R_2 \rightarrow
    RWT$ (Bedingung 5 aus Definition
    \ref{def:wohlstrukturierte-subs}).}  
    und $\delta = \set{D_2 \mapsto D'_2}$.
    Starte erneut unter Punkt 1 mit
    $\delta \sigma$.
    Hat $d_2$ als Wurzelsymbol ein Funktionssymbol oder eine
    Kontextvariable $D_2 \in \Var(P)$ oder
    existiert $glb(R_1,S)$ nicht, dann stoppe mit der Antwort:
    $P$ besitzt keine wohlstrukturierte Lösung. 
  \item $d_1$ ist ein Kontext der Sorte $R_1 \rightarrow S_1$ mit 
    $S_1 \not\sqsubseteq S$.   
    Wenn das Wurzelsymbol von $d_1$ eine Kontextvariable $D_1$ ist, so dass
    $D_1 \notin \Var(P)$ gilt und $glb(S_1,S) = S'$ existiert, dann sei $D'_1:
    R_1 \rightarrow S'$\footnote{Bzw. $D'_1: R_1 \rightarrow RWT$, falls $D:T
    \rightarrow RT$ gilt und $glb(S_1,S)$ existiert (Bedingung 5 aus
    Definition \ref{def:wohlstrukturierte-subs}).}
    eine neue Kontextvariable und $\delta = \set{D_1 \mapsto D'_1}$. 
    Starte erneut unter Punkt 1 mit 
    $\delta \sigma$. Besitzt $d_1$ als Wurzelsymbol ein 
    Funktionssymbol oder eine Kontextvariable $D_1 \in \Var(P)$ oder
    existiert $glb(S_1,S)$ nicht, dann
    stoppe mit der Antwort: $P$ besitzt keinen wohlstrukturierten Unifikator. 
  \end{itemize}
Die Substitution $\delta$ erhält man durch die Komposition der
in den einzelnen Schritten berechneten $\delta$. $\qed$
\end{enumerate}
\end{beweis}

Für den im Beweis beschriebenen Prozess der Wohlstrukturierung eines 
(wohlsortierten) Unifikators $\sigma$ für ein eingeschränktes
$\sigmaLet$-Unifikationsproblem $P$ gilt:
\begin{itemize}
\item Der Prozess terminiert: Da $\sigma$ eine Substitution ist,
  müssen nur endlich viele nicht zulässige Kontextvariablen
  instantiiert werden. Die Sorten der neuen Kontextvariablen ($D'$)
  werden dabei so gewählt, dass sie zulässig sind (Punkt 1). 
  Um die Bedingungen 3, 4 und 5 aus Definition
  \ref{def:wohlstrukturierte-subs} zu überprüfen, müssen endlich
  viele Subterme in der Range von $\sigma$ inspiziert werden. Um die
  Bedingung 2 aus Definition \ref{def:wohlstrukturierte-subs} zu
  überprüfen, müssen endlich viele Kontextschachtelungen $d_1(d_2)$
  inspiziert werden (Punkt 2). 
%  Alle Kontextvariablen, die währendessen instantiiert werden, werden
%  durch zulässige Kontextvariablen instantiiert. 
\item Der Prozess ist vollständig: Die Menge der wohlstrukturierten
  Unifikatoren des $\sigmaLet$-Unifikationsproblems wird durch den
  Prozess nicht verändert. 
%  Die Instanzierung von nicht zulässigen Kontextvariablen ist
%  eindeutig, da alle $f(x_1,x_2) \in \sigmaLet$ eine eindeutig Sorte
%  besitzten. 
  %Falls eine Substitution wohlstrukturierbar ist, dann gibt es genau
  %eine 
\item Der Prozess berechnet einen wohlstrukturierten Unifikator aus 
  der vollständigen Menge der Unifikatoren des
  $\sigmaLet$-Unifikationsproblems $P$: Die Substitution $\sigma$ ist ein
  wohlsortierter Unifikator von $P$. Diese Substitution wird gemäß
  der Definition wohlstrukturierter Substitutionen angepasst. 
  
  %indem alle Bedingungen der Definition überprüft werden. 
\end{itemize}

Als Endresultat halten wir fest: 
Das eingeschränkte $\sigmaLet$-Unifikationsproblem mit
Kontextvariablen ist entscheidbar. Eine vollständige Menge von 
wohlstrukturierten Unifikatoren kann folgendermaßen berechnet werden:
Berechne zuerst mit der durch die Regeln in Definition
\ref{def:unifreg-kontextvar-ohne-sorten} beschriebenen
Unifikationsprozedur eine vollständige Menge von wohlsortierten
Unifikatoren für ein $\sigmaLet$-Unifikationsproblem $P$. 
Berechne dabei die vollständige Menge von Alternativen von
Transformationen.
Dieses Verfahren terminiert und ist vollständig.
%d.h. für jede Transformationsregel 
Besitzt $P$ wohlstrukturierte Lösungen, so können diese aus der
vollständigen Menge der Unifikatoren durch das im Beweis von Lemma
\ref{lemma:prozess-wohlstrukturierung} beschriebene Verfahren gewonnen
werden. Auch dieser Prozess terminiert und ist vollständig. 



%Das in obigem Beweis angegebene Verfahren zur Wohlstrukturierung einer
%$\sigmaLet$-Substition $\sigma$ nutzt die Tatsache aus, dass nicht
%zulässige Kontextvariablen in einer Substitution durch zulässige Kontexte
%instanziert werden können und neueingeführte Kontextvariablen durch
%Kontextvariablen instanziert werden können, so dass Kontext
%bezüglich der Schachtelungsbedingung  

Es wird ein ausführliches Beispiel zur Berechnung von
wohlstrukturierten Unifikatoren in zwei Schritten gegeben. 

\begin{beispiel}
\label{bsp:wohlstrukturierung}
Es sei folgendes $\sigmaLet$-Unifikationsproblem gegeben: 
$P = \set{C(s_T) \ue R(t_T)}$, mit den Kontextvariablensorten 
$C: T \rightarrow T$ und $R: T \rightarrow RT$ . Wir betrachten die
Berechnung der Menge aller wohlstrukturierten Unifikatoren für $P$. 

Anwendung der Regeln \emph{Context Decomposition $i)$} und $ii)$ auf $P$
ergibt die beiden Probleme \\
\begin{tabular}{l}
$\set{s_T \ue R'(t), R \ue C(R'(\square))}$, mit $R':T \rightarrow T$ und \\
$\set{t_T \ue C'(s), C \ue R(C'(\square))}$, mit $C':T \rightarrow T$. 
\end{tabular}\\
Das zweite Problem ist in gelöster, wohlstrukturierter From.
Das erste Problem ist in gelöster Form und es ist wohlsortiert,
allerdings ist es nicht wohlstrukturiert, da für 
$R \ue C(R'(\square))$ und $c_1 = C(\square), c_2 = R'(\square)$ gilt
$snd(LS_{\sigmaLet}(C)) = T \not\sqsupseteq RT = snd(LS_{\sigmaLet}(R))$
und da $C \in \Var(P)$ ist, kann die Sorte der Kontextvariablen nicht
angepasst werden. 

Die Regeln \emph{Context Decomposition $iii)$} und $iv)$ 
sind auf $P$ anwendbar, da die größte untere Schranke 
$glb(LS_{\sigmaLet}(C(s_T)),LS_{\sigmaLet}(R(t_T))) = 
glb(T,RT)= RT$ existiert. Jetzt müssen alle Funktionssymbole 
$f \in \sigmaLet$ betrachtet werden. 
\begin{itemize}
\item Sei $f = app:T \rightarrow T \rightarrow Ap$. Die Anwendung von
  \emph{Context Decomposition $iii)$} und $iv)$ ergibt die Unifikationsprobleme \\
  \begin{tabular}{rll}
    $\underrightarrow{iii)}$ & $\set{C \ue E(app(C'(\square),R'(t_T))),
    R \ue E(app(C'(s_T),R'(\square)))}$ & $:= P_1$, \\
    $\underrightarrow{iv)}$ & $\set{C \ue E(app(R'(t_T),C'(\square))),
    R \ue E(app(R'(\square),C'(s_T)))}$ & $:= P_2$.\\
  \end{tabular}\\
  Mit den Variablensorten $E:Ap \rightarrow RT, C':T \rightarrow T$ und
  $R':T \rightarrow T$. 
  Beide Probleme sind in gelöster Form und wohlsortiert und beide
  Probleme enthalten die nicht zulässige Kontextvariable 
  $E$, deren Sorte $(Ap,RT)$ eine Subsorte der
  $\sigmaLet$-Kontextvariablen Sorten $(T,T),(T,ST)$ und $(T,RT)$
  ist. Die kleinste dieser Sorten ist $(T,RT)$, d.h. 
  wir instantiieren $E$ mit einer neuen zulässigen Kontextvariablen
  dieser Sorte und setzten die Wohlstrukturierung mit 
  $\set{E \mapsto E'_{(T,RT)}}P_i, i = 1,2$ fort. 
  Jetzt müssen die Bedingungen zwei bis fünf aus Definition
  \ref{def:wohlstrukturierte-subs} überprüft werden. 
  Für $P_1$ haben wir für die rechte Seite der zweiten
  Gleichung $E'(app(C'(s_T),R'(\square))|_1 = app(C'(s_T),R'(\square))$ 
  und weil $R:T \rightarrow RT$ ist, wird
  die Bedingungen 4 aus Definition
  \ref{def:wohlstrukturierte-subs} nicht erfüllt.  
  %darf das Loch nicht im zweiten Argument
  %einer Applikation stehen 
  Das erste Problem repräsentiert somit keine wohlstrukturierte
  Lösung für P. 
  %Das Unifikationsproblem $P_2$ 
  %Im zweiten Unifikationsproblem steht das Loch in einem Subterm auf
  %der rechten Seite der zweiten Gleichung an einer zulässigen Position.
  %im ersten Argument der Applikation, 
  Im Unifikationsproblem $P_2$ ist Bedingung 5 aus Definition
  \ref{def:wohlstrukturierte-subs} an zwei Stellen verletzt: Für  
  $c_1 = E'(app(\square,C'(s_T)))$ mit der Sorte $T \rightarrow RT$ und
  $c_2 = R'(\square)$ mit der Sorte $T\rightarrow T$, gilt 
  $snd(LS_{\sigmaLet}(c_2)) = T \not \sqsupseteq RWT$.
  Da aber $R' \notin \Var(P)$ gilt, kann die Sorte von $R'$ angepasst
  werden, indem $R'': T \rightarrow glb(RWT,T)$ eine neue Kontextvariable
  ist. Außerdem ist $snd(LS_{\sigmaLet}(E')) = RT \not\sqsupseteq
  RWT$. Da aber $E'\notin \Var(P)$ gilt, instantiieren wir $E'$ mit
  einer neuen Variablen $E'': T \rightarrow RWT$. 
  Dann  repräsentiert $\set{R'_{(T,T)} \mapsto R^-_{(T,RWT)},
  E'_{(T,RT)} \mapsto E''_{(T,RWT)}}P_2$ 
  %, eingeschränkt auf die in $P$ vorkommenden Variablen, 
  eine wohlstrukturierte Lösung für $P$.
\item Sei $f = abs:V \rightarrow T \rightarrow Ab$. Durch die
  Anwendung von \emph{Context Decomposition $iii)$} und $iv)$ erhält
  man die Probleme \\
  \begin{tabular}{rll}
    $\underrightarrow{iii)}$ & $\set{C \ue E(abs(C'(\square),R'(t_T))),
    R \ue E(abs(C'(s_T),R'(\square)))}$ & $:= P_1$ \\
    & mit Variablensorten $E:Ab \rightarrow RT$, $C':T \rightarrow V$, $R':T \rightarrow T$. \\
    $\underrightarrow{iv)}$ & $\set{C \ue E(abs(R'(t_T),C'(\square))),
    R \ue E(abs(R'(\square),C'(s_T)))}$ & $:= P_2$\\
    & mit Variablensorten $E:Ab \rightarrow RT$, $C':T \rightarrow T$, $R':T \rightarrow V$. \\
  \end{tabular}\\
  Beide Unifikationsprobleme enthalten Kontextvariablen, die nicht
  zulässig sind. In $P_1$ sind $E$ und $C'$ nicht zulässig, in $P_2$
  sind $E$ und $R'$  
  nicht zulässig. Für die Sorte $T \rightarrow V$ der beiden
  Variablen existiert keine Funktionsdeklaration in $f \in \sigmaLet$, so
  dass $(T,V) \sqsubseteq LS_{\sigmaLet}(f(\square,x_2))$
  oder $(T,V) \sqsubseteq LS_{\sigmaLet}(f(x_1,\square))$.
  Die beiden Probleme sind deshalb nicht wohlstrukturierbar. 
\item Sei $f = letrec:U \rightarrow T \rightarrow L$. Die
  Anwendung von \emph{Context Decomposition $iii)$} und $iv)$
  resultiert in den Problemen \\
  \begin{tabular}{rll}
    $\underrightarrow{iii)}$ & $\set{C \ue E(letrec(C'(\square),R'(t_T))),
    R \ue E(letrec(C'(s_T),R'(\square)))}$ & $:= P_1$ \\
    & mit Variablensorten $E:L \rightarrow RT$, $C':T \rightarrow U$, $R':T \rightarrow T$. \\
    $\underrightarrow{iv)}$ & $\set{C \ue E(letrec(R'(t_T),C'(\square))),
    R \ue E(letrec(R'(\square),C'(s_T)))}$ & $:= P_2$\\
    & mit Variablensorten $E:L \rightarrow RT$, $C':T \rightarrow T$, $R':T \rightarrow U$. \\
  \end{tabular}\\
  Das Problem $P_1$ enthält zwei nicht zulässige Variablen $E$ und $C'$, die
  mit zulässigen Kontexten instantiiert werden können: 
  $E$ wird analog zu obigem Fall $f = app$ instantiiert.
  Für $C'$ betrachte die Funktionsdeklaration $b(x_V,u_T)$, für die gilt 
  $LS_{\sigmaLet}(C') = (T,U) \sqsubseteq
  LS_{\sigmaLet}(b(x_V,\square))$. Die Sorte $U$ ist keine Subsorte
  von $T$, deshalb sei $C''$ eine neue Kontextvariable der Sorte 
  $T \rightarrow LS_{\sigmaLet}(u_T) = T \rightarrow T$ und
  wir überprüfen, ob $\set{C' \rightarrow b(x_V,C''(\square)), E
  \mapsto E'_{(T,RT)}}P_1 = P'_1 = $\\
  \begin{tabular}{l}
    $\set{C \ue E'(letrec(b(x_V,C''(\square)),R'(t_T))), 
      R \ue E'(letrec(b(x_V,C''(s_T)),R'(\square)))}$
  \end{tabular}\\
  \sloppy
  wohlstrukturiert ist. Die zweite Gleichung von $P'_1$ 
  verstößt an zwei Stellen gegen  Bedingung 5 aus Definition
  \ref{def:wohlstrukturierte-subs}. 
  An der Position $p = 1$ des Kontextes
  $E'(letrec(b(x_V,C''(s_T)),R'(\square)))$ steht ein Kontext, der als
  Wurzelsymbol das Funktionssymbol $letrec$ besitzt. Der Kontext an der
  Position $q  = \epsilon, q < p$ besitzt als Wurzelsymbol eine
  Kontextvariable $E' \notin \Var(P)$, die durch den leeren Kontext
  instantiiert werden kann.
  Außerdem haben wir für
  $c_1 = E'(letrec(b(x_V,C''(s_T)),\square)), c_2 = R'(\square)$, 
  dass $snd(LS_{\sigmaLet}(c_2)) = T \not\sqsupseteq RWT$ gilt. Weil $R' \notin \Var(P)$
  gilt, kann die Sorte von $R'$ angepasst werden, so dass $\set{R'_{(T,T)}
  \mapsto R^-_{(T,RWT)}, E'_{(T,RT)} \mapsto \square}P'_1$ eine wohlstrukturierte Lösung von $P$
  repräsentiert. 

  Für $P_2$ sind $R':T \rightarrow U$ und $E: L \rightarrow T$ keine zulässigen
  Kontextvariablen, die auf die gleiche Weise wie oben beschrieben mit
  einem zulässigen Kontext instantiiert werden können. 
  %Nach einer Anpassung
  %der Sorten der neuen Kontextvariablen $R'$ (zu $R^-$ wie oben) gemäß Bedingung 5 aus 
  %Definition \ref{def:wohlstrukturierte-subs}, ist das Resultat: 
  Als Resultat erhalten wir: \\
  \begin{tabular}{l}
    $\set{C \ue letrec(b(x_V,R^-(t)),C'(\square)), 
      R \ue letrec(b(x_V,R^-(\square)),C'(s)} =: P'_2 $ \\
  \end{tabular}\\
  mit den Variablensorten  $C':T \rightarrow T$,
  $R^-:T \rightarrow RWT$. Das Problem repräsentiert eine
  wohlstrukturierte Lösung, allerdings ist der Kontext
  $letrec(b(x_V,R^-(\square)),C'(s))$ kein Reduktionskontext
  bezüglich der Definition von Reduktionskontexten in $\Lambda^{let}$.
  Damit der Kontext einen $\Lambda^{let}$-Reduktionskontext
  entspricht, muss $C'$ eine Kontextvariable der Sorte $T \rightarrow
  RWT$ sein und $s = x_V$ gelten. 
  Diese Bedingung kann durch den Algorithmus zur Wohlstrukturierung von
  Substitutionen berücksichtigt werden. Sie wurde nicht mit
  in die Beschreibung des Verfahrens aufgenommen, um die Notation nicht
  weiter zu verkomplizieren. Im vorliegenden Programm, das die
  Unifikation f\"ur $\sigmaLet$-Kontextvariablen implementiert wird diese
  Bedingung berücksichtigt. 
\item Sei $f = \setf{\cdot|\cdot}:B \rightarrow U \rightarrow U$. Die Anwendung von
  \emph{Context Decomposition $iii)$} und $iv)$ ergibt die
  Unifikationsprobleme \\
  \begin{tabular}{rll}
    $\underrightarrow{iii)}$ & $\set{C \ue E(\setf{C'(\square)|R'(t_T)}),
    R \ue E(\setf{C'(s_T)|R'(\square)})}$ & $:= P_1$ \\
    & mit Variablensorten $E:U \rightarrow RT$, $C':T \rightarrow B$, $R':T \rightarrow U$. \\
    $\underrightarrow{iv)}$ & $\set{C \ue E(\setf{R'(t_T)|C'(\square)}),
    R \ue E(\setf{R'(\square)|C'(s_T)})}$ & $:= P_2$\\
    & mit Variablensorten $E:U \rightarrow RT$, $C':T \rightarrow U$, $R':T \rightarrow B$. \\
  \end{tabular}\\
  Beide Probleme enthalten Kontextvariablen, die nicht zulässig sind,
  aber durch zulässige Terme instantiiert werden können. 
  Betrachte das Problem $P_1$:
  \begin{itemize}
  \item Wir haben $LS_{\sigmaLet}(E) =  (U,RT) \sqsubseteq
    LS_{\sigmaLet}(letrec(\square,u_T)))$ und $L \sqsubseteq T$. Deshalb
    setzen wir $\delta_1 = \set{E \mapsto E'(letrec(\square,u_T))}$,
    wobei $E'$ die Sorte $L \rightarrow RT$ hat. 
  \item Es gilt $LS_{\sigmaLet}(C') = (T,B) \sqsubseteq LS_{\sigmaLet}(b(x_V,\square)))$ und $B
    \not\sqsubseteq T$. Deshalb setze $\delta_2 = \set{C' \mapsto
    b(x_V,C''(\square))}$ mit $C'':T \rightarrow T$.
  \item Es gilt $LS_{\sigmaLet}(R') = (T,U) \sqsubseteq LS_{\sigmaLet}(b(y_V,\square)))$ und $B
    \not\sqsubseteq T$. Deshalb setze $\delta_3 = \set{C' \mapsto
    b(y_V,R''(\square))}$ mit $R'':T \rightarrow T$.
  \end{itemize}
  Die Anwendung $(\delta_1 \cup \delta_2 \cup \delta_3)P$ ergibt das Problem \\
  \begin{tabular}{lr}
   $\set{C \ue E'(letrec(\setf{b(x_V,C''(\square))|b(y_V,R''(t_T))},u_T)),$ & \\
   \phantom{\{}$    R \ue E'(letrec(\setf{b(x_V,C''(s_T))|b(y_V,R''(\square))},u_T))}$ & $=: P'_1$, 
  \end{tabular}\\
  das jetzt auf Wohlstrukturiertheit geprüft werden muss. 
  Dabei muss die Sorte der Variablen $R''$ angepasst werden
  und $E'$ muss mit dem leeren Kontext instantiiert werden: 
  $\set{R''_{(T,T)} \mapsto R^-_{(T,RWT}), E' \mapsto
  \square}P'_1 = $ \\
  \begin{tabular}{lr}
    $\set{C \ue letrec(\setf{b(x_V,C''(\square))|b(y_V,R^-(t_T))},u_T),$ & \\
   \phantom{\{}$R \ue letrec(\setf{b(x_V,C''(s_T))|b(y_V,R^-(\square))},u_T)}$ & \\
  \end{tabular}\\
  Das Problem ist in wohlstrukturierter, gelöster Form. Allerdings
  ist auch hier der Kontext
  $letrec(\setf{b(x_V,C''(s_T))|b(y_V,R^-(\square))},u_T)$
  kein Reduktionskontext in $\Lambda^{let}$. 
  Damit der Kontext ein Reduktionskontext ist, muss außerdem $u_T =
  R'^-[y_V]$ gelten (auch dieser Fall wird in der Implementierung
  korrekt berücksichtigt). 

  Für das Problem $P_2$ erfolgt die Wohlstrukturierung analog. 
\item Sei $f = b: V \rightarrow T \rightarrow B$. Dieser Fall lässt
  sich analog zu Fall $f = abs$ nicht wohlstrukturieren. 
\end{itemize}
Die vollständige Menge der wohlstrukturierten Unifikatoren für das 
Unifikationsproblem $\set{C(s_T) \ue R(t_T)}$ besteht somit aus folgenden Substitutionen:
\begin{enumerate}
\item $\set{t_T \mapsto C'(s), C \mapsto R(C'(\square))} $
\item $\set{C \mapsto E''(app(R^-(t_T),C'(\square))), R \mapsto E''(app(R^-(\square),C'(s_T)))} $
\item $\set{C \mapsto letrec(b(x_V,C''(\square)),R^-(t_T)), R \mapsto letrec(b(x_V,C''(s_T)),R^-(\square))} $
\item $\set{C \mapsto letrec(b(x_V,R^-(t)),C'(\square)), R \mapsto letrec(b(x_V,R^-(\square)),C'(s))} $ \\
       $\quad \text{mit}\; C':T \rightarrow RWT \; \text{und} \; s = x_V $
\item $\set{C \mapsto letrec(\setf{b(x_V,C''(\square))|b(y_V,R^-(t_T))},u_T), \\ 
  \phantom{\{} R \mapsto letrec(\setf{b(x_V,C''(s_T))|b(y_V,R^-(\square))},u_T)} $ \\
 $\quad \text{mit} \; u_T = R'^-[y_V] $
\item $\set{C \mapsto letrec(\setf{b(y_V,R^-(t_T))|b(x_V,C''(\square))},u_T), \\ 
  \phantom{\{} R \mapsto letrec(\setf{b(y_V,R^-(\square))|b(x_V,C''(s_T))},u_T)} $\\
  $\quad \text{mit} \; u_T = R'^-[y_V] $
\end{enumerate}
\end{beispiel}

\chapter{Berechnung von Überlappungen für Gabeldiagramme in $\sigmaLet$}
\label{cha:berechn-von-uberl}
Um einen vollständigen Satz von Gabeldiagrammen für eine interne
Reduktion zu berechnen, müssen zunächst alle möglichen
Überlappungen zwischen no-Reduktionen und der internen Reduktion
bestimmt werden (vgl. Abschnitt \ref{sec:berechn-von-uberl}).
In diesem Kapitel wird der Begriff der \emph{Überlappung} von
Reduktionsregeln formal definiert. Dazu orientieren wir uns an dem
Begriff der Überlappung, der in der Theorie der Termersetzungssysteme
verwendet wird \cite{baader_term_1998,bezem_term_2003}.

Zuerst wird in Abschnitt \ref{sec:sigmalet-kalkuel} der
$\sigmaLet$-Kalkül vorgestellt, der verwendet wird, um 
Überlappungen zu berechnen. Die Signatur $\sigmaLet$, deren Definition
sich über die Kapitel \ref{cha:unif-fur-terme-mit-sorten},
\ref{cha:ac-unifikation}, \ref{cha:unif-von-ketten} und \ref{cha:unif-von-kontexten} erstreckt, wird  
zusammengefasst angegeben, ebenso wie die Übersetzung
$\transl{\;}$, die $\Lambda^{let}$-Ausdrücke in $\sigmaLet$-Terme
übersetzt. Anschließend werden Reduktionsregeln und die
standardisierte Form der Auswertung, die Normalordnungsreduktion, für
$\sigmaLet$-Terme definiert. Die Reduktionsregeln in $\sigmaLet$
bilden die Reduktionsregeln aus $\Lambda^{let}$ nach. 
Die Normalordnungsreduktion in $\sigmaLet$ entspricht einer
eingeschränkten Normalordnungsreduktion in $\Lambda^{let}$. 

Im Abschnitt \ref{sec:berechnung-von-ueberlappungen-in-sigmaLet} wird
der Begriff der Überlappung formal definiert und eine Methode
%basierend auf der Unifikation linker Seiten von Reduktionsregeln 
%basierend auf der Berechnung so genannter \emph{kritischer Paare} für Reduktionsregeln 
zur Berechnung von Überlappungen in $\sigmaLet$ angegeben. 

\section{Der $\sigmaLet$-Kalkül}
\label{sec:sigmalet-kalkuel}
Die Signatur $\sigmaLet$ bildet die Basis, um Terme mit Sorten,
Kontextvariablen, einem links-kommutativen Funktionssymbol
$\setf{\cdot|\cdot}$ und Variablenketten darzustellen und zu
unifizieren. 

\begin{definition}
\label{def:sigaLet-alles}
Die Definition der Signatur $\sigmaLet$ 
%Das Funktionssymbol $\setf{\cdot|\cdot}$, das \letr-Umgebungen in
%$\sigmaLet$ ist links-kommutativ, d.h. seine Argumente sind
%vertauschbar (wie in Kapitel  beschrieben). 
%Für das Funktionssymbol $ch$ zur Darstellung von Variablenketten in
%$\sigmaLet$ gelten die in Kapitel  definierten 
und die Übersetzung
$\transl{\;}$, die $\Lambda^{let}$-Ausdrücke in Meta-Notation 
(die für die Definition von Reduktionsregeln in $\Lambda^{let}$
verwendet wird, (siehe Abschnitt \ref{sec:reduktionen}) 
in $\sigmaLet$-Termen übersetzt, 
ist in Abbildung
\ref{fig:sigmaLet-alles} zu sehen. 
Die Umkehrabbildung, die $\sigmaLet$-Terme in
$\Lambda^{let}$-Ausdrücke übersetzt, wird mit $\transl{\;}^-$
bezeichnet. 
\end{definition}

\begin{figure}[hbtp]
\centering
\fbox{
\begin{minipage}{0.98\textwidth}
\newcommand{\fktsort}[3]{#1 \rightarrow #2 \rightarrow #3}
\[\begin{array}{rllr}
\sigmaLet = \set{ 
& \multicolumn{2}{l}{\mathbf{Subsortdeklarationen:}} \\
%& A, V, \sqsubset T, \\ %\; B \sqsubset U& \\
& \multicolumn{2}{l}{Ab, Ap, V, L \sqsubset T, \quad Ap, L \sqsubset ST \sqsubset T, \quad  Ap, L \sqsubset RT \sqsubset ST,}  \\
& \multicolumn{2}{l}{Ap \sqsubset RWT \sqsubset RT, \quad B,K \sqsubset M \sqsubset U,} \\
%& B \sqsubset U,  & \\
& \multicolumn{2}{l}{\mathbf{Funktionsdeklarationen:}} \\
&  abs : \fktsort{V}{T}{Ab} & \mathsf{(Abstraktion)}, \\
&  app : \fktsort{T}{T}{Ap} & \mathsf{(Applikation)}, \\
&  letrec : \fktsort{U}{T}{L} & \mathsf{(\letr)}, \\
&  \setf{\cdot|\cdot} : \fktsort{M}{U}{U} & \mathsf{(\letr-Umgebung)}. &  \\
&  ch : \fktsort{B}{B}{K} & \mathsf{(Variablenkette)}, \\
&  bind : \fktsort{V}{T}{B} & \mathsf{(\letr-Bindung)},  \\
&  \emptyset : U & \mathsf{(leere \; \letr-Umgebung)} & } \\
%%&  kette : \fktsort{B}{B}{U} & \mathsf{(Kette \; von \; Bindugen)} \\
\end{array}\]
\end{minipage}}
\fbox{
\begin{minipage}{0.98\textwidth}
\[\begin{array}{rcl}
\transl{x}           & = & x_V \\
\transl{v}           & = & v_A \\
\transl{s}           & = & s_T \\
\transl{t}           & = & t_T \\
\transl{Env}         & = & e_U \\
\transl{\lambda x.s} & = & abs(\transl{x},\transl{s}) \\
\transl{(s \; t)}      & = & app(\transl{s},\transl{t}) \\
\transl{\letrecm{Env}{s}} & = & letrec(\transl{Env},\transl{s}) \\
\transl{\letrecm{Env}{s}} & = & letrec(\transl{Env},\transl{s}) \\
\transl{\set{Env, x_1 = s_1, \dots, x_n = s_n}} & = &
  \transl{\set{x_1=s_1, \dots, x_n=s_n, Env}} \\
\transl{\set{x_1 = s_1, \dots, Env, \dots, x_n = s_n}} & = &
  \transl{\set{x_1=s_1, \dots, x_n=s_n, Env}} \\
\transl{\set{x_1=s_1,x_2=s_2, \dots, x_n=s_n}} & = & \setf{\;\transl{x_1=s_1}\;|\;\transl{\set{x_2=s_2, \dots, x_n=s_n}}\;} \\
\transl{\set{\set{x_i=x_{i-1}}^n_{i=m},x_1=s_1, \dots}} & = & \setf{\transl{\set{x_i=x_{i-1}}^n_{i=m}}|\transl{\set{x_1=s_1, \dots}}} \\
\transl{\set{x=s, Env}} & = & \setf{\transl{x=s}|\transl{Env}} \\
\transl{\set{x=s}} & = & \setf{\transl{x=s}|\emptyset } \\
\transl{x=s} & = & bind(\transl{x},\transl{s}) \\
\transl{\set{x_i=x_{i-1}}^n_{i=m}}  & = & ch(bind(\transl{x_m},\transl{x_{m-1}}),bind(\transl{x_n},\transl{x_{n-1}})\\
\transl{C[s]}        & = & \transl{C}(\transl{s}) \quad \text{(analog für $S,R$ oder $R^-$)}\\
\transl{C}           & = & C:  T \rightarrow T \\
\transl{S}           & = & S:  T \rightarrow ST \\
\transl{R}           & = & R:  T \rightarrow RT \\
\transl{R^-}         & = & R^-: T \rightarrow RWT \\ 
\end{array}\]
\end{minipage}}
\caption{Die Signatur $\sigmaLet$ und die Übersetzung $\transl{\;}$. \label{fig:sigmaLet-alles}}
\end{figure}

%\begin{figure}[htbp]
%\centering
%\fbox{
%\begin{minipage}{0.98\textwidth}
%\[\begin{array}{rcl}
%\transl{x}           & = & x_V \\
%\transl{v}           & = & v_A \\
%\transl{s}           & = & s_T \\
%\transl{t}           & = & t_T \\
%\transl{Env}         & = & e_U \\
%\transl{\lambda x.s} & = & abs(\transl{x},\transl{s}) \\
%\transl{(s \; t)}      & = & app(\transl{s},\transl{t}) \\
%\transl{\letrecm{Env}{s}} & = & letrec(\transl{Env},\transl{s}) \\
%\transl{\letrecm{Env}{s}} & = & letrec(\transl{Env},\transl{s}) \\
%\transl{\set{Env, x_1 = s_1, \dots, x_n = s_n}} & = &
%  \transl{\set{x_1=s_1, \dots, x_n=s_n, Env}} \\
%\transl{\set{x_1 = s_1, \dots, Env, \dots, x_n = s_n}} & = &
%  \transl{\set{x_1=s_1, \dots, x_n=s_n, Env}} \\
%\transl{\set{x_1=s_1,x_2=s_2, \dots, x_n=s_n}} & = & \setf{\;\transl{x_1=s_1}\;|\;\transl{\set{x_2=s_2, \dots, x_n=s_n}}\;} \\
%\transl{\set{\set{x_i=x_{i-1}}^n_{i=m},x_1=s_1, \dots}} & = & \setf{\transl{\set{x_i=x_{i-1}}^n_{i=m}}|\transl{\set{x_1=s_1, \dots}}} \\
%\transl{\set{x=s, Env}} & = & \setf{\transl{x=s}|\transl{Env}} \\
%\transl{\set{x=s}} & = & \setf{\transl{x=s}|\emptyset } \\
%\transl{x=s} & = & bind(\transl{x},\transl{s}) \\
%\transl{\set{x_i=x_{i-1}}^n_{i=m}}  & = & ch(bind(\transl{x_m},\transl{x_{m-1}}),bind(\transl{x_n},\transl{x_{n-1}})\\
%\transl{C[s]}        & = & \transl{C}(\transl{s}) \quad \text{(analog für $S,R$ oder $R^-$)}\\
%\transl{C}           & = & C:  T \rightarrow T \\
%\transl{S}           & = & S:  T \rightarrow ST \\
%\transl{R}           & = & R:  T \rightarrow RT \\
%\transl{R^-}         & = & R^-: T \rightarrow RWT \\ 
%\end{array}\]
%\end{minipage}}
%\caption{übersetzung von $\Lambda^{let}$-Ausdrücken mit Meta-Notation
% in $\sigmaLet$-Terme. \label{fig:translation-lambdaLet-sigmaLet}}
%\end{figure}

%Die Definition der Ein-Schritt-Reduktionen 
%$\xrightarrow{no}$ und $\xrightarrow{i}$ in $\sigmaLet$ unterscheidet
%sich von der in $\Lambda^{let}$. 

\begin{definition}
\label{def:reduktion}
Zu einer Signatur $\Sigma$ ist eine \emph{Reduktionsregel} ein Paar 
$(l,r)$ von $\Sigma$-Termen. Reduktionsregeln werden geschrieben als 
$l \rightarrow r$ und falls sie einen Namen $\rho$ besitzen auch als
$\rho: l \rightarrow r$. 
\end{definition}
Zu der Reduktionsregel $\rho : l \rightarrow r$ wird eine Instanz von
$l$ (d.h. $\sigma l $ für eine Substitution $\sigma$) als
\emph{$\rho$-Redex} bezeichnet. 

\begin{definition}
\label{def:sigmaLet-reduktionen}
Die Reduktionsregeln des $\sigmaLet$-Kalküls sind in Abbildung
\ref{fig-is-reduktionen} zu sehen. 
\end{definition}

\begin{figure}[hbt]
\centering
\fbox{
\begin{minipage}{0.98\textwidth}
\begin{Bitemize}
\item [(llet-in)]
  $letrec(e_1,letrec(e_2,s)) \longrightarrow letrec(\setf{e_1|e_2},s)$ 
\item [(llet-e)]
  $letrec(\setf{b(x,letrec(e_2,s))|e_1},t) \longrightarrow letrec(\setf{b(x,s),e_2 |e_1},t)$ 
\item [(cp-in)] 
  $letrec(\setf{b(x_1,v),ch(b(x_2,x_1),b(x_n,x_{n-1}))|e},C(x_n))$ \\
  $\longrightarrow letrec(\setf{b(x_1,v),ch(b(x_2,x_1),b(x_n,x_{n-1}))|e},C(v))$ 
\item [(cp-e)] 
  $letrec(\setf{b(x_1,v),ch(b(x_2,x_1),b(x_n,x_{n-1})),b(y,C(x_n))|e},t)$ \\
  $\longrightarrow letrec(\setf{b(x_1,v),ch(b(x_2,x_1),b(x_n,x_{n-1})),b(y,C(v))|e},t)$ 
\item [(lapp)]   
  $app(letrec(e,s),t) \longrightarrow letrec(e,app(s,t))$ 
\item [(lbeta)] 
 $app(abs(x,s),t) \longrightarrow letrec(\setf{b(x,t)|\emptyset},s)$ 
\end{Bitemize}
\end{minipage}}
\caption{Reduktionsregeln des $\sigmaLet$-Kalküls. \label{fig-is-reduktionen}}
\end{figure}

Die Reduktionsregeln des $\sigmaLet$-Kalküls ergeben sich aus der
Übersetzung der Reduktionsregeln des $\Lambda^{let}$-Kalküls durch
die Abbildung $\transl{\;}$. 
Bei der Übersetzung der Regeln (\emph{lapp}) und (\emph{lbeta}) aus
$\Lambda^{let}$ wird der umschließende Reduktionskontext $C$
aufgrund der angepassten Definition der Reduktionsrelation (Definition 
\ref{def:sigmaLet-no-is-reduktion}) nicht mit übersetzt. 
Beispielsweise wird die linke Seite der (\emph{lbeta}) Regel
$C[((\lambda x.s) \;t )]$ aus $\Lambda^{let}$ übersetzt zu
$app(abs(x,s),t)$. 
Die rechten Seiten der $\sigmaLet$-Reduktionsregeln (\emph{llet-in})
und (\emph{llet-e}) enthalten Terme, die nicht wohlsortiert sind: In 
$letrec(\setf{e_1|e_2},s)$ und 
$letrec(\setf{b(x,s),e_2 |e_1},t)$ sind jeweils zwei Umgebungsvariablen
$e_1$ und $e_2$ der Sorte $U$ in den \letr-Umgebungen enthalten, was 
nach der Definition des Funktionssymbols 
$\setf{\cdot|\cdot}:M \rightarrow U \rightarrow U$ nicht zulässig
ist. Allerdings ist dies hier nicht problematisch, da für die
Berechnung von Überlappungen für Gabeldiagramme keine rechten
Seiten von Reduktionsregeln unifiziert werden müssen. 

\begin{definition}
\label{def:no-reduktionen-sigmaLet}
Die Abbildungen \ref{fig-no-reduktionen-1} und
\ref{fig-no-reduktionen-2} zeigen die eno-Reduktionsregeln des
$\sigmaLet$-Kalküls. 

Der Präfix "`e"' soll symbolisieren, dass die Reduktionsregeln in
$\sigmaLet$ nur eine Teilmenge der in $\Lambda^{let}$ m\"oglichen 
no-Reduktionen beschreiben. Die eno-Reduktionsregeln in $\sigmaLet$
sind eingeschränkt auf Reduktionsketten der Länge $\leq 3$. 

Die Vereinigung der Regeln (\emph{eno, llet-e i}) wird als (\emph{eno, llet-e}), 
die von (\emph{eno, cp-e i}) als (\emph{eno, cp-e}), 
die von (\emph{eno, lapp i.j}) als (\emph{eno, lapp}), 
und die Vereinigung von (\emph{eno, lbeta i.j}) wird als (\emph{eno, lbeta}) 
bezeichnet, für $i = 1,2,3,j=1,2,3,4$. 
%Analog zu den Bezeichnungen der Reduktionsregeln in Kapitel
%wird die Vereinigung von (\emph{eno, llet-in}) und (\emph{eno, llet-e})  
%als (\emph{eno,llet}) 
\end{definition}

\begin{figure}[p]
\centering
\fbox{
\begin{minipage}{0.98\textwidth}
\begin{Bitemize}
\item [(eno,llet-in)] 
  $letrec(e_1,letrec(e_2,s)) \longrightarrow letrec(\setf{e_1|e_2},s)$ 
\item [(eno,llet-e 0)] 
  $letrec(\setf{b(x,letrec(e_2,s))|e_1},R^-(x))$  \\
  $\longrightarrow letrec(\setf{b(x,s)),e_2 |e_1},R^-(x))$ 
\item [(eno,llet-e 1)] 
  $letrec(\setf{b(x,letrec(e_2,s)),b(x_1,R^-_1(x))|e_1},R^-(x_1))$ \\
  $\longrightarrow letrec(\setf{b(x,s)),b(x_1,R^-_1(x)),e_2|e_1},R^-(x_1))$ 
\item [(eno,llet-e 2)] 
  $letrec(\setf{b(x,letrec(e_2,s)),b(x_1,R^-_1(x)),b(x_2,R^-_2(x_1))|e_1},R^-(x_2))$ \\
  $\longrightarrow letrec(\setf{b(x,s)),b(x_1,R^-_1(x)),b(x_2,R^-_2(x_1)),e_2|e_1},R^-(x_2))$ 
\item [(eno,llet-e 3)] 
  $letrec(\setf{b(x,letrec(e_2,s)),b(x_1,R^-_1(x)),b(x_2,R^-_2(x_1)),$\\
  \phantom{$letrec\{|$}$b(x_3,R^-_3(x_2))|e_1},R^-(x_3))$ \\
    $\longrightarrow letrec(\setf{b(x,s)),b(x_1,R^-_1(x)),b(x_2,R^-_2(x_1)),$ \\
  \phantom{$\longrightarrow letrec\{|$}$b(x_3,R^-_3(x_2)),e_2|e_1},R^-(x_3))$ 
\item [(eno,cp-in)] 
  $letrec(\setf{b(x_1,v),ch(b(x_2,x_1),b(x_n,x_{n-1}))|e},R^-(x_n))$ \\
  $\longrightarrow letrec(\setf{b(x_1,v),ch(b(x_2,x_1),b(x_n,x_{n-1}))|e},R^-(v))$ 
\item [(eno,cp-e 0)] 
  $letrec(\setf{b(x_1,v),ch(b(x_2,x_1),b(x_n,x_{n-1})),$\\
  \phantom{$letrec\{|$}$b(y,R^-_0(app(x_n,s)))|e},R^-(y))$ \\
  $\longrightarrow letrec(\setf{b(x_1,v),ch(b(x_2,x_1),b(x_n,x_{n-1})),$\\
  \phantom{$\longrightarrow letrec\{|$}$b(y,R^-_0(app(v,s)))|e},R^-(y))$ 
\item [(eno,cp-e 1)] 
  $letrec(\setf{b(x_1,v),ch(b(x_2,x_1),b(x_n,x_{n-1})),b(y,R^-_0(app(x_n,s))),$ \\
  \phantom{$letrec\{|$}$b(y_1,R^-_1(y))|e},R^-(y_1))$ \\
  $\longrightarrow letrec(\setf{b(x_1,v),ch(b(x_2,x_1),b(x_n,x_{n-1})),b(y,R^-_0(app(v,s))),$ \\
  \phantom{$ \longrightarrow letrec\{|$}$b(y_1,R^-_1(y))|e},R^-(y_1))$ 
\item [(eno,cp-e 2)] 
  $letrec(\setf{b(x_1,v),ch(b(x_2,x_1),b(x_n,x_{n-1})),b(y,R^-_0(app(x_n,s))),$ \\
  \phantom{$letrec\{|$}$b(y_1,R^-_1(y)),b(y_2,R^-_2(y_1))|e},R^-(y_2))$ \\
  $\longrightarrow letrec(\setf{b(x_1,v),ch(b(x_2,x_1),b(x_n,x_{n-1})),b(y,R^-_0(app(v,s))),$ \\
  \phantom{$ \longrightarrow letrec\{|$}$b(y_1,R^-_1(y)),b(y_2,R^-_2(y_1))|e},R^-(y_2))$ 
\item [(eno,cp-e 3)] 
  $letrec(\setf{b(x_1,v),ch(b(x_2,x_1),b(x_n,x_{n-1})),b(y,R^-_0(app(x_n,s))),$ \\
  \phantom{$letrec\{|$}$b(y_1,R^-_1(y)),b(y_2,R^-_2(y_1)),b(y_3,R^-_3(y_2))|e},R^-(y_3))$ \\
  $\longrightarrow letrec(\setf{b(x_1,v),ch(b(x_2,x_1),b(x_n,x_{n-1})),b(y,R^-_0(app(v,s))),$ \\
  \phantom{$ \longrightarrow letrec\{|$}$b(y_1,R^-_1(y)),b(y_2,R^-_2(y_1)),b(y_3,R^-_3(y_2))|e},R^-(y_3))$ 
\end{Bitemize}
\end{minipage}}
\caption{Die eno-Reduktionsregeln des $\sigmaLet$-Kalküls (Teil 1). \label{fig-no-reduktionen-1}}
\end{figure}

\begin{figure}[p]
\centering
\fbox{
\begin{minipage}{0.98\textwidth}
\begin{Bitemize}
\item [(eno,lapp 1)] 
  $R^-(app(letrec(e,s),t)) \longrightarrow R^-(letrec(e,app(s,t)))$
\item [(eno,lapp 2)] 
  $letrec(e_1,app(letrec(e_2,s),t)) \longrightarrow letrec(e_1,letrec(e_2,app(s,t)))$
\item [(eno,lapp 3.0)] 
  $letrec(\setf{b(x,app(letrec(e_2,s),t))|e_1},R^-(x))$ \\
  $\longrightarrow letrec(\setf{b(x,letrec(e_2,app(s,t))|e_1},R^-(x))$
\item [(eno,lapp 3.1)] 
  $letrec(\setf{b(x,app(letrec(e_2,s),t)),b(x_1,R^-_1(x))|e_1},R^-(x_1))$ \\
  $\longrightarrow letrec(\setf{b(x,letrec(e_2,app(s,t)),b(x_1,R^-_1(x))|e_1},R^-(x_1))$
\item [(eno,lapp 3.2)] 
  $letrec(\setf{b(x,app(letrec(e_2,s),t)),b(x_1,R^-_1(x)),$ \\
  \phantom{$letrec\{|$}$b(x_2,R^-_2(x_1))|e_1},R^-(x_2))$ \\
  $\longrightarrow letrec(\setf{b(x,letrec(e_2,app(s,t)),b(x_1,R^-_1(x)),$ \\
  \phantom{$\longrightarrow letrec\{|$}$b(x_2,R^-_2(x_1))|e_1},R^-(x_2))$
\item [(eno,lapp 3.3)] 
  $letrec(\setf{b(x,app(letrec(e_2,s),t)),b(x_1,R^-_1(x)),$ \\
  \phantom{$letrec\{|$}$b(x_2,R^-_2(x_1)),b(x_3,R^-_3(x_2))|e_1},R^-(x_3))$ \\
  $\longrightarrow letrec(\setf{b(x,letrec(e_2,app(s,t)),b(x_1,R^-_1(x)),$ \\
  \phantom{$\longrightarrow letrec\{|$}$b(x_2,R^-_2(x_1)),b(x_3,R^-_3(x_2))|e_1},R^-(x_3))$
\item [(eno,lbeta 1)] 
 $R^-(app(abs(x,s),t)) \longrightarrow R^-(letrec(\setf{b(x,t)|\emptyset},s))$
\item [(eno,lbeta 2)] 
 $letrec(e,(app(abs(x,s),t))) \longrightarrow letrec(e,letrec(\setf{b(x,t)|\emptyset},s))$
\item [(eno,lbeta 3.0)] 
 $letrec(\setf{b(y,app(abs(x,s),t))|e},R^-(y))$ \\
 $\longrightarrow letrec(\setf{b(y,letrec(\setf{b(x,t)|\emptyset},s)|e},R^-(y))$
\item [(eno,lbeta 3.1)] 
 $letrec(\setf{b(y,app(abs(x,s),t)),b(y_1,R^-_1(y))|e},R^-(y_1))$ \\
 $\longrightarrow letrec(\setf{b(y,letrec(\setf{b(x,t)|\emptyset},s),b(y_1,R^-_1(y))|e},R^-(y_1))$
\item [(eno,lbeta 3.2)] 
 $letrec(\setf{b(y,app(abs(x,s),t)),b(y_1,R^-_1(y)),$ \\
 \phantom{$letrec\{|$}$b(y_2,R^-_2(y_1))|e},R^-(y_2))$ \\
 $\longrightarrow letrec(\setf{b(y,letrec(\setf{b(x,t)|\emptyset},s),b(y_1,R^-_1(y)),$ \\
 \phantom{$\longrightarrow letrec\{|$}$b(y_2,R^-_2(y_1))|e},R^-(y_2))$
\item [(eno,lbeta 3.3)] 
 $letrec(\setf{b(y,app(abs(x,s),t)),b(y_1,R^-_1(y)),$ \\
 \phantom{$letrec\{|$}$b(y_2,R^-_2(y_1)),b(y_3,R^-_3(y_2))|e},R^-(y_3))$ \\
 $\longrightarrow letrec(\setf{b(y,letrec(\setf{b(x,t)|\emptyset},s),b(y_1,R^-_1(y)),$ \\
 \phantom{$\longrightarrow letrec\{|$}$b(y_2,R^-_2(y_1)),b(y_3,R^-_3(y_2))|e},R^-(y_3))$
\end{Bitemize}
\end{minipage}}
\caption{Die eno-Reduktionsregeln des $\sigmaLet$-Kalküls (Teil 2). \label{fig-no-reduktionen-2}}
\end{figure}

\clearpage
Die eno-Reduktionsregeln des $\sigmaLet$-Kalküls ergeben sich durch
die Übersetzung der $\Lambda^{let}$-Ausdrücke, die durch die
verschiedenen Fälle der Definition der Normalordnungsreduktion in
$\Lambda^{let}$ bestimmt sind (Definition \ref{def-no}). 
Die eno-Reduktionsregeln in $\sigmaLet$ decken nur einen Teil der
möglichen no-Reduktionen aus $\Lambda^{let}$ ab. In
$\Lambda^{let}$ können no-Redexe mit Reduktionsketten beliebiger  
Länge der Form $\set{x_i=R^-_i[x_{i-1}]}^n_{i=m}$ vorkommen. 
Solche Reduktionsketten beliebiger Länge können in $\sigmaLet$ nicht
dargestellt werden. 
Deshalb werden im $\sigmaLet$-Kalkül nur Reduktionsregeln mit
Reduktionsketten einer Länge $\leq 3$ für die Berechnung der
Überlappungen verwendet. 
%{D.h. in $\sigmaLet$ wird nur mit einer
%Teilmenge aller in $\Lambda^{let}$ möglichen no-Reduktionen
%überlappt.}

%Da die no-Reduktionsregeln in $\sigmaLet$ nur zur
%Berechnung von überlappungen von Reduktionen verwe

\begin{definition}
\label{def:sigmaLet-no-is-reduktion}
Eine \emph{$\sigmaLet$-Reduktion} %$\xrightarrow{}$ ist
$\xrightarrow{}$ %\subseteq T(\sigmaLet,X,\CX) \times T(\sigmaLet,X,\CX)$ 
ist folgendermaßen definiert:
$s \xrightarrow{} t,$ gdw. es eine Reduktionsregel
$l \rightarrow r$, eine Substitution $\sigma$ und eine Position $p \in
\Pos(s)$ gibt, so dass $s|_p = \sigma(l)$ und $t = s[\sigma(r)]_p$. 

Eine \emph{eno-$\sigmaLet$-Reduktion} $\xrightarrow{eno}$
%$\xrightarrow{eno} \subseteq T(\sigmaLet,X,\CX) \times T(\sigmaLet,X,\CX)$ 
ist definiert durch:
$s \xrightarrow{eno} t,$ gdw. es eine eno-{Re\-duk\-ti\-ons\-re\-gel}
$l \rightarrow r$ und eine Substitution $\sigma$ gibt,
so dass $s = \sigma(l)$ und $t = \sigma(r)$ gilt.

Eine \emph{iX-$\sigmaLet$-Reduktion} $\xrightarrow{iX}$ für 
$X \in \set{\mathcal{C},\mathcal{S},\mathcal{R}}$ ist definiert durch:
$s \xrightarrow{iX} t,$ gdw. es eine Reduktionsregel
$l \rightarrow r$, eine Substitution $\sigma$ und eine Position $p \in
\Pos(s)$ gibt, so dass $\transl{s[\square]_p}^-$ ein Kontext der
Kontextklasse $X$ ist, $s|_p = \sigma(l)$ sowie $t = s[\sigma(r)]_p$ gilt 
und wenn $s$ eno-reduzierbar zu $t'$ ist $(s \xrightarrow{eno} t')$, dann 
gilt $t' \neq t$.
\end{definition}

%\begin{definition}
%\begin{enumerate}
%\item Das \emph{Muster} einer Reduktionsregel $\rho: l \rightarrow r$
%  ist definiert als der Multikontext $\epsilon(l)$, wobei $\epsilon$
%  die (nicht wohlsortierte) Substitution ist, die alle Variablen und
%  alle Kontextvariablen auf $\square$ abbildet, d.h. $\epsilon(x) =
%  \square$ für alle $x \in X \cup \CX$. 
%\item Sei $s$ ein Redex bezüglich der Reduktionsregel 
%  $\rho: l \rightarrow r$ und sei $P$ ein Muster von $\rho$. Dann ist
%  $P$ auch ein Muster des Redex $s$, ein so genanntes
%  \emph{Redex-Muster}. Es gilt $l = P[x_1, \dots, x_n]$ und 
%  $s = \sigma l = P[\sigma x_1, \dots, \sigma x_n]$ für bestimmte
%  Variablen $x_i \in X \cup \CX$ und eine Substitution $\sigma$. 
%  Die Terme $\sigma x_1, \dots, \sigma x_n$ werden als Argumente des
%  Redex $s$ bezeichnet. 
%\item Die Vorkommen zweier Redexe in einem Term $t$
%  \emph{überlappen}, wenn sich ihre Redex-Muster mindestens ein
%  Funktionssymbol teilen. Die überlappung zwischen
%  einem Redex $s$ und sich selbst, wird als \emph{triviale
%  überlappung} bezeichnet.
%\item Zwei Reduktionsregeln $\rho_1,\rho_2$ überlappen, wenn in einem
%  Term $t$ ein $\rho_1$-Redex $s_1$ und ein $\rho_2$-Redex $s_2$
%  vorkommen, so dass $s_1$ und $s_2$ überlappen. 
%\end{enumerate}
%\end{definition}

\section{Überlappungen von Reduktionsregeln in $\sigmaLet$}
\label{sec:berechnung-von-ueberlappungen-in-sigmaLet}
%%{\color{red}{Weshalb werden hier zwei Substitutionen $\sigma_1,\sigma_2$
%%verwendet?}}

Wir haben folgende Situation für Gabeldiagramme in $\sigmaLet$:
\[\xymatrix{%Vierecke
s  \ar@{->}[d]_{eno, l_1 \rightarrow r_1} \ar@{->}[rr]^{iS, l_2 \rightarrow r_2}& & t_2 \\
t_1 & & \\
}\]
wobei $l_1 \rightarrow s_1$ eine eno-Reduktionsregel ist 
%und es eine Position $p_1 \in \Pos(s)$
und es eine Substitution $\sigma_1$ gibt, so dass $s = \sigma_1 l_1$ und 
$t_1 = \sigma r$ gilt. 
%und $\transl{s[\square]_{p_1}}^-$ ist ein Reduktionskontext\footnote{Wir
%  schreiben im Folgenden $s[\square]_{p}$ ist ein Kontext einer
%  bestimmten Kontextklasse
%  und meinen damit, dass $\transl{s[\square]_{p}}^-$ ein Kontext
%  dieser Kontextklasse ist.}.
Die Reduktion $\xrightarrow{iS,l_2 \rightarrow r_2}$ ist eine interne
Reduktion in einem Oberflächenkontext. 
D.h. $l_2 \rightarrow r_2$ ist eine 
Reduktionsregel und es gibt eine Position $p \in \Pos(s)$
und eine Substitution $\sigma_2$, so dass $s|_{p} = \sigma_2 l_2$
und $\transl{s[\square]_{p}}^-$ ein Oberflächenkontext ist. 
Dann ist $t_2 = s[\sigma_2 r_2]_{p}$ und es gilt $t_1 \neq t_2$. 

Abhängig von der Position $p$ (bzw. von der Form des Subterms
$\sigma(l_1|_p)$) lassen sich verschiedene Fälle unterscheiden. 

%Der Fall, dass die Positionen $p_1,p$ parallel sind ($p_1 || p$), 
%d.h. $\sigma l_1$ und $\sigma l_2$ in verschiedenen Teilbäumen von 
%$s$ vorkommen, kann wegen der Struktur von eno-Reduktionen nicht
%auftreten 

%{\bf{Fall 1.}} 
%{Dieser Fall kann gar nicht auftreten, wegen der Struktur der Normalordnung!!}
%$p_1$ und $p_2$ sind in verschiedenen Subtermen von
%$s$, d.h. die Positionen sind parallel $(p_1 || p_2)$.  Wie man in Abbildung
%\ref{fig-no-overlap} sehen kann, ist es kein Problem das Gabeldiagramm zu
%schließen. 
%
%\begin{figure}[!htp]
%\label{fig-no-overlap}
%\center
%\includegraphics*{Abb.Overlap.Parallel.Konvergenz.eps}
%\caption{Keine Überlappung}
%\end{figure}

%{\bf{Fall 1.}} $p_1$ ist ein Präfix von $p_2$, d.h. es gibt eine
%Position $p$ (die möglicherweise leer ist), so dass gilt $p_2 = p_1p$. 
%Dann hat $s$ die folgende Form: 
%\begin{center}
%\includegraphics*{Abb.Overlap.Pos.eps}
%\end{center}

%Im weiteren Verlauf reicht es aus den Subterm $s|_{p_1} = \sigma_1
%l_1$ zu betrachten, da 
%\[\xymatrix{%Vierecke
%\sigma_1 l_1  \ar@{->}[d] \ar@{->}[r] & (\sigma_1 l_1)[\sigma_2 r_2]_{p} \ar@{.>}[d]^{*} \\
%\sigma_1 r_1 \ar@{.>}[r]^{*} & t \\
%}\]
%impliziet, dass $t_1 = s[\sigma_1 r_1]_{p_1} \xrightarrow{*}
%s[t]_{p_1} \xleftarrow{*} s[(\sigma_1 l_1)[\sigma_2 l_2]_{p}]_{p_1} =
%s[\sigma_2 r_2]_{p_2} = t_2$, wegen Kompatibilität von $\rightarrow$
%mit dem Kontext $s[\cdot]_{p_1}$. 

%Der Fall, dass $p_2$ ein (echter, d.h. $p$ ist nicht leer) Präfix von
%$p_1$ ist $(p_1 = p_2p)$, kann nicht auftreten,
%%\footnote{Für $p$ leer, d.h. $p_1 = p_2$, können die beiden Redexe
%%Überlappen, allerdings nicht an einer Variablenposition (vgl. Fall 2.2).}
%da es zu folgendem Widerspruch kommt: Sei $p_1 = p_2p$,
%wegen $s[\sigma_2 l_2[\sigma_1 l_1]_p]_{p_2} \xrightarrow{no} 
%s[\sigma_2 l_2[\sigma_1 r_1]_p]_{p_2}$ muss $\sigma_2 l_2[\square]_p$
%ein Reduktionskontext sein. 
%Allerdings gibt es keine Substitution $\sigma_2$, so dass gilt
%$\sigma_2 l_2[\square]_p$ ist ein Reduktionskontext. 
%{Das kann man zeigen, indem man die Struktur von Reduktionskontexten
%mit (internen) Reduktionsregeln vergleicht (ähnlich der Unifikation). Z.B. 
%$\set{(\lambd{x}{s} \; t) \ue (R^- \;t)} \Rightarrow
%\set{\lambd{x}{s} =\lightning R^-, s \ue t}$.}

%%WAS HIER FOLGT IST FALSCH
%%{\bf{Fall 2.B.1}} Der Redex $\sigma_1 l_1$ überlappt nicht direkt mit
%%$l_2$ sondern ist in $\sigma_2$ enthalten, d.h. $p=q_1 q_2$, so dass
%%$q_1$ eine Variablen Position von $l_2$ ist. Die Situation an der
%%Gabel ist folgende: 
%%%Dann hat $\sigma_2 l_2$
%%%die Folgenden Form: $\sigma_2 l_2[\sigma_1 l_1]_p$.
%%\[\xymatrix{%Vierecke
%%s[\sigma_2 l_2[\sigma_1 l_1]_p]_{p_2} \ar@{->}[d]_{no} \ar@{->}[r]^{i}& s[\sigma_2 r_2[\sigma_1 l_1]_{p}]_{p_2} \\ %\ar@{.>}[d]^{*}
%%s[\sigma_2 l_2[\sigma_1 r_1]_p]_{p_2} & \\ %\ar@{.>}[r]^{*} 
%%}\]
%%Diese Gabel kann geschlossen werden, wenn $\sigma_2 r_2\lochm_p$ ein
%%Reduktionskontext ist. Man benötigt folgendes Lemma:
%%\begin{lemma}
%%Sei $R \lochm $ ein Reduktionskontext. Dann kann man alle in $R \lochm $ enthaltenen
%%internen Redex mit internen Reduktionen reduzieren, wobei der
%%Resultierende Kontext $R' \lochm $ ein Reduktioskontext ist:
%%\[R\lochm \xrightarrow{i,a} R' \lochm \quad \mathsf{für \; alle \; internen\; Reduktion \; a}\]
%%und $R\lochm, R'\lochm$ sind Reduktionskontexte. 
%%\end{lemma}
%%\begin{beweis} Fallunterscheidung (Induktion?) Über die Struktur von
%%Reduktionskontexten
%%\end{beweis}
%%
%%Es besteht ausserdem noch die Möglichkeit, dass die interne Reduktion den
%%no-Redex löscht, die Gabel kann dann geschlossen werden
%%(vgl. Fall 2.A.1 und Abbildung \ref{fig-nest-3}).:
%%\[\xymatrix{%Vierecke
%%s[\sigma_2 l_2[\sigma_1 l_1]_p]_{p_2} \ar@{->}[d]_{no} \ar@{->}[r]^{i}& s[\sigma_2 r_2]_{p_2} \\ %\ar@{.>}[d]^{*}
%%s[\sigma_2 l_2[\sigma_1 r_1]_p]_{p_2} \ar@{.>}[ur]_i & \\ %\ar@{.>}[r]^{*} 
%%}\]
%
%Nun muss unterschieden werden, wie weit die beiden Redexe $\sigma_1
%l_1$ und $\sigma_2 l_2$ voneinander entfernt sind. 

{\bf{Fall 1.1}} Der interne-Redex $\sigma_2 l_2$ überlappt nicht direkt mit
$l_1$, sondern ist in $\sigma_1$ enthalten. D.h. es gilt $p=q_1 q_2$,
so dass $q_1$ eine Variablen-Position von $l_1$ ist. Dann hat
der eno-Redex $\sigma_1 l_1$ die Form: 
\begin{center}
\includegraphics*{pictures/Abb.Overlap.Nesting.Pos.eps}
\end{center}

Diese Überlappung wird als \emph{Schachtelung} der
Redexe bezeichnet: Der interne Redex kommt innerhalb einer Variablen 
des eno-Redex vor. Für diesen Fall kann 
das Gabeldiagramm immer auf die gleiche einfache Art 
geschlossen werden (siehe Abbildung \ref{fig-nest-1} und Lemma
\ref{lemma:schachtelung-von-redexen}). 


\begin{figure}[htb]

\center
\includegraphics*{pictures/Abb.Overlap.NonCrit.Red.eps}
\center
\caption{Schachtelung von Redexen. Ist $\sigma_1 r_1[\square]_{p'}$
  ein Reduktionskontext, dann gilt $A = eno$, sonst ist $A=iS$. \label{fig-nest-1}}
\end{figure}

Zum Schließen des Gabeldiagramms ist
auf der rechten Seite der Gabel nach der Reduktion des
internen Redex $\sigma_2 l_2$ eine 
eno-Reduktion von $\sigma_1 l_1$ notwendig. Diese ist möglich, da
%$s[\square]_{p_1}$ ein Reduktionskontext ist, 
$\sigma_1 l_1$ ein eno-Redex ist und die Reduktion des
internen Redex den %im Reduktionskontext $s[\square]_{p_1}$ beläßt%und ihn 
eno-Redex nicht zerstört, weil sich die beiden Redexe keine
Funktionssymbole teilen. 
Der resultierende Ausdruck ist $r = \sigma_1 r_1[\sigma_2 r_2]_{p'}$
($p' \in \Pos(\sigma r_1)$ ist die Position, des internen Redex
nach der eno-Reduktion). 
Nach der eno-Reduktion auf der linken Seite der Gabel zu $t_1$, 
kommen folgende Fälle in Betracht, um $t_1$ (durch eine interne oder eine
eno-Reduktion) zu $r$ zu reduzieren:
Sei $p' \in \Pos(\sigma_1 r_1)$ die Position, so dass $\sigma_1(r_1|_{p'}) =
\sigma_2 l_2$ gilt. Wenn $\transl{\sigma_1 r_1[\square]_{p'}}^-$ ein
Reduktionskontext ist, dann
%dann  ist auch $s[\sigma_1 r_1[\square]_p]_{p_1}$ ein Reduktionskontext 
%(da $s[\square]_{p_1}$ ein Reduktionskontext ist und Reduktionskontexte geschachtelt
%werden können). In diesem Fall 
kann $t_1 = \sigma_1 r_1[\sigma_2 l_2]_{p'}$ durch eine eno-Reduktion
von $\sigma_2 l_2$ zu $r$ reduziert werden. Ist $\sigma_1 r_1[\square]_{p'}$ kein
Reduktionskontext, kann $t_1$ durch eine iS-Reduktion von
$\sigma_2 l_2$ zu $r$ reduziert werden. 

%%Außerdem besteht die Möglichkeit, dass der i-Redex $\sigma_2 l_2$
%%nach der no-Reduktion mehrfach in $s$ auftaucht. 
%%Das Gabeldiagramm kann dann durch eine Folge von Reduktionen (no und
%%internen, abhängig davon, ob $\sigma_1 r_1 \lochm $ an der Position an der
%%$\sigma_2 l_2$ steht Reduktionskontext ist, oder nicht)
%%nach der no-Reduktion geschlossen werden, wie in Abbildung \ref{fig-nest-2}
%%beispielhaft für die Verdopplung des i-Redex zu sehen ist. 
%%
%%Der i-Redex kann durch die no-Reduktion aus $s$ verschwinden
%%(beispielsweise durch eine \seqc-, oder \casec-Reduktion). In diesem
%%Fall ist eine no-Reduktion nach der i-Reduktion ausreichend um das
%%Gabeldiagramm zu schließen, wie in Abbildung \ref{fig-nest-3} zu sehen
%%ist. 

{\bf{Fall 1.2.}} Die beiden linken Seiten der Reduktionsregeln $l_1$
und $l_2$ überlappen, d.h. $p \in \Pos(l_1)$ und $l_1|_p$ ist keine Variable und 
$\sigma_1(l_1|_p) = \sigma_2 l_2$. In diesem Fall ist $\sigma l_2$ ein nicht
trivialer Subterm von $\sigma l_1$ an der Position $p$. 
Dann hat $\sigma_1 l_1$ folgende Form: 
\begin{center}
\includegraphics*{pictures/Abb.Overlap.Crit.Pos.eps}
\end{center}

Dieser Fall ist eine echte so genannte \emph{kritische Überlappung}
der beiden Redexe. Die beiden Redexe teilen sich mindestens ein
Funktionssymbol. Dieser Fall der Überlappung ist eine Instanz eines
\emph{kritischen Paares}. Informell kann man ein
kritisches Paar verstehen als das Resultat der Unifikation 
der linken Seite einer (internen) Reduktionsregel mit einem
Nicht-Variablen-Subterm einer linken Seite einer anderen 
(eno) Reduktionsregel. 

\begin{definition}%[Kritisches Paare] 
\label{def:kritische-paare}
Seien $l_i \rightarrow r_i, i = 1,2$ 
zwei Reduktionsregeln mit umbenannten Variablen, so dass
$\Var(l_1,r_1) \cap \Var(l_2,r_2) = \emptyset$. 
Sei $p \in \Pos(l_1)$ eine Position in $l_1$, so dass $l_1|_p$ keine
Variable ist und $C$ eine vollständige Menge von
Unifikatoren für das Unifikationsproblem $l_1|_p \ue l_2$. 
Dann ist die \emph{Menge der kritischen Paare} definiert durch 
$\set{\left\langle \sigma r_1, \sigma(l_1)[\sigma r_2]_p) \right\rangle \; |\; \sigma \in C}$.
Elemente aus der Menge der kritischen Paare, können durch 
das Diagramm 
\[\xymatrix{%Vierecke 
\sigma l_1  \ar@{->}[d]_{l_1 \rightarrow r_1} \ar@{->}[rr]^{l_2 \rightarrow r_2} & & \sigma(l_1)[\sigma r_2]_p \\
\sigma r_1 & & \\
}\]
dargestellt werden.
Wenn zwei Reduktionsregeln eine Menge von kritischen Paaren 
erzeugen, sagt man, die beiden Reduktionsregeln \emph{überlappen}.
\end{definition}

Für eine eno-Reduktionsregel $l_1 \rightarrow r_1$ und eine
Reduktionsregel $l_2 \rightarrow r_2$ und alle Positionen $p \in
\Pos(l_1)$, so dass $p$ keine Position im Rumpf einer Abstraktion ist,
beschreiben die jeweiligen Mengen kritischer Paare alle Überlappungen
zwischen der eno-Reduktion, die durch $l_1 \rightarrow r_1$ gegeben
ist und der iS-Reduktion, die durch $l_2 \rightarrow r_2$ gegeben
ist. 
%{Die Menge der Mengen von kritischen Paaren für eine (interne)
%  Reduktionregel und eine eno-Reduktionreduktionsregel beschreiben alle
%  überlappungen für die nicht offensichtlich ist wie das
%  Gabeldiagramm geschlossen werden kann.}

%\begin{beispiel}
%Der Ausdruck $r = \letrecm{Env_1}{\letrecm{Env_2,x=\letrecm{Env_3}{s}}{t}}$ 
%enthält zwei kritisch überlappende Redexe. 
%\begin{center}
%{
%\begin{pspicture}(0,-3.205)(4.805,3.205)
%\definecolor{color1274b}{rgb}{0.6,0.6,0.6}
%\definecolor{color1277b}{rgb}{0.8,0.8,0.8}
%\pspolygon[linewidth=0.01,fillstyle=solid,fillcolor=color1274b](1.2,1.2)(0.0,1.2)(0.0,1.8)(1.4,3.2)(2.2,3.2)(4.6,1.2)(4.6,-0.4)(3.8,-0.4)(3.8,-1.4)(4.8,-2.6)(4.8,-3.2)(1.4,-3.2)(1.2,-3.2)(1.2,-2.4)(2.2,-1.4)(2.2,-0.4)(1.2,-0.4)(1.2,1.2)
%\usefont{T1}{ptm}{m}{n}
%\rput(1.7442187,2.83){\ttfamily{letrec}}
%\pspolygon[linewidth=0.01,fillstyle=solid,fillcolor=color1277b](1.4,1.2)(1.4,1.2)(1.4,1.2)(2.4,2.0)(3.4,2.0)(4.4,1.2)(4.4,-0.2)(3.6,-0.2)(3.6,-1.4)(4.6,-2.6)(4.6,-3.0)(1.4,-3.0)(1.4,-2.8)(1.4,-2.4)(2.4,-1.4)(2.4,-0.2)(1.4,-0.2)(1.4,1.2)
%\usefont{T1}{ptm}{m}{n}
%\rput(2.9442186,1.43){\ttfamily{letrec}}
%\usefont{T1}{ptm}{m}{n}
%\rput(2.9442186,-1.37){\ttfamily{letrec}}
%\usefont{T1}{ptm}{m}{n}
%\rput(0.63140625,1.43){$Env_1$}
%\usefont{T1}{ptm}{m}{n}
%\rput(1.8314062,0.03){$Env_2$}
%\usefont{T1}{ptm}{m}{n}
%\rput(1.8314062,-2.77){$Env_3$}
%\usefont{T1}{ptm}{m}{n}
%\rput(3.0414062,0.03){$x$}
%\usefont{T1}{ptm}{m}{n}
%\rput(4.211406,0.03){$t$}
%\usefont{T1}{ptm}{m}{n}
%\rput(4.231406,-2.77){$s$}
%\psline[linewidth=0.01cm](1.8,2.6)(3.0,1.6)
%\psline[linewidth=0.01cm](1.8,2.6)(0.6,1.6)
%\psline[linewidth=0.01cm](3.0,1.2)(1.8,0.2)
%\psline[linewidth=0.01cm](3.0,1.2)(3.0,0.2)
%\psline[linewidth=0.01cm](3.0,1.2)(4.2,0.2)
%\psline[linewidth=0.01cm](3.0,-0.2)(3.0,-1.2)
%\psline[linewidth=0.01cm](3.0,-1.6)(1.8,-2.6)
%\psline[linewidth=0.01cm](3.0,-1.6)(4.2,-2.6)
%\end{pspicture}}
%\end{center}
%
%In diesem Beispiel kann die Gabel leicht geschlossen werden:
%\[\begin{array}{rlr}
%& \letrecm{Env_1}{\letrecm{Env_2,x=\letrecm{Env_3}{s}}{t}} & (= r) \\
%\xrightarrow{i, \emph{llet-e}} & \letrecm{Env_1}{\letrecm{Env_2,Env_3,x=s}{t}} & \\
%\xrightarrow{n, \emph{llet-in}} & \letrecm{Env_1,Env_2,Env_3,x=s}{t} & \\ \hline
%& \letrecm{Env_1}{\letrecm{Env_2,x=\letrecm{Env_3}{s}}{t}} & (= r) \\
%\xrightarrow{n, \emph{llet-in}} & \letrecm{Env_1,Env_2,x=\letrecm{Env_3}{s}}{t} & \\
%\xrightarrow{n, \emph{llet-e}} & \letrecm{Env_1,Env_2,Env_3,x=s}{t} & \\ 
%\end{array}\]
%
%Dass die Gabel in dieser Art und Weise geschlossen werden kann,  muss
%nicht immer der Fall sein. Da sich bei einer kritischen Überlappung
%die Redexe Symbole in Ausdrücken teilen, könnte es vorkommen, dass die
%Reduktion eines Redex den anderen Redex zerstört. 
%\end{beispiel}
%
%%{\color{red}{Zusammenhang zwischen kritischen Paaren und vollst. Satz von
%%Gabeldiagrammen: Wenn alle kritischen Paare zusammenführbar
%%(joinable) sind, dann ist ein vollst. Satz von Gabeldiagrammen
%%gefunden.}}
%

Zur Berechnung aller Überlappungen einer iS-Reduktion mit
eno-Reduktionen geht man folgendermaßen vor: 
Für alle eno-Reduktionsregeln $l_1 \rightarrow r_1$ und 
eine Reduktionsregel $l_2 \rightarrow r_2$ (die interne Reduktion) und
für alle Positionen $p \in \Pos(l_1)$, so dass 
$l_1|_p$ keine Variable und kein Subterm im Rumpf einer
Abstraktion ist, werden variablendisjunkte Varianten von $l_1|_p$ und
$l_2$ unifiziert. Die so bestimmten Mengen der kritischen
Paare beschreiben alle Überlappungen der internen Reduktion in einem
Oberflächenkontext, die durch die $l_2 \rightarrow r_2$ bestimmt ist,
mit eno-Reduktionen. 

Zur Unifikation wird die Unifikationsprozedur verwendet, die sich aus
der Vereinigung 
\begin{itemize}
\item der Unifikationsregeln für Terme mit Sorten (aus Definition \ref{def.unifikationsregeln}), 
\item der Unifikationsregeln für Terme mit Kontextvariablen
  (Definition \ref{def:unifreg-kontextvar-ohne-sorten}) und
\item der Unifikationsregeln für Terme mit dem links-kommutativen
  Funktionssymbol $\setf{\cdot|\cdot}$ und dem Funktionssymbol $ch$ für
  Variablenketten beliebiger Länge (Definitionen
  \ref{def:uni-regel-ketten}, \ref{def:uni-regeln-ketten-ketten} und
  \ref{def:uni-regeln-ketten-ketten-2}) 
\end{itemize}
ergibt. 
%Die Unifikationsprozedur terminiert und die
%vollständige Menge $C$ der berechneten Unifikatoren ist endlich.
Die Unifikationsprozeduren zur Unifikation von Termen mit Sorten,
Termen mit Kontextvariablen und Termen mit einem links-kommutativen
Funktionssymbol sind vollständig. Von der Unifikationsprozedur für
Terme mit Variablenketten wird angenommen, dass sie
überlappungs-vollständig ist\footnote{D.h. Es wird angenommen, dass
  alle Unifikatoren, die zur Berechnung aller Überlappung notwendig
  sind, durch die Unifikationsprozedur berechnet werden.}.
D.h. die Menge der kritischen Paare kann durch die
Unifikationsprozedur, die sich aus der Vereinigung der Regeln der
einzelnen Unifikationsprozeduren ergibt, berechnet werden.   

Aufgrund der Eingeschränktheit der eno-Reduktion in $\sigmaLet$
gegenüber der no-Reduktion in $\Lambda^{let}$ wird mit dieser Methode
nur eine Teilmenge aller Überlappung berechnet, die in 
$\Lambda^{let}$ möglich sind. 

\chapter{Implementierung und Ergebnisse}
\label{cha:impl-und-ergebn}
Im Rahmen der vorliegenden Arbeit ist eine Implementierung entstanden,
die zu einer gegebenen iS-Reduktion 
eine vollständige Menge von Gabeldiagrammen durch die Überlappung mit 
eno-{Re\-duk\-tio\-nen} (eingeschränkten no-Reduktionen, siehe
Definition \ref{def:no-reduktionen-sigmaLet})  
berechnet. 
Der Kern des Programms, das in der funktionalen Programmiersprache
Haskell entwickelt wurde, besteht aus einem Unifikationsalgorithmus zur
Unifikation von Termen mit Sorten, Kontextvariablen mit Sorten, einem
links-kommutativen Funktionssymbol und Variablenketten beliebiger
Länge.  

\fbox{
\begin{minipage}{0.98\textwidth}
Der Quelltext des Haskell-Programms ist unter folgender URL abrufbar: 
\begin{center}
\url{http://www.xylon.de/rau/}.
\end{center}
Zur Ausführung des Programms wird der Haskell Compiler \emph{GHC} in
einer Version $\geq 6.10.1$ benötigt, der unter der URL
\url{http://www.haskell.org/ghc/} erhältlich ist. 

Wird das Programm compiliert oder in den GHC-Interpreter geladen, 
muss als Option \texttt{--fglasgow-exts} angegeben werden. 
\end{minipage}}

Die Implementierung ist zu Beginn der Bearbeitung des Themas
in einer explorativen Phase entstanden. Zu diesem Zeitpunkt waren die
verschiedenen Konzepte, die es bei der Unifikation zu berücksichtigen
gilt, teilweise noch in anderer Form formuliert. 
Beispielsweise wurden die in $\Lambda^{let}$-Reduktionsregeln
(Definition \ref{def:reduktionen})
enthaltenen Variablen $s,t,x,y,Env,R^-,R,C$ und $v$ als Metavariablen bezeichnet. 
Der Begriff der Metavariablen war informell definiert: 
Für eine bestimmte Metavariable können Ausdrücke oder andere
Metavariablen eines entsprechenden Typs
eingesetzt werden. D.h. für $s,t$ können beliebige Ausdrücke, 
für $x,y$ Variablen, 
für $Env$ \letr-Umgebungen,
für $R^-,R,C$ beliebige Kontexte einer entsprechenden Kontextklasse
und für $v$ Abstraktionen eingesetzt werden. 
Das Konzept der Metavariablen ist dem Konzept der Variablen mit Sorten
sehr ähnlich. So entsprechen die Metavariablen $s,t$ Variablen der
Sorte $T$, Metavariablen $x,y$ entsprechen Variablen der Sorte $V$, usw.
Allerdings ist in der Literatur, die sich mit Unifikationstheorien
befasst, von Termen und Variablen mit Sorten und nicht von
Metavariablen die Rede. In der frühen Phase der Bearbeitung wurde das
Programm basierend auf dem Begriff von Metavariablen entwickelt.

Des weiteren verwendet das Programm zur Darstellung der zu
unifizierenden Objekte Ausdrücke, die in ihrer Gestalt 
eher der Syntax von $\Lambda^{let}$-Ausdrücken als der Syntax
von $\sigmaLet$-Termen entsprechen. Ausdrücke und Terme sind
verwandte Begriffe, allerdings hat das \letr-Konstrukt in
$\Lambda^{let}$ keine feste Stelligkeit. Im theoretischen Teil dieser
Arbeit wurden deshalb die Funktionssymbole $letrec$ und 
$\setf{\cdot|\cdot}$ der Signatur $\sigmaLet$ eingeführt, die über
eine feste Stelligkeit verfügen. 
In der Literatur wird Unifikation im Rahmen von Termen und nicht
von Ausdrücken behandelt.
Im Programm werden die Ausdrücke bei der Unifikation im wesentlichen
wie Terme behandelt, allerdings werden keine expliziten Terme sondern
Ausdrücke unifiziert. 

Die Regeln des Programms, die zur Unifikation 
der in $\Lambda^{let}$-Reduktionsregeln enthaltenen Konstrukten
verwendet werden, sind durch eine intuitive Herangehensweise
entstanden. Die Überlegungen, die zum Entwurf der Unifikationsregeln
angestellt wurden, waren immer von der Art:
Gegeben eine Unifikationsgleichung zwischen Ausdrücken, welche
Möglichkeiten bestehen, die Ausdrücke zu unifizieren. 
Für die Gleichung 
\[\letrecm{Env_1,x_1=s_1}{s} \ue \letrecm{Env_2,y_1=t_1}{t}\]
besteht beispielsweise nur die Möglichkeit die beiden 
\letr-Umgebungen untereinander sowie $s$ mit $t$ zu unifizieren. 
Diese Unifikationsmöglichkeiten entsprechen der Anwendung 
der Regel \emph{Decomposition}, wenn Terme unifiziert werden. 
Da \letr~ in $\Lambda^{let}$ ebenso wenig ein Funktionssymbol ist, wie
die Konstrukte Applikation und Abstraktion, wird bei der Unifikation
von Ausdrücken für alle möglichen Kombinationen von Konstrukten in
Unifikationsgleichungen eine separate Regel benötigt, die der
\emph{Decomposition}-Regel für Terme entspricht:
\[\begin{array}{ll}
\multicolumn{2}{l}{\mathbf{Dec \; Abs}} \\
 \set{\lambd{ x}{s} \ue \lambd{ y}{t}} \uplus P  \Rightarrow \set{ x \ue  y,  s \ue  t} \cup P & \\
\multicolumn{2}{l}{\mathbf{Dec \; App}} \\
\set{(f \; s) \ue (g \; t)} \uplus P  \Rightarrow  \set{f \ue g, s \ue t} \cup P & \\
\multicolumn{2}{l}{\mathbf{Dec \; \letr}} \\
\set{\letrecm{Env_1}{s} \ue \letrecm{Env_2}{t}} \uplus P  \Rightarrow \\
\quad \set{Env_1 \ue Env_2, s \ue t} \cup P & \\
\multicolumn{2}{l}{\mathbf{Symbol \; Clash \; \letr / App}} \\
\set{\letrecm{Env}{t} \ue \lambd{x}{s}} \uplus P \Longrightarrow \bot & \\
\dots
\end{array}\]
Das intuitive Vorgehen beim Entwurf der Unifikationsregeln für das
Programm, die Verwendung von Metavariablen und die syntaktische
Repräsentation in Form von Ausdrücken resultiert im wesentlichen in
Regeln, die den Unifikationsregeln entsprechen, die im theoretischen
Teil dieser Arbeit 
beschrieben werden. Allerdings weicht die Formulierung der
einzelnen Regeln des Programms teilweise von Formulierungen ab, die in
der Unifikationsliteratur gebräuchlich sind. 
Aus diesem Grund war es nach der Entwicklung des Programms schwierig, 
Resultate aus dem Bereich der Unifikationstheorien zum Beweis der
Terminierung und Vollständigkeit des programmierten
Unifikationsalgorithmus zu verwenden. 
Da diese beiden Eigenschaften aber zentral für die Berechnung aller
möglichen Überlappungen für Gabeldiagramme ist, 
wurde in der zweiten Phase der Bearbeitung des Themas ein stärkerer
Bezug zu existierenden Theorien hergestellt, um formale Aussagen über die Eigenschaften
des Unifikationsalgorithmus zu treffen. 
%um Aussagen über die Terminierung und Vollständigkeit des
%Unifikationsalgorithmus zu treffen. 
Daraus resultiert eine
gewisse Diskrepanz zwischen dem Programm und den vorgestellten
Theorien, die aufgrund der Beschränkung des Bearbeitungszeitraums 
im Rahmen dieser Arbeit nicht mehr behoben werden konnte. 
Die Anpassung des Programms an die vorgestellten Unifikationstheorien
muss in zukünftigen Arbeiten erfolgen.
Die Diskrepanz bezieht sich nur auf die Formulierung der
Unifikationsregeln: 
Die Unifikationsregeln des Programms sind nicht an allen Stellen exakt
so formuliert, wie die Unifikationsregeln der vorgestellten Theorien. 
Die Unifikationsmöglichkeiten, die durch die Regeln des Programms
beschrieben werden, decken trotzdem alle Unifikationsmöglichkeiten
ab, die durch die Regeln der verschiedenen Theorien gegeben sind. 
Um diese Behauptung zu stützen, geben wir eine Reihe von
Beispielaufrufen wichtiger Funktionen des Programms an, die verwendete
Unifikationsregeln illustrieren, und vergleichen sie mit den
Ergebnissen, die sich aus den Regeln der Unifikationstheorien
ergeben. 

%Die \emph{Tautology} und \emph{Orientation} Regeln des Programms
%entsprechen den jeweiligen Regeln zur Unifikation von Termen mit
%Sorten (Definition ). 
%\[
%\begin{array}{llrl}
%\mathbf{Tautology}\\
%\set{s \ue s} \uplus P 
%  \Rightarrow  \cup \; P \\
%\mathbf{Orientation} \\
%\set{s \ue \Delta m} \uplus P  
%  \Rightarrow  \set{\Delta m \ue s} \cup P \\
%\quad \text{wenn $\Delta m$ eine beliebige Metavariable und $t$
%  keine Metavariable ist.}
%\end{array}\]
%
%\[
%\begin{array}{llrl}
%\mathbf{Dec \; Abs}\\
%\set{\lambd{ \Delta x}{s} \ue \lambd{ \Delta y}{t}} \uplus P 
%  \Rightarrow  \set{ \Delta x \ue  \Delta y,  s \ue  t} \cup P \\
%\mathbf{Dec \; App} \\
%\set{(s \; t) \ue (s' \; t')} \uplus P  
%  \Rightarrow  \set{s \ue s', t \ue t'} \cup P \\
%\mathbf{Dec \; Let} \\
%\set{\letrecm{Env_1}{s} \ue \letrecm{Env_2}{t}} \uplus P \\
%\quad  \Rightarrow  \set{Env_1 \ue Env_2, s \ue t} \cup P \\
%\mathbf{Symbol \; Clash \; Abs/App}  \\
%\set{\lambd{ \Delta x}{s} \ue (t \; u)} \uplus P 
%  \Rightarrow  \bot \\
%\mathbf{Symbol \; Clash \; Abs/\letr}  \\
%\set{\lambd{ \Delta x}{s} \ue \letrecm{Env}{t}} \uplus P 
%  \Rightarrow  \bot \\
%\mathbf{Symbol \; Clash \; App/Abs} \\
% \set{(s \; t) \ue \lambd{ \Delta y}{u}} \uplus P 
%  \Rightarrow  \bot \\
%\mathbf{Symbol \; Clash \; App/\letr} \\ \set{(s \; t) \ue \letrecm{Env}{u}} \uplus P 
%  \Rightarrow  \bot \\
%\mathbf{Symbol \; Clash \; \letr/App} \\ \set{\letrecm{Env}{s} \ue (t \; u)} \uplus P 
%  \Rightarrow  \bot \\
%\mathbf{Symbol \; Clash \; \letr/Abs} \\ \set{\letrecm{Env}{t} \ue \lambd{\Delta x}{s}} \uplus P 
%  \Rightarrow  \bot \\
%\end{array}
%\]
%{Die Metavariablen werden durch ein vorangestelltes $\Delta$ gekennzeichnet.}
%
%Die Regeln decken exakt die Unifikationsmöglichkeiten ab, die durch
%die Regeln \emph{Decomposition} und \emph{Symbol Clash}  
%zur Unifikation von Termen mit Sorten definiert sind (Definition ). 
%
%\[\begin{array}{llrl}
%\mathbf{Eliminate \; \Delta s} \\
% \set{\Delta s \ue t} \uplus P  \Rightarrow  
%  \set{\Delta s \ue t} \cup \set{\Delta s \mapsto t}(P) \\
%  \text{wenn} \; \Delta s \; \text{eine Metavariable für Ausdrücke
%    und $\Delta s$ nicht in $t$ vorkommt.}\\
%\mathbf{Occ \; Tmv}  \set{\Delta t \ue s} \uplus P  \Rightarrow  
%  \bot \quad \text{wenn} \; \Delta t \in \mathcal{T}mv(s) \;
%  \text{und} \; \Delta t \ne s \\
%\mathbf{Fail}  \set{\Delta t \ue \Delta C\lochm} \uplus P  \Rightarrow 
%  \bot \\
%\end{array}\]

\section{Implementierung}
\label{sec:programm}
Zuerst werden kurz die wichtigsten Datenstrukturen vorgestellt, die im   
Programm zur Darstellung von Ausdrücken verwendet werden. 
Dann werden die zentralen Funktionen des Programms besprochen, die
Unifikationsgleichungen transformieren, kritische Paare und eine
vollständige Menge von Gabeldiagrammen berechnen. 

\subsection{Datenstrukturen für Ausdrücke}
\label{sec:datenstrukturen}

Folgende Datenstrukturen werden zur Darstellung von Metavariablen im Programm
verwendet:
\begin{tabbing}
\qquad\=\hspace{\lwidth}\=\hspace{\cwidth}\=\+\kill
${\mathbf{data}\;\Conid{Tmv}\mathrel{=}\Conid{Tmv}\;\Conid{VName}}$ \\%\;\mathbf{deriving}\;(\Conid{Show},\Conid{Eq})}$\\
${\mathbf{data}\;\Conid{Vmv}\mathrel{=}\Conid{Vmv}\;\Conid{VName}}$ \\%\;\mathbf{deriving}\;(\Conid{Show},\Conid{Eq})}$\\
${\mathbf{data}\;\Conid{Wmv}\mathrel{=}\Conid{Wmv}\;\Conid{VName}}$ \\%\;\mathbf{deriving}\;(\Conid{Show},\Conid{Eq})}$\\
${\mathbf{data}\;\Conid{Emv}\mathrel{=}\Conid{Emv}\;\Conid{VName}}$\\%\;\mathbf{deriving}\;(\Conid{Eq})}$\\
${\mathbf{data}\;\Conid{Cmv}\mathrel{=}\Conid{Cmv}\;\Conid{VName}\;\Conid{CType}}$.\\%\;\mathbf{deriving}\;(\Conid{Eq})}$\\
%${\mathbf{data}\;\Conid{CType}\mathrel{=}\Conid{C}\mid \Conid{S}\mid \Conid{R}\mid \Conid{Rw}$\\%\;\mathbf{deriving}\;(\Conid{Show},\Conid{Eq})}$.
\end{tabbing}
Alle Metavariablen haben einen Namen \emph{VName}, der durch 
ein Paar des Typs $(String$, $Integer)$ dargestellt wird. 
Der String bezeichnet den Namen der Variablen, der Integer-Wert wird zum
einfachen Umbenennen von Variablen im Programm verwendet. 
Wir geben die Bedeutung der einzelnen Datenstrukturen an.
\begin{itemize}
\item Die Datenstruktur \emph{Tmv} (abgekürzt für Term bzw. Ausdrucks-Metavariable)
  repräsentiert Metavariablen für Ausdrücke. 
  Die entsprechenden Variablen in $\sigmaLet$ sind von der Sorte $T$. 
\item Die Datenstruktur \emph{Vmv} (Variablen-Metavariable)
  repräsentiert Metavariablen für Variablen. 
  Die entsprechenden Variablen in $\sigmaLet$ sind von der Sorte $V$. 
\item Die Datenstruktur \emph{Wmv} (Werte-Metavariable)
  repräsentiert Metavariablen für Abstraktionen. 
  Die entsprechenden Variablen in $\sigmaLet$ sind von der Sorte $App$. 
\item Die Datenstruktur \emph{Emv} (Umgebungs-Metavariable)
  repräsentiert Metavariablen für \letr-Umgebungen. 
  Die entsprechenden Variablen in $\sigmaLet$ sind von der Sorte $U$. 
\item Die Datenstruktur \emph{Cmv} (Kontext-Metavariable)
  repräsentiert Metavariablen für Kontexte.
  Der Konstruktor der Datenstruktur verfügt über ein zusätzliches
  Argument \emph{CType}, das angibt, zu welcher Kontextklasse die
  Kontext-Metavariable gehört:
  \[{\mathbf{data}\;\Conid{CType}\mathrel{=}\Conid{C}\mid\Conid{S}\mid \Conid{R}\mid \Conid{Rw}}.\]
  Eine Kontextvariable mit \emph{CType} $C$ entspricht einer
  $\sigmaLet$-Kontextvariablen der Sorte $T \rightarrow T$.
  Es gelten analoge Entsprechungen von Kontext-Metavariablen mit einem
  anderen \emph{CType} zu den jeweiligen $\sigmaLet$-Kontextvariablen. 
\end{itemize}

Ausdrücke werden im Programm durch die Datenstruktur
\begin{tabbing}
\qquad\=\hspace{\lwidth}\=\hspace{\cwidth}\=\+\kill
${\mathbf{data}\;\Conid{MAusdr}\mathrel{=}\Conid{MTtmv}\;\Conid{Tmv}}$\\
${\hskip5.00em\relax\mid \Conid{MTvmv}\;\Conid{Vmv}}$\\
${\hskip5.00em\relax\mid \Conid{MTwmv}\;\Conid{Wmv}}$\\
${\hskip5.00em\relax\mid \Conid{MTC}\;\Conid{Cmv}\;\Conid{MAusdr}}$\\
${\hskip5.00em\relax\mid \Conid{MApp}\;\Conid{MAusdr}\;\Conid{MAusdr}}$\\
${\hskip5.00em\relax\mid \Conid{MAbs}\;\Conid{Vmv}\;\Conid{MAusdr}}$\\
${\hskip5.00em\relax\mid \Conid{MLet}\;\Conid{Env}\;\Conid{MAusdr}}$
\end{tabbing}
dargestellt. Der Präfix $M$ soll verdeutlichen, dass es sich um
Ausdrücke mit Metavariablen handelt. 
Ein Ausdruck im Programm ist entweder eine bestimmte Metavariable, 
repräsentiert durch die Konstruktoren \emph{MTtmv, MTvmv} und
\emph{MTwmv}, die jeweils eine entsprechende Metavariable als Argument
erwarten, oder eine Kontext-Metavariable angewandt auf einen Ausdruck 
(\emph{MTC}). 
Des Weiteren kann es sich bei einem Ausdruck um eine Applikation
(\emph{MApp}), eine Abstraktion (\emph{MAbs}) oder einen
\letr-Ausdruck (\emph{MLet}) handeln. 
Der \letr~Datenkonstruktor erwartet als zweites Argument eine
Datenstruktur des Typs $Env$. \letr-Umgebungen sind im Programm
als drei-Tupel definiert:
\[{\mathbf{type}\;\Conid{Env}\mathrel{=}([\mskip1.5mu \Conid{Emv}\mskip1.5mu],
  [\mskip1.5mu \Conid{Chain}\mskip1.5mu],[\mskip1.5mu \Conid{Bind}\mskip1.5mu])}\]
bestehend aus einer Liste von Umgebungs-Metavariablen, einer Liste von
Variablenketten und einer Liste von \letr-Bindungen. 
\letr-Umgebungen enthalten zwar eine Liste von
Umgebungs-Metavariablen, der Unifikationsalgorithmus des Programms
unifiziert aber nur solche Umgebungen, die maximal eine
Umgebungs-Metavariable enthalten (analog zu der Beschränkung, dass
Umgebungen $\setf{\cdot|\cdot}$ in $\sigmaLet$ nur eine Variable der
Sorte $U$ enthalten dürfen).

Im Programm sind \letr-Bindungen definiert durch 
\[{\mathbf{data}\;\Conid{Bind}\mathrel{=}\Conid{Vmv}\mathbin{:=:}\Conid{MAusdr}}.\]
Der infix Konstruktor $:=:$ bindet einen Ausdruck an eine
Variablen-Metavariable. 

Variablenketten werden durch die Datenstruktur
\[{\mathbf{data}\;\Conid{Chain}\mathrel{=}\Conid{Chain}\;\Conid{CHmv}\;\Conid{Bind}\;[\mskip1.5mu
    (\Conid{BindPos},\Conid{Bind})\mskip1.5mu]\;\Conid{Bind}}\] 
dargestellt. Als zweites und viertes Argument erwartet der
Kettenkonstruktor jeweils eine \letr-Bindung, die Anfangs- und
Endbindung der Variablenkette symbolisieren. Das erste Argument des
Konstruktors ist eine Ketten-Metavariable, die zusammen mit dem
dritten Argument, einer Liste von Tupeln bestehend aus einer Position 
($A$,$E$ oder $M$) und einer Bindung, dazu dienen, sich abgespaltene
Bindungen und Aufteilungen der Kette zu merken (siehe Kapitel \ref{cha:unif-von-ketten}). 
Ketten-Metavariablen sind analog zu den anderen Metavariablen definiert:
\[{\mathbf{data}\;\Conid{CHmv}\mathrel{=}\Conid{CHmv}\;\Conid{VName}}.\]
Für eine Ketten-Metavariable können Variablenketten oder andere
Ketten-{Me\-ta\-va\-ri\-a\-b\-len} eingesetzt werden. 

Reduktionsregeln werden im Programm durch Paare 
$(MAusdr,MAusdr)$ repräsentiert. Die noe-Reduktionsregeln und die 
Reduktionsregeln, die zur Berechnung aller Überlappungen verwendet 
werden, entsprechen den in Kapitel \ref{cha:berechn-von-uberl}
definierten Regeln des  
$\sigmaLet$-Kalküls (Definition \ref{def:reduktion} und Definition \ref{def:no-reduktionen-sigmaLet}). 
Im Haskell-Interpreter werden die Regeln durch den Aufruf der Funktionen 
\emph{norules} bzw. \emph{isrules} angezeigt. 

Die meisten Datenstrukturen verfügen über eine Druckfunktion für
eine besser lesbare Darstellung im Haskell-Interpreter, wie beispielsweise

\begin{verbatim}
> MLet ([Emv ("E", 1)],[],
        [Vmv ("x", 1) :=: MApp (MTtmv (Tmv ("s", 1))) 
                               (MTvmv (Vmv ("x", 1)))]) 
       (MTvmv (Vmv ("v", 1)))
> (letrec ([E1],[],[x1=@(s1,x1)]) in v1).
\end{verbatim}
Nach obigem Schema wird die Auswertung eines Haskell-Ausdrucks im
Interpreter präsentiert: Hinter dem ersten \verb+>+ stehet der
auszuwertenden Ausdruck, hinter dem zweiten \verb+>+ das Resultat der
Auswertung. 

%\begin{tabbing}
%\qquad\=\hspace{\lwidth}\=\hspace{\cwidth}\=\+\kill
%${\mathbf{data}\;\Conid{GL}\mathrel{=}\Conid{GLT}\;(\Conid{MAusdr},\Conid{MAusdr})}$\\
%${\hskip3.50em\relax\mid \Conid{GLC}\;(\Conid{Cmv},\Conid{MAusdr})}$\\
%${\hskip3.50em\relax\mid \Conid{GLE}\;(\Conid{Env},\Conid{Env})}$\\
%${\hskip3.50em\relax\mid \Conid{GLB}\;(\Conid{Bind},\Conid{Bind})}$\\
%${\hskip3.50em\relax\mid \Conid{GLCH}\;(\Conid{CHmv},[\mskip1.5mu \Conid{Chain}\mskip1.5mu])}$\\
%${\hskip3.50em\relax\mid \Conid{Fail}}$
%\end{tabbing}

\subsection{Funktionen}
\label{sec:funktionen}

Die Funktion \emph{solve} mit dem Typ
\[{\Varid{solve}\mathbin{::}\Conid{GL}\to\; \Conid{Either}\;[\mskip1.5mu
    [\mskip1.5mu \Conid{GL}\mskip1.5mu]\mskip1.5mu]\;\Conid{Subst}}\]
erhält als Argument eine Unifikationsgleichung zwischen Ausdrücken
(repräsentiert durch die Datenstruktur \emph{GL}) und 
wendet eine Transformation auf die Unifikationsgleichung an. 
Der Rückgabewert ist entweder
eine Liste von Listen von Unifikationsgleichungen  
(die vollständige Menge von Alternativen, siehe Definition \ref{def:vollst-min-mgu-menge}) 
oder eine Substitution, falls die eingegebene Gleichung in gelöster
Form ist. Für die eingegebene Unifikationsgleichung m\"ussen die
Bedingungen eingeschränkter Unifikationsprobleme (Definition \ref{def:eingschraenktes-unifikationsproblem}) 
gelten. Insbesondere darf jede Kontext-Metavariable nur einmal
vorkommen. Außerdem darf jede \letr-Umgebung in der Gleichung 
maximal eine Variablenkette enthalten, es sei denn die
Variablenketten sind durch Aufspaltung aus einer Ursprungskette
entstanden (siehe Kapitel \ref{cha:unif-von-ketten}). 
Die Ausführung der Funktion \emph{solve} ist in eine Zustands-Monade 
gekapselt, um auf einfache und modulare Weise neue Variablennamen zu
erzeugen, die von manchen Unifikationsregeln benötigt werden. Der
tatsächliche Typ von \emph{solve} ist deshalb
\[{\Varid{solve}\mathbin{::}\Conid{GL}\to\; \Conid{State}\;\Conid{Integer}\;(\Conid{Either}\;[\mskip1.5mu
    [\mskip1.5mu
    \Conid{GL}\mskip1.5mu]\mskip1.5mu]\;\Conid{Subst})}.\]
D.h. \emph{solve} gibt einen Zustand zurück, der aus einer
Integer-Zahl, die für die Generierung neuer Variablennamen verwendet
wird, und einer entweder der vollständigen Menge von Alternativen
oder einer Substitution besteht. 

Wir geben eine Reihe von Beispielen, die illustrieren, dass die
Unifikationsregeln des Programms kompatibel mit den Unifikationsregeln
der vorgestellten Theorien sind. 

Betrachte die Gleichung $\set{app(s_1,t_1) \ue app(s_2,t_2)}$ in $\sigmaLet$
die durch einen \emph{Decomposition}-Schritt (aus Definition
\ref{def.unifikationsregeln}) transformiert wird zu  
$\set{s_1 \ue t_1, s_2 \ue t_2}$.
Ein Aufruf von \emph{solve} mit dem Unifikationsproblem als Argument
sieht folgendermaßen aus: 
\begin{verbatim}
> run $ solve (MApp (MTtmv (Tmv ("s", 1))) (MTtmv (Tmv ("t", 1))) =? 
               MApp (MTtmv (Tmv ("s", 2))) (MTtmv (Tmv ("t", 2))))
> Left [[s1 =? s2,t1 =? t2]].
\end{verbatim}
Dabei ist \emph{run} eine Hilfsfunktion, um die Zustands-Monade für
\emph{solve} zu initialisieren. 
Der Datenkonstruktor \verb Left ~signalisiert, dass der Rückgabewert
die vollständige Menge (Liste) von Alternativen ist, die in diesem Fall nur 
aus einer Liste von Unifikationsgleichungen besteht. 

Das $\sigmaLet$-Unifikationsproblem $\set{s_T \ue letrec(e,t)}$ ist in
gelöster, wohlsortierter Form. Der Aufruf von \emph{solve} für diese
Problem resultiert in einer Substitution, die den \letr-Ausdruck an
die Variable bindet. Die Rückgabe einer Substitution wird durch den 
Datenkonstruktor \verb Right ~signalisiert. 
\begin{verbatim}
> run $ solve ((MTtmv (Tmv ("s", 1))) =? 
               (MLet ([Emv ("E", 1)],[],[]) (MTtmv (Tmv ("t", 1)))))
> Right Tmv ("s",1) -> (letrec ([E1],[],[]) in t1)
\end{verbatim}

Auf das $\sigmaLet$-Unifikationsproblem $\set{x_v \ue letrec(e,t)}$
besitzt keine Lösung (\emph{Sorted Fail Fun} aus Definition \ref{def.unifikationsregeln}). 
Analog dazu der Aufruf von \emph{solve}: 
\begin{verbatim}
> run $ solve ((MTvmv (Vmv ("x", 1))) =? 
               (MLet ([Emv ("E", 1)],[],[]) (MTtmv (Tmv ("t", 1)))))
> Left [],
\end{verbatim}
wobei der \verb Left[] ~der Wert ist, der das Unifikationsproblem
repräsentiert dass keine Lösung besitzt.

Das $\sigmaLet$-Unifikationsproblem $\set{s \ue letrec(e,s)}$ 
resultiert in einem \emph{Occurs Check}, 
dazu passend haben wir
\begin{verbatim}
> run $ solve ((MTtmv (Tmv ("s", 1))) =? 
               (MLet ([Emv ("E", 1)],[],[]) (MTtmv (Tmv ("s", 1)))))
> Right *** 
  Exception: Occurs: Tmv ("s",1) in (letrec ([E1],[],[]) in s1).
\end{verbatim}


Die vollständige Menge von Alternativen für das $\sigmaLet$-Unifikationsproblem 
\[\set{\setf{b(x_1,s_1),b(x_2,s_2)|e_1} \ue
  \setf{b(y_1,t_1),b(y_2,t_2)|e_2}}\] ist 
durch die Transformationsmöglichkeiten von
\emph{U-Decomposition} (aus Definition \ref{def:p-unifikatiosregeln-mod}) gegeben:
\[\set{\set{\setf{b(x_2,s_2)|e_1} \ue \setf{b(y_1,t_1)|N}}, 
 \set{\setf{b(x_1,s_1)|N} \ue \setf{b(y_2,t_2)|e_2}}}\]
Im Programm wird eine Variante der
\emph{U-Decomposition}-Regel verwendet, wie an folgendem Beispiel zu
sehen ist. 
\begin{verbatim}
> run $ solve 
  (([Emv ("E", 1)],[],[Vmv ("x", 1) :=: MTtmv (Tmv ("s", 1)),
                       Vmv ("x", 2) :=: MTtmv (Tmv ("s", 2))]) =? 
   ([Emv ("E", 2)],[],[Vmv ("y", 1) :=: MTtmv (Tmv ("t", 1)),
                       Vmv ("y", 2) :=: MTtmv (Tmv ("t", 2))]))
> Left 
1 [[x1=s1 =? y1=t1, ([E1],[],[x2=s2]) =? ([E2],[],[y2=t2])],
2  [x1=s1 =? y2=t2, ([E1],[],[x2=s2]) =? ([E2],[],[y1=t1])],
3  [([E2],[],[]) =? ([N],[],[x1=s1]),
    ([E1],[],[x2=s2]) =? ([N],[],[y1=t1,y2=t2])]]
\end{verbatim}
Die Liste der vollständigen Alternativen enthält ein zusätzliches
Unifikationsproblem (Zeile 2), das durch die 
$\sigmaLet$-Unifikationsregeln erst nach einer Folge von 
Transformationen berechnet wird (siehe Transformation in
semi-gelöste Form in Lemma \ref{lemma:vollst.zerlegung.von.umg}). Die
im Programm verwendete Unifikationsregel 
zieht diese Transformationsmöglichkeit vor. 
Das Unifikationsproblem in Zeile 3 ist entsprechend angepasst, 
um die Berechnung einiger redundanter Unifikatoren zu vermeiden. 

Für das $\sigmaLet$-Unifikationsproblem 
$\set{\setf{b(x_1,s_1)|e_1} \ue \setf{ch(b(y_2,y_1),b(y_4,y_3))|e_2}}$
ergibt sich die vollständigen Menge von Alternativen 
durch die Anwendung der Regel \emph{Split-R} und
\emph{U-Decompositon} (Definition \ref{def:uni-regel-ketten}):
\[\begin{array}{l}
\set{\set{e_1 \ue \setf{ch(b(y_2,y_1),b(y_4,y_3))|N},  e_2 \ue \setf{b(x_1,s_1)|N}}, \\
     \phantom{\{}\set{b(x_1,s_1) \ue b(y_2,y_1), e_1 \ue \setf{ch(b(z,y_2),b(y_4,y_3))^M|e_2}} \\
     \phantom{\{}\set{b(x_1,s_1) \ue b(y_4,y_3), e_1 \ue \setf{ch(b(y_2,y_1),b(y_3,z))|e_2}} \\
     \phantom{\{}\set{b(x_1,s_1) \ue b(z_3,z_2), e_1 \ue \setf{ch(b(y_2,y_1),b(z_2,z_1)), ch(b(z_4,z_3),b(y_4,y_3))^M|e_2}}} \\
\end{array}\]
Durch \emph{solve} werden exakt diese Alternativen berechnet: 
\begin{verbatim}
> run $ solve 
  (([Emv ("E", 1)],[],[Vmv ("x", 1) :=: MTtmv (Tmv ("s", 1))]) =? 
   ([Emv ("E", 2)],
    [Chain (CHmv ("CH", 1)) 
           (Vmv ("y", 2) :=: MTvmv (Vmv ("y", 1))) [] 
           (Vmv ("y", 4) :=: MTvmv (Vmv ("y", 3)))],[]))
> Left 
1 [[([E2],[],[]) =? ([N],[],[x1=s1]),
    ([E1],[],[]) =? ([N],[CH1(y2=y1,[],y4=y3)],[])],
2  [x1=s1 =? y2=y1, CH1 =? [CH11(y13=y2,[(A,y2=y1)],y4=y3)],
    ([E1],[],[]) =? ([E2],[CH11(y13=y2,[(A,y2=y1)],y4=y3)],[])],
3  [x1=s1 =? y4=y3, CH1 =? [CH11(y2=y1,[(E,y4=y3)],y3=y14)],
    ([E1],[],[]) =? ([E2],[CH11(y2=y1,[(E,y4=y3)],y3=y14)],[])],
4  [x1=s1 =? y14=y13, CH1 =? [CH11(y2=y1,[],y13=y15), 
                              CH12(y16=y14,[(M,y14=y13)],y4=y3)],
   ([E1],[],[]) =? ([E2],[CH11(y2=y1,[],y13=y15),
                          CH12(y16=y14,[(M,y14=y13)],y4=y3)],[])]]
\end{verbatim}
Die Unifikationsprobleme in den Zeilen 2, 3 und 4 enthalten jeweils eine
zusätzliche Gleichungen, beispielsweise in Zeile 2:
\verb+CH1 =? [CH11(y13=y2,[(A,y2=y1)],y4=y3)]+. In diesen Gleichungen
steht auf der linken Seite eine Ketten-Metavariable und auf der
rechten Seite eine Liste von Variablenketten. Die Gleichungen 
sind per Definition in gelöster Form und dienen dazu, sich die
Abspaltung oder Aufteilung von Variablenketten zu merken
(vgl. Kapitel \ref{cha:unif-von-ketten}), damit die substituierten Terme syntaktisch gleich
werden. In der Kette \verb+CH11(y13=y2,[(A,y2=y1)],y4=y3)+ ist
beispielsweise vermerkt, 
dass an der Anfangsposition der ursprünglichen Kette (\verb+A+)
die Bindung \verb+y2=y1+ abgespalten wurde. 
Die Markierungen \verb+A+ und \verb+M+ entsprechen der Markierung $M$
der Unifikationsregeln für Variablenketten. Variablenketten die mit 
\verb+E+ markiert sind, werden wie unmarkierte Variabelketten
behandelt. 

Als letztes Beispiel betrachten wir das
$\sigmaLet$-Unifikationsproblem mit Kontextvariablen 
$\set{C_{(T,T)}(t_T) \ue R_{(T,RT)}(s_T)}$\footnote{In dem Problem ist
  $C$ eine allgemeine Kontextvariable und $R$ eine Reduktionskontextvariable.},  
das auch ausführlich am
Ende des Kapitels \ref{cha:unif-von-kontexten}  behandelt wird (in Beispiel \ref{bsp:wohlstrukturierung}).
\begin{verbatim}
> run $ solve ((MTC (Cmv ("C", 1) C) $ MTtmv (Tmv ("s", 1))) =? 
               (MTC (Cmv ("R", 1) R) $ MTtmv (Tmv ("t", 1))))
> Left 
1 [[C1c =? R11-[@(R13-[t1],C8c[ ])], 
    R1r =? R11-[@(R13-[ ],C8c[s1])]],
2  [C1c =? (letrec ([E5],[],[x6=C8c[ ],y7=R3-[t1]]) in R2-[y7]),
    R1r =? (letrec ([E5],[],[x6=C8c[s1],y7=R3-[ ]]) in R2-[y7])],
3  [C1c =? (letrec ([E5],[],[x6=C8c[ ]]) in R3-[t1]),
    R1r =? (letrec ([E5],[],[x6=C8c[s1]]) in R3-[ ])],
4  [C1c =? (letrec ([E5],[],[x6=R3-[t1]]) in R4-[ ]),
    R1r =? (letrec ([E5],[],[x6=R3-[ ]]) in R4-[s1]), s1 =? x6],
5  [C1c =? R1r[C8c[ ]], t1 =? C8c[s1]]]
\end{verbatim}
Kontext-Metavariablen, die allgemeine Kontexte darstellen, werden im
Interpreter mit einem Suffix \verb+c+ gedruckt. Kontext-Metavariablen aus
der Klasse der Oberflächenkontexte tragen den Suffix \verb+s+, 
Kontext-Metavariablen der Klasse der Reduktionskontexte den Suffix
\verb+r+ und für Metavariablen aus der Klasse der schwachen
Reduktionskontext wird der Suffix \verb+-+ verwendet. 
Die vollständige Menge der alternativen, die durch das Programm
berechnet wird, entspricht der im Beispiel \ref{bsp:wohlstrukturierung} angegeben
vollständigen Menge. Allerdings mit der Einschränkung, dass 
in der vom Programm berechneten Menge nur ein
Unifikationsproblem der Form 
\begin{verbatim}
  C1c =? (letrec ([E5],[],[x6=C8c[ ],y7=R3-[t1]]) in R2-[y7]),
  R1r =? (letrec ([E5],[],[x6=C8c[s1],y7=R3-[ ]]) in R2-[y7])
\end{verbatim}
enthalten ist (in Zeile 2) und dass zusätzliche in Beispiel \ref{bsp:wohlstrukturierung}
vorkommenden Problem 
\begin{verbatim}
  C1c =? (letrec ([E5],[],[y7=R3-[t1]],x6=C8c[ ]) in R2-[y7]),
  R1r =? (letrec ([E5],[],[y7=R3-[ ]],x6=C8c[s1],) in R2-[y7])
\end{verbatim}
nicht berechnet wird. Der Grund dafür ist, dass von den beiden Problemen
wegen der Vertauschbarkeit von Elementen in \letr-Umgebungen nur eines 
in der Vollständigen Menge der Alternativen benötigt wird. 
Damit das Vertauschbarkeits-Axiom ($Cl$) anwendbar ist, werden im
Programm zusätzlich neue Umgebungs-Metavariablen (\verb+E5+) in den
\letr-Umgebungen instantiiert. 
Außerdem werden die Nebenbedingungen, die für die
Wohlstrukturiertheit der berechneten
Unifikatoren gelten müssen korrekt beachtet. So ist beispielsweise in
den Gleichung 
\begin{verbatim}
 1 C1c =? (letrec ([E5],[],[x6=R3-[t1]]) in R4-[ ]),
 2 R1r =? (letrec ([E5],[],[x6=R3-[ ]]) in R4-[s1]), 
 3 s1 =? x6
\end{verbatim}
\sloppy
\verb+R4-+ eine Kontext-Metavariable der Klasse der schwachen
Reduktionskontexte und es gilt \verb+s =? x6+. 
D.h. \verb+(letrec ([E5],[],[x6=R3-[ ]]) in R4-[s1])+ stellt einen
Reduktionskontext dar und deshalb ist die Gleichung in Zeile 2
wohlstrukturiert. 

Die Funktion \emph{unify} mit dem Typ
\[{\Varid{unify}\mathbin{::}\Conid{MAusdr}\to \Conid{MAusdr}\to \Conid{State}\;\Conid{Integer}\;[\mskip1.5mu \Conid{Subst}\mskip1.5mu]}\]
berechnet für zwei gegebene Ausdrücke eine vollständige Menge von
Unifikatoren. 
Dazu ruft sie rekursiv die Funktion \emph{solve} auf. 
Zur einfachen Erzeugung von neuen Variablen, ist auch die Funktion
\emph{solve} in einer Zustands-Monade gekapselt. Um als
Rückgabewert lediglich die vollständige Menge von Unifikatoren 
zu erhalten, wird die Funktion im Haskell-Interpreter folgenderma"sen
aufgerufen:
\begin{verbatim}
> State.evalState (unify Ausdruck1 Ausdruck2) i
\end{verbatim}
wobei $i$ eine Integer-Zahl ist, die größer ist als alle Integer-Zahlen,
die in Variablennamen in \verb+Ausdruck1+ oder \verb+Ausdruck2+
vorkommen. 
%Falls \emph{solve} eine Substitution zurück gibt, wende \emph{unify}
%diese auf das transformierte Unifikationsproblem an. Gibt \emph{solve}
%eine vollständige Menge von Alternativen zurück, werden diese
%rekursive durch rekursive Anwendungen von \emph{solve} weiter
%transformiert. 

Die Funktion \emph{cpss} berechnet für eine Liste von Reduktionen und 
eine Reduktion alle kritischen Paare (Definition \ref{def:kritische-paare}) zwischen
der Reduktion und den Reduktionen. Ihr Typ ist: 
\[\begin{array}{l}
{\Varid{cpss}\mathbin{::}[\mskip1.5mu (\Conid{String},(\Conid{MAusdr},\Conid{MAusdr}))\mskip1.5mu]} \\
{\phantom{\Varid{cpss}\mathbin{::}\mbox{}}\to (\Conid{String},(\Conid{MAusdr},\Conid{MAusdr}))} \\
{\phantom{\Varid{cpss}\mathbin{::}\mbox{}}\to [\mskip1.5mu (\Conid{String},\Conid{MAusdr},\Conid{MAusdr},\Conid{MAusdr})\mskip1.5mu]}. \\
\end{array}\]
Die Reduktionen, die \emph{cpss} als
Argument erwartet, stehen in einem Tupel $(String,(MAusdr,MAusdr))$,
wobei der String den Namen der jeweiligen Reduktionsregel enthält,
die durch das Paar $(MAusdr,MAusdr)$ repräsentiert wird. 
Die Rückgabe der Funktion ist eine Menge von kritischen Paaren, die
durch eine Liste von vier-Tupeln 
$[(String,MAusdr,MAusdr,MAusdr)]$ dargestellt wird. 
Der String enthält die Namen der Reduktionsregeln, die das kritische Paar
erzeugen. Darauf folgt der Ausdruck, in dem die Überlappung
auftritt. Die beiden letzten Ausdrücke stellen das kritische Paar
dar, wobei der erste der beiden Ausdrücke der eno-reduzierte und der
zweite der iS-reduzierte Ausdruck ist. 
Ein Beispielaufruf von \emph{cpss}, der nur die ersten beiden
kritischen Paare für eine interne (\emph{llet-in})-Reduktion ausgibt 
(was durch das vorangestellte \verb+take 2 $+ erreicht wird) ist:
\begin{verbatim}
> take 2 $ cpss norules ("iS,llet-in",islletin)
> 1 [("eno,lletin iS,llet-in",
      (letrec ([E1],[],[]) in (letrec ([E2],[],[]) in r1)),
      (letrec ([E1,E2],[],[]) in r1),
      (letrec ([E1,E2],[],[]) in r1)),
  2  ("eno,lletin iS,llet-in",
      (letrec ([E1],[],[]) in (letrec ([E2],[],[]) in 
                               (letrec ([E7],[],[]) in r6))),
      (letrec ([E1,E2],[],[]) in (letrec ([E7],[],[]) in r6)),
      (letrec ([E1],[],[]) in (letrec ([E2,E7],[],[]) in r6)))]
\end{verbatim}
Das kritische Paar in Zeile 1 erzeugt eine triviale Überlappung,
d.h. der eno-Redex und der interne Redex (der in diesem Fall kein
interner Redex ist) sind identisch. 
Das kritische Paar in Zeile 2 erzeugt eine echte Überlappung.

Eine vollständige Menge von Gabeldiagrammen für alle internen
Reduktionen des $\sigmaLet$-Kalküls wird durch die Funktion
\emph{completeFDSet} mit dem Typ
\[\begin{array}{l}
{\Varid{completeFDSet}\mathbin{::}[\mskip1.5mu (\Conid{String},(\Conid{MAusdr},\Conid{MAusdr}))\mskip1.5mu]}\\
{\phantom{\Varid{completeFDSet}\mathbin{::}\mbox{}}\to [\mskip1.5mu (\Conid{String},(\Conid{MAusdr},\Conid{MAusdr}))\mskip1.5mu]}\\
{\phantom{\Varid{completeFDSet}\mathbin{::}\mbox{}}\to [\mskip1.5mu ([\mskip1.5mu (\Conid{String},\Conid{MAusdr})\mskip1.5mu],[\mskip1.5mu (\Conid{String},\Conid{MAusdr})\mskip1.5mu])\mskip1.5mu]}\\
\end{array}\]
berechnet. 
Die Funktion erwartet als erstes Argument eine Liste von
eno-Reduktionsregeln und als zweites Argument eine Liste von
Reduktionsregeln (die internen Reduktionsregeln). 
Die Listen von Reduktionsregeln enthalten wieder
Paare, bestehend aus dem Namen der Reduktionsregel und der jeweiligen
Regel. Der Rückgabewert von \emph{completeFDSet} ist ein
vollständiger Satz von Gabeldiagrammen für die internen Reduktionen,
die als zweites Argument übergeben wurden. 
Der vollständige Satz wird dargestellt durch eine Liste von Paaren 
$[([(\Conid{String},\Conid{MAusdr})\mskip1.5mu],[\mskip1.5mu (\Conid{String},\Conid{MAusdr})\mskip1.5mu])\mskip1.5mu].$
Die Elemente des Tupels sind Listen von Paaren. 
In diesen Paaren steht der String f\"ur den Namen einer
Reduktionsregel und der Ausdruck f\"ur ein Redukt, dass aus der
Anwendung der benannten Regel resultiert. 
Das erste Element des Tupels 
$([(\Conid{String},\Conid{MAusdr})\mskip1.5mu],[\mskip1.5mu (\Conid{String},\Conid{MAusdr})\mskip1.5mu])$
repräsentiert die Reduktionsfolge auf der linken und unteren Seite
des Gabeldiagramms, das zweite Element stellt die Reduktionsfolge auf
der oberen und rechten Seite des Gabeldiagramms dar.
Wir geben ein Beispiel:

\begin{verbatim}
> take 2 $ completeFDSet norules isrules
> 1 [([("eno,lletin",(letrec ([E6,E7],[],[]) in r6))],
      [("iS,lletin",(letrec ([E6,E7],[],[]) in r6))]),
  2 ([("eno,lletin",
       (letrec ([E1,E6],[],[]) in (letrec ([E7],[],[]) in r6))),
      ("eno,lletin",
       (letrec ([E1,E6,E7],[],[]) in r6))],
     [("iS,lletin",
       (letrec ([E1],[],[]) in (letrec ([E6,E7],[],[]) in r6))),
      ("eno,lletin",
       (letrec ([E1,E6,E7],[],[]) in r6))])]
\end{verbatim}
Die Ausgabe in Zeile 1 bezieht sich auf eine triviale
Überlappung, für die kein Gabeldiagramm notwendig ist.
Das Paar in Zeile 2 korrespondiert mit dem Gabeldiagramm
\[\xymatrix{
\cdot \ar@{->}[rr]^{iS,\emph{llet-in}} \ar@{.>}[d]_{eno,\emph{llet-in}} & & \cdot \ar@{.>}[ddll]^{eno,\emph{llet-in}} \\
\cdot \ar@{.>}[d]_{eno,\emph{llet-in}} & & \\
\cdot & & \\
}\]

Zum Schließen von Gabeldiagrammen wird in der Funktion
\emph{completeFDSet} folgenderma"sen vorgegangen:
Sei $(s,t)$ ein kritisches Paar für eine eno-Reduktionsregel $\rho_1$ und
einer (interne) Reduktionsregel $\rho_2$ und sei $s$ der eno-reduzierte
Ausdruck und $t$ der Ausdruck der durch die interne Reduktion
reduziert wurde:
\[\xymatrix{
u \ar@{->}[rr]^{iS,\rho_2} \ar@{->}[d]_{eno,\rho_1} & & t \\
s & & \\
}\]
D.h. zum Schließen des Diagramms können auf $t$ nur eno-Reduktionen
angewendet werden und auf $s$ eno- oder interne Reduktionen. 
Generiere einen Suchbaum mit dem Wurzelknoten $(s,t)$. 
Für jeden Knoten $(s_i,t_j)$ im Baum erzeuge all seine Kinderknoten 
\begin{itemize}
\item $(s_l,t_j)$, wenn $s_i \xrightarrow{eno,a} s_l$ für eine
  eno-Reduktionsregel $a$ gilt. Und
\item $(s_l,t_j)$ für alle internen Reduktionsmöglichkeiten in
 Oberflächenkontexten $s_i \xrightarrow{iS,b} s_l$. Und
\item $(s_i,t_k)$, wenn $t_j \xrightarrow{eno,c} t_k$ für eine
  eno-Reduktionsregel $c$ gilt. 
\end{itemize}
Folgende Abbildung zeigt das Schema eines solchen Suchbaums. 
\[\xymatrix@C=2.2cm@R=1.3cm{
& & (s,t) \ar@{->}[dll]|{s \xrightarrow{eno,a} s_1} 
          \ar@{->}[dl]|{s \xrightarrow{iS,b_1} s_2} 
	  \ar@{->}[d]|{s \xrightarrow{iS,b_2} s_3} 
	  \ar@{.>}[dr]|{\xrightarrow{iS,b_i}} 
	  \ar@{->}[drr]|{t \xrightarrow{eno,c} t_1} & &  \\
(s_1,t) & 
(s_2,t) & 
(s_3,t)   \ar@{->}[dl]|{s_3 \xrightarrow{eno,a} s_{31}} 
	  \ar@{.>}[d]|{\xrightarrow{iS,b_i}}
	  \ar@{->}[dr]|{t \xrightarrow{eno,c} t_1} &
\dots & 
(s,t_1) \\
 &
(s_{31}, t) &
\dots &
(s_3, t_1) &
 &
}\]
Der so erzeugte Baum wird mittels Tiefensuche mit einer iterativen
Tiefenschranke durchsucht nach
einem Knoten $(s_i,t_j)$, so dass 
die Ausdrücke syntaktisch gleich sind (modulo der durch das
$Cl$-Axiom und die Split-Axiome erzeugte Kongruenzrelation). 
Man merke sich den Pfad vom
Wurzelknoten zu diesem Knoten. Er gibt die kürzesten Folgen von
Reduktionen an, so dass das Gabeldiagramm geschlossen wird. 

Die Reduktion von Ausdrücken im Programm wird durch Matching
implementiert. 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% no,a, iS,lletin
\section{Ergebnisse der Berechnung von Gabeldiagrammen}
Wir geben die vollständigen Gabeldiagramme von Gabeldiagrammen für 
iS-Reduktionen an, die durch das Programm berechnet werden. 
Für interne \emph{lapp} und \emph{lbeta} Reduktionen
ergeben sich keine kritischen Paare. 
Das entspricht der Tatsache, dass zum Beweis der Korrektheit der
Programmtransformationen \emph{lapp,lbeta} keine Diagramme benötigt
werden (siehe Proposition \ref{prop:korrekt-lbeta-lapp}).

\section{Vollständiger Satz von Gabeldiagrammen für (\emph{iS,llet})}
\subsection{Vollständiger Satz von Gabeldiagrammen für (\emph{iS,llet-in})}
Für die Überlappungen einer $(iS,\emph{llet-in})$-Reduktion mit
eno-Reduktionen berechnet das Programm insgesamt 11 Gabeldiagramme, die
teilweise redundant sind. Wir geben einige berechnete Gabeldiagramme,
zugehörigen kritischen Paaren und die schließenden Reduktionsfolgen
an. 

\framebox{\begin{minipage}{1\textwidth} 
$\xymatrix{
\cdot \ar@{->}[rr]^{iS,\emph{llet-in}} \ar@{.>}[d]_{eno,\emph{llet-in}} & & \cdot \ar@{.>}[ddll]^{eno,\emph{llet-in}} \\
\cdot \ar@{.>}[d]_{eno,\emph{llet-in}} & & \\
\cdot & & \\
}$\\[0.2cm]
$\begin{array}[t]{rl} \multicolumn{2}{l}{\letrecm{ E_{1} }{\letrecm{ E_{6} }{\letrecm{ E_{7} }{r_{6}}}} }\\ \hline \xrightarrow{ eno,lletin}& \letrecm{ E_{1},E_{6} }{\letrecm{ E_{7} }{r_{6}}} \\ \xrightarrow{ eno,lletin}& \letrecm{ E_{1},E_{6},E_{7} }{r_{6}} \\\hline \xrightarrow{ iS,lletin}& \letrecm{ E_{1} }{\letrecm{ E_{6},E_{7} }{r_{6}}} \\ \xrightarrow{ eno,lletin}& \letrecm{ E_{1},E_{6},E_{7} }{r_{6}} \\ \end{array}$ 
\end{minipage}}

Die folgenden vier Diagramme ergeben sich zwar aus unterschiedlichen
Überlappungen, können aber immer durch das gleiche Gabeldiagramm
geschlossen werden. Sie entstehen durch die Überlappung mit 
Varianten einer eno-Reduktionsregel, die jeweils Reduktionsketten
unterschiedlicher Länge enthalten. 

\framebox{\begin{minipage}{1\textwidth} 
\fdiagrammA{\islletin}{\enollete}{\enollete}{\enollete}\\[0.2cm]
 $\begin{array}[t]{rl} \multicolumn{2}{l}{\letrecm{ E_{1}x_{1}=\letrecm{ E_{6} }{\letrecm{ E_{7} }{r_{6}}} }{R_{1}^-[x_{1}]} }\\ \hline \xrightarrow{ eno,llete0}& \letrecm{ E_{1},E_{6},  x_{1}=\letrecm{ E_{7} }{r_{6}} }{R_{1}^-[x_{1}]} \\ \xrightarrow{ eno,llete0}& \letrecm{ E_{1},E_{6},E_{7},  x_{1}=r_{6} }{R_{1}^-[x_{1}]} \\\hline \xrightarrow{ iS,lletin}& \letrecm{ E_{1},  x_{1}=\letrecm{ E_{6},E_{7} }{r_{6}} }{R_{1}^-[x_{1}]} \\ \xrightarrow{ eno,llete0}& \letrecm{ E_{1},E_{6},E_{7},  x_{1}=r_{6} }{R_{1}^-[x_{1}]} \\ \end{array}$ 
\end{minipage}}

\framebox{\begin{minipage}{1\textwidth}  
\fdiagrammA{\islletin}{\enollete}{\enollete}{\enollete}\\[0.2cm]
$\begin{array}{rl} \multicolumn{2}{l}{\letrecms{ E_{1},
      nx_{1}=nR_{1}^-[@(x_{1},u_{1})],x_{1}=\letrecm{ E_{6},
      }{\letrecm{ E_{7},   }{r_{6}}} }{R_{1}^-[nx_{1}]} }\\ \hline
  \xrightarrow{ eno,llete1}& \letrecms{ E_{1},E_{6},
    nx_{1}=nR_{1}^-[@(x_{1},u_{1})],x_{1}=\letrecm{ E_{7},   }{r_{6}}
  }{R_{1}^-[nx_{1}]} \\ \xrightarrow{ eno,llete1}& \letrecm{
    E_{1},E_{6},E_{7},  nx_{1}=nR_{1}^-[@(x_{1},u_{1})],x_{1}=r_{6}
  }{R_{1}^-[nx_{1}]} \\\hline \xrightarrow{ iS,lletin}& \letrecms{
    E_{1},  nx_{1}=nR_{1}^-[@(x_{1},u_{1})],x_{1}=\letrecm{
      E_{6},E_{7},   }{r_{6}} }{R_{1}^-[nx_{1}]} \\ \xrightarrow{
    eno,llete1}& \letrecm{ E_{1},E_{6},E_{7},
    nx_{1}=nR_{1}^-[@(x_{1},u_{1})],x_{1}=r_{6} }{R_{1}^-[nx_{1}]} \\
\end{array}$ \end{minipage}}  

\framebox{\begin{minipage}{1\textwidth}  
\fdiagrammA{\islletin}{\enollete}{\enollete}{\enollete}\\[0.2cm]
$\begin{array}{rl} \multicolumn{2}{l}{\letrecmt{ E_{1},
      nx_{1}=nR_{1}^-[x_{1}],nx_{2}=nR_{2}^-[nx_{1}],}{x_{1}=\letrecm{
	E_{6},   }{\letrecm{ E_{7},   }{r_{6}}} }{R_{1}^-[nx_{2}]} }\\
  \hline \xrightarrow{ eno,llete2}& \letrecmt{ E_{1},E_{6},
    nx_{1}=nR_{1}^-[x_{1}],nx_{2}=nR_{2}^-[nx_{1}],}{x_{1}=\letrecm{
      E_{7},   }{r_{6}} }{R_{1}^-[nx_{2}]} \\ \xrightarrow{
    eno,llete2}& \letrecm{ E_{1},E_{6},E_{7},
    nx_{1}=nR_{1}^-[x_{1}],nx_{2}=nR_{2}^-[nx_{1}],x_{1}=r_{6}
  }{R_{1}^-[nx_{2}]} \\\hline \xrightarrow{ iS,lletin}& \letrecmt{
    E_{1},
    nx_{1}=nR_{1}^-[x_{1}],nx_{2}=nR_{2}^-[nx_{1}],}{x_{1}=\letrecm{
      E_{6},E_{7},   }{r_{6}} }{R_{1}^-[nx_{2}]} \\ \xrightarrow{
    eno,llete2}& \letrecm{ E_{1},E_{6},E_{7},
    nx_{1}=nR_{1}^-[x_{1}],nx_{2}=nR_{2}^-[nx_{1}],x_{1}=r_{6}
  }{R_{1}^-[nx_{2}]} \\ \end{array}$ \end{minipage}}  

\framebox{\begin{minipage}{1\textwidth}  
\fdiagrammA{\islletin}{\enollete}{\enollete}{\enollete}\\[0.2cm]
$\begin{array}{rl} \multicolumn{2}{l}{\letrecmt{ E_{1},
      nx_{1}=nR_{1}^-[x_{1}],nx_{2}=nR_{2}^-[nx_{1}],nx_{3}=nR_{3}^-[nx_{2}],}{x_{1}=\letrecm{ E_{6},   }{\letrecm{ E_{7},   }{r_{6}}} }{R_{1}^-[nx_{3}]} }\\ \hline \xrightarrow{ eno,llete3}& \letrecmt{ E_{1},E_{6},  nx_{1}=nR_{1}^-[x_{1}],nx_{2}=nR_{2}^-[nx_{1}],nx_{3}=nR_{3}^-[nx_{2}],}{x_{1}=\letrecm{ E_{7},   }{r_{6}} }{R_{1}^-[nx_{3}]} \\ \xrightarrow{ eno,llete3}& \letrecmt{ E_{1},E_{6},E_{7},  nx_{1}=nR_{1}^-[x_{1}],nx_{2}=nR_{2}^-[nx_{1}],nx_{3}=nR_{3}^-[nx_{2}],}{x_{1}=r_{6} }{R_{1}^-[nx_{3}]} \\\hline \xrightarrow{ iS,lletin}& \letrecmt{ E_{1},  nx_{1}=nR_{1}^-[x_{1}],nx_{2}=nR_{2}^-[nx_{1}],nx_{3}=nR_{3}^-[nx_{2}],}{x_{1}=\letrecm{ E_{6},E_{7},   }{r_{6}} }{R_{1}^-[nx_{3}]} \\ \xrightarrow{ eno,llete3}& \letrecmt{ E_{1},E_{6},E_{7},  nx_{1}=nR_{1}^-[x_{1}],nx_{2}=nR_{2}^-[nx_{1}],nx_{3}=nR_{3}^-[nx_{2}],}{x_{1}=r_{6} }{R_{1}^-[nx_{3}]} \\ \end{array}$ \end{minipage}}      

\framebox{\begin{minipage}{1\textwidth}  
\fdiagrammB{\islletin}{\enolapp}{\enolapp}{\islapp}{\islletin} bzw. 
$\xymatrix{%Vierecke
\cdot \ar@{->}[rr]^{eno,lapp} \ar@{->}[d]_{eno,lapp} & & \cdot \ar@{.>}[dddll]^{eno,lapp} \\
\cdot \ar@{.>}[d]_{eno,lapp}  & & \\
\cdot \ar@{.>}[d]_{eno,lletin}  & & \\
\cdot & & \\
}$ \\
$\begin{array}[t]{rl} \multicolumn{2}{l}{R_{3}^-[@(\letrecm{ E_{6} }{\letrecm{ E_{7} }{r_{6}}},s_{1})] }\\ \hline 
\xrightarrow{ eno,lapp1}& R_{3}^-[\letrecm{ E_{6} }{@(\letrecm{ E_{7} }{r_{6}},s_{1})}] \\ 
\xrightarrow{ iS \vee eno,lapp}& R_{3}^-[\letrecm{ E_{6} }{\letrecm{ E_{7} }{@(r_{6},s_{1})}}] \\ 
\xrightarrow{ iS \vee eno,lletin}& R_{3}^-[\letrecm{ E_{6},E_{7} }{@(r_{6},s_{1})}] \\
& \text{Die beiden letzten Reduktionen sind eno, falls} \; R_{3}^- = \lochm, \; \text{sonst} \; iS. \\ \hline 
\xrightarrow{ iS,lletin}& R_{3}^-[@(\letrecm{ E_{6},E_{7} }{r_{6}},s_{1})] \\ 
\xrightarrow{ eno,lapp1}& R_{3}^-[\letrecm{ E_{6},E_{7} }{@(r_{6},s_{1})}] \\ \end{array}$  \\
\end{minipage}}

\framebox{\begin{minipage}{1\textwidth} 
\fdiagrammB{\islletin}{\enolapp}{\enolapp}{\islapp}{\islletin} \\[0.2cm]
 $\begin{array}[t]{rl} \multicolumn{2}{l}{\letrecm{ E_{3} }{R_{3}^-[@(\letrecm{ E_{6} }{\letrecm{ E_{7} }{r_{6}}},s_{1})]} }\\ \hline \xrightarrow{ eno,lapp2}& \letrecm{ E_{3} }{R_{3}^-[\letrecm{ E_{6} }{@(\letrecm{ E_{7} }{r_{6}},s_{1})}]} \\ \xrightarrow{ iS,lapp}& \letrecm{ E_{3} }{R_{3}^-[\letrecm{ E_{6} }{\letrecm{ E_{7} }{@(r_{6},s_{1})}}]} \\ \xrightarrow{ iS,lletin}& \letrecm{ E_{3} }{R_{3}^-[\letrecm{ E_{6},E_{7} }{@(r_{6},s_{1})}]} \\\hline \xrightarrow{ iS,lletin}& \letrecm{ E_{3} }{R_{3}^-[@(\letrecm{ E_{6},E_{7} }{r_{6}},s_{1})]} \\ \xrightarrow{ eno,lapp2}& \letrecm{ E_{3} }{R_{3}^-[\letrecm{ E_{6},E_{7} }{@(r_{6},s_{1})}]} \\ \end{array}$ 
\end{minipage}}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% eno,a, is,llete
\subsection{Vollständiger Satz von Gabeldiagrammen für (\emph{iS,llet-e})}
Für die Überlappungen einer $(iS,\emph{llet-e})$-Reduktion mit
eno-Reduktionen berechnet das Programm insgesamt 35 Gabeldiagramme. 
Wir geben die 5 Fälle an, die unterschiedliche Diagramme ergeben.  

\framebox{\begin{minipage}{1\textwidth} 
\fdiagrammA{\isllete}{\enolletin}{\enolletin}{\isllete}\\[0.2cm]
 $\begin{array}[t]{rl} \multicolumn{2}{l}{\letrecm{ E_{6},  x_{6}=\letrecm{ E_{7} }{s_{6}} }{\letrecm{ E_{2} }{r_{1}}} }\\ \hline \xrightarrow{ eno,lletin}& \letrecm{ E_{6},E_{2},  x_{6}=\letrecm{ E_{7} }{s_{6}} }{r_{1}} \\ \xrightarrow{ iS,llete}& \letrecm{ E_{6},E_{2},E_{7},  x_{6}=s_{6} }{r_{1}} \\\hline \xrightarrow{ iS,llete}& \letrecm{ E_{6},E_{7},  x_{6}=s_{6} }{\letrecm{ E_{2} }{r_{1}}} \\ \xrightarrow{ eno,lletin}& \letrecm{ E_{6},E_{7},E_{2},  x_{6}=s_{6} }{r_{1}} \\ \end{array}$ 
\end{minipage}}

\framebox{\begin{minipage}{1\textwidth} 
\fdiagrammA{\isllete}{\enollete}{\enollete}{\isllete}\\[0.2cm]
 $\begin{array}[t]{rl} \multicolumn{2}{l}{\letrecm{ E_{8},  x_{1}=\letrecm{ E_{2} }{s_{1}},x_{6}=\letrecm{ E_{7} }{s_{6}} }{R_{1}^-[x_{1}]} }\\ \hline \xrightarrow{ eno,llete0}& \letrecm{ E_{8},E_{2},  x_{1}=s_{1},x_{6}=\letrecm{ E_{7} }{s_{6}} }{R_{1}^-[x_{1}]} \\ \xrightarrow{ iS,llete}& \letrecm{ E_{8},E_{2},E_{7},  x_{1}=s_{1},x_{6}=s_{6} }{R_{1}^-[x_{1}]} \\\hline \xrightarrow{ iS,llete}& \letrecm{ E_{8},E_{7},  x_{1}=\letrecm{ E_{2} }{s_{1}},x_{6}=s_{6} }{R_{1}^-[x_{1}]} \\ \xrightarrow{ eno,llete0}& \letrecm{ E_{8},E_{7},E_{2},  x_{1}=s_{1},x_{6}=s_{6} }{R_{1}^-[x_{1}]} \\ \end{array}$ 
\end{minipage}}

\framebox{\begin{minipage}{1\textwidth} 
\fdiagrammA{\isllete}{\enocpin}{\enocpin}{\isllete}\\[0.2cm]
 $\begin{array}[t]{rl} \multicolumn{2}{l}{\letrecms{ E_{9},
      CH_{1}(cx_{2}=cx_{1},cx_{4}=cx_{3}),
      cx_{1}=v_{1},x_{6}=\letrecm{ E_{7} }{s_{6}} }{R_{1}^-[cx_{4}]}
  }\\ \hline \xrightarrow{ eno,\emph{cpin}}& \letrecms{ E_{9},
    CH_{1}(cx_{2}=cx_{1},cx_{4}=cx_{3}), cx_{1}=v_{1},x_{6}=\letrecm{
      E_{7} }{s_{6}} }{R_{1}^-[v_{1}]} \\ \xrightarrow{ iS,llete}&
  \letrecm{ E_{9},E_{7}, CH_{1}(cx_{2}=cx_{1},cx_{4}=cx_{3}),
    cx_{1}=v_{1},x_{6}=s_{6} }{R_{1}^-[v_{1}]} \\\hline \xrightarrow{
    iS,llete}& \letrecms{ E_{9},E_{7},
    CH_{1}(cx_{2}=cx_{1},cx_{4}=cx_{3}), cx_{1}=v_{1},x_{6}=s_{6}
  }{R_{1}^-[cx_{4}]} \\ \xrightarrow{ eno,cpin}& \letrecm{
    E_{9},E_{7}, CH_{1}(cx_{2}=cx_{1},cx_{4}=cx_{3}),
    cx_{1}=v_{1},x_{6}=s_{6} }{R_{1}^-[v_{1}]} \\ \end{array}$  
\end{minipage}}

\framebox{\begin{minipage}{1\textwidth} 
\fdiagrammA{\isllete}{\enocpe}{\enocpe}{\isllete}\\[0.2cm]
 $\begin{array}[t]{rl} \multicolumn{2}{l}{\letrecmt{ E_{14},
      CH_{2}(cy_{2}=cy_{1},cy_{4}=cy_{3}),
      cy_{1}=v_{2},x_{1}=R_{2}^-[@(cy_{4},s_{2})],}{x_{6}=\letrecm{
	E_{7} }{s_{6}} }{R_{1}^-[x_{1}]} }\\ \hline \xrightarrow{
    eno,cpe0}& \letrecmt{ E_{14}, CH_{2}(cy_{2}=cy_{1},cy_{4}=cy_{3}),
    cy_{1}=v_{2},x_{1}=R_{2}^-[@(v_{2},s_{2})],}{x_{6}=\letrecm{ E_{7}
    }{s_{6}} }{R_{1}^-[x_{1}]} \\ \xrightarrow{ iS,llete}& \letrecmt{
    E_{14},E_{7}, CH_{2}(cy_{2}=cy_{1},cy_{4}=cy_{3}),
    cy_{1}=v_{2},x_{1}=R_{2}^-[@(v_{2},s_{2})],}{x_{6}=s_{6}
  }{R_{1}^-[x_{1}]} \\\hline \xrightarrow{ iS,llete}& \letrecmt{
    E_{14},E_{7}, CH_{2}(cy_{2}=cy_{1},cy_{4}=cy_{3}),
    cy_{1}=v_{2},x_{1}=R_{2}^-[@(cy_{4},s_{2})],}{x_{6}=s_{6}
  }{R_{1}^-[x_{1}]} \\ \xrightarrow{ eno,cpe0}& \letrecmt{
    E_{14},E_{7}, CH_{2}(cy_{2}=cy_{1},cy_{4}=cy_{3}),
    cy_{1}=v_{2},x_{1}=R_{2}^-[@(v_{2},s_{2})],}{x_{6}=s_{6}
  }{R_{1}^-[x_{1}]} \\ \end{array}$  
\end{minipage}}

\framebox{\begin{minipage}{1\textwidth} 
\fdiagrammA{\isllete}{\enolapp}{\enolapp}{\isllete} bzw. 
$\xymatrix{
\cdot \ar@{->}[rr]^{iS,\emph{llet-e}} \ar@{.>}[d]_{eno,lapp} & & \cdot \ar@{.>}[ddll]^{eno,lapp} \\
\cdot \ar@{.>}[d]_{eno,\emph{llet-e}} & & \\
\cdot & & \\
}$\\[0.2cm]
 $\begin{array}[t]{rl} \multicolumn{2}{l}{R_{3}^-[@(\letrecm{ E_{6},
	x_{6}=\letrecm{ E_{7} }{s_{6}} }{r_{6}},s_{1})] }\\ \hline
  \xrightarrow{ eno,lapp1}& R_{3}^-[\letrecm{ E_{6},  x_{6}=\letrecm{
	E_{7} }{s_{6}} }{@(r_{6},s_{1})}] \\ \xrightarrow{ iS\vee no,llete}&
  R_{3}^-[\letrecm{ E_{6},E_{7},  x_{6}=s_{6} }{@(r_{6},s_{1})}] \\
  & \text{Die letzte Reduktion ist no, falls $R_{3}^- = \lochm$, sonst iS.} \\
\hline \xrightarrow{ iS,llete}& R_{3}^-[@(\letrecm{ E_{6},E_{7},  x_{6}=s_{6} }{r_{6}},s_{1})] \\ \xrightarrow{ eno,lapp1}& R_{3}^-[\letrecm{ E_{6},E_{7},  x_{6}=s_{6} }{@(r_{6},s_{1})}] \\ \end{array}$ 
\end{minipage}}

Durch die Zusammenfassung der einzelnen Diagramme ergibt sich der berechnete
vollständige Satz von Gabeldiagrammen für $(iS,llet)$:

%\Ovalbox{
\[\xymatrix@R=1.5cm@C=1.5cm{%Vierecke
\cdot \ar@{->}[rr]^{\mathbf{iS,llet}} \ar@{->}[d]_{\mathbf{eno,a}} & & \cdot \ar@{.>}[d]^{\mathbf{eno,a}} \\
\cdot \ar@{.>}[rr]^{\mathbf{iS,llet}}                                  & & \cdot
}\quad 
%\Ovalbox
\xymatrix@R=1.5cm@C=1.5cm{%Vierecke
\cdot \ar@{->}[rr]^{\mathbf{iS,llet}} \ar@{->}[d]_{\mathbf{eno,lll}} & & \cdot \ar@{.>}[ddll]^{\mathbf{eno,lll}} \\
\cdot \ar@{.>}[d]_{\mathbf{eno,lll}} & & \\
\cdot & & \\
}\]

%\Ovalbox{
\[\xymatrix@R=1.5cm@C=1.5cm{%Vierecke
\cdot \ar@{->}[rr]^{\mathbf{iS,llet-in}} \ar@{->}[d]_{\mathbf{eno,lapp}} & & \cdot \ar@{.>}[d]^{\mathbf{eno,lapp}} \\
\cdot \ar@{.>}[r]^{\mathbf{iS,lapp}}                                   & \cdot \ar@{.>}[r]^{\mathbf{iS,llet-in}}  & \cdot
}\quad
%\Ovalbox{
\xymatrix@R=1.5cm@C=1.5cm{%Vierecke
\cdot \ar@{->}[rr]^{\mathbf{iS,llet-in}} \ar@{->}[d]_{\mathbf{eno,lapp}} & & \cdot \ar@{.>}[dddll]^{\mathbf{eno,lapp}} \\
\cdot \ar@{.>}[d]_{\mathbf{eno,lapp}} & & \\
\cdot \ar@{.>}[d]_{\mathbf{eno,llet-in}} & & \\
\cdot & & \\
}\]


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% eno,a, is,cpin 
\section{Vollständiger Satz von Gabeldiagrammen für (\emph{iS,cp})}
\subsection{Vollständiger Satz von Gabeldiagrammen für (\emph{iS,cp-in})}
Das Programm berechnet 63 Gabeldiagramme für eine
$(iS,cp-in)$-Reduktion.
Wir geben die Diagramme an, die sich unterscheiden. 

\framebox{\begin{minipage}{1\textwidth}  
\fdiagrammA{\iscpin}{\enolletin}{\enolletin}{\iscpin}\\[0.2cm]
$\begin{array}[t]{rl} \multicolumn{2}{l}{\letrecm{ E_{6},
      CH_{6}(cx_{7}=cx_{6},cx_{9}=cx_{8}), cx_{6}=v_{6} }{\letrecm{
	E_{2} }{C_{10}^C[cx_{9}]}} }\\ \hline \xrightarrow{
    eno,lletin}& \letrecm{ E_{6},E_{2},
    CH_{6}(cx_{7}=cx_{6},cx_{9}=cx_{8}), cx_{6}=v_{6}
  }{C_{10}^C[cx_{9}]} \\ \xrightarrow{ iS,cpin}& \letrecm{
    E_{6},E_{2}, CH_{6}(cx_{7}=cx_{6},cx_{9}=cx_{8}), cx_{6}=v_{6}
  }{C_{10}^C[v_{6}]} \\\hline \xrightarrow{ iS,cpin}& \letrecms{ E_{6},
    CH_{6}(cx_{7}=cx_{6},cx_{9}=cx_{8}), cx_{6}=v_{6} }{\letrecm{
      E_{2} }{C_{10}^C[v_{6}]}} \\ \xrightarrow{ eno,lletin}&
  \letrecm{ E_{6},E_{2}, CH_{6}(cx_{7}=cx_{6},cx_{9}=cx_{8}),
    cx_{6}=v_{6} }{C_{10}^C[v_{6}]} \\ \end{array}$  
\end{minipage}}

\framebox{\begin{minipage}{1\textwidth}
\fdiagrammA{\iscpin}{\enollete}{\enollete}{\iscpin}\\[0.2cm]
$\begin{array}[t]{rl} \multicolumn{2}{l}{\letrecms{ E_{10},
      CH_{6}(cx_{7}=cx_{6},cx_{9}=cx_{8}),
      cx_{6}=v_{6},x_{1}=\letrecm{ E_{2} }{s_{1}}
    }{R_{18}^-[@(R_{20}^-[x_{1}],C_{17}^C[cx_{9}])]} }\\ \hline
  \xrightarrow{ eno,llete.0}& \letrecms{ E_{10},E_{2},
    CH_{6}(cx_{7}=cx_{6},cx_{9}=cx_{8}), cx_{6}=v_{6},x_{1}=s_{1}
  }{R_{18}^-[@(R_{20}^-[x_{1}],C_{17}^C[cx_{9}])]} \\ \xrightarrow{
    iS,cpin}& \letrecms{ E_{10},E_{2},
    CH_{6}(cx_{7}=cx_{6},cx_{9}=cx_{8}), cx_{6}=v_{6},x_{1}=s_{1}
  }{R_{18}^-[@(R_{20}^-[x_{1}],C_{17}^C[v_{6}])]} \\\hline
  \xrightarrow{ iS,cpin}& \letrecmt{ E_{10},
    CH_{6}(cx_{7}=cx_{6},cx_{9}=cx_{8}), cx_{6}=v_{6},}{x_{1}=\letrecm{
      E_{2} }{s_{1}} }{R_{18}^-[@(R_{20}^-[x_{1}],C_{17}^C[v_{6}])]}
  \\ \xrightarrow{ eno,llete.0}& \letrecms{ E_{10},E_{2},
    CH_{6}(cx_{7}=cx_{6},cx_{9}=cx_{8}), cx_{6}=v_{6},x_{1}=s_{1}
  }{R_{18}^-[@(R_{20}^-[x_{1}],C_{17}^C[v_{6}])]} \\ \end{array}$  
\end{minipage}}


\framebox{\begin{minipage}{1\textwidth}
\fdiagrammA{\iscpin}{\enocpin}{\enocpin}{\iscpin} \\[0.2cm]
$\begin{array}[t]{rl} \multicolumn{2}{l}{\letrecms{ E_{21},
      CH_{1}(cx_{2}=cx_{6},cx_{4}=cx_{3}),CH_{6}(cx_{7}=cx_{6},cx_{9}=cx_{8}), cx_{6}=v_{6} }{R_{147}^-[@(R_{149}^-[cx_{4}],C_{146}^C[cx_{9}])]} }\\ \hline \xrightarrow{ eno,cpin}& \letrecmt{ E_{21}, CH_{1}(cx_{2}=cx_{6},cx_{4}=cx_{3}),}{CH_{6}(cx_{7}=cx_{6},cx_{9}=cx_{8}), cx_{6}=v_{6} }{R_{147}^-[@(R_{149}^-[v_{6}],C_{146}^C[cx_{9}])]} \\ \xrightarrow{ iS,cpin}& \letrecmt{ E_{21}, CH_{1}(cx_{2}=cx_{6},cx_{4}=cx_{3}),}{CH_{6}(cx_{7}=cx_{6},cx_{9}=cx_{8}), cx_{6}=v_{6} }{R_{147}^-[@(R_{149}^-[v_{6}],C_{146}^C[v_{6}])]} \\\hline \xrightarrow{ iS,cpin}& \letrecmt{ E_{21}, CH_{1}(cx_{2}=cx_{6},cx_{4}=cx_{3}),}{CH_{6}(cx_{7}=cx_{6},cx_{9}=cx_{8}), cx_{6}=v_{6} }{R_{147}^-[@(R_{149}^-[cx_{4}],C_{146}^C[v_{6}])]} \\ \xrightarrow{ eno,cpin}& \letrecmt{ E_{21}, CH_{1}(cx_{2}=cx_{6},cx_{4}=cx_{3})}{CH_{6}(cx_{7}=cx_{6},cx_{9}=cx_{8}), cx_{6}=v_{6} }{R_{147}^-[@(R_{149}^-[v_{6}],C_{146}^C[v_{6}])]} \\ \end{array}$   
\end{minipage}}

\framebox{\begin{minipage}{1\textwidth}
\fdiagrammA{\iscpin}{\enocpe}{\enocpe}{\iscpin} \\[0.2cm]
$\begin{array}{rl} \multicolumn{2}{l}{\letrecms{ E_{25},
      CH_{6}(cx_{7}=cx_{6},cx_{9}=cx_{8}),
      cx_{6}=v_{6},x_{1}=R_{2}^-[@(cx_{9},s_{2})]
    }{R_{162}^-[@(R_{164}^-[x_{1}],C_{161}^C[cx_{9}])]} }\\ \hline
  \xrightarrow{ eno,cpe.0}& \letrecms{ E_{25},
    CH_{6}(cx_{7}=cx_{6},cx_{9}=cx_{8}),
    cx_{6}=v_{6},x_{1}=R_{2}^-[@(v_{6},s_{2})]
  }{R_{162}^-[@(R_{164}^-[x_{1}],C_{161}^C[cx_{9}])]} \\ \xrightarrow{
    iS,cpin}& \letrecms{ E_{25}, CH_{6}(cx_{7}=cx_{6},cx_{9}=cx_{8}),
    cx_{6}=v_{6},x_{1}=R_{2}^-[@(v_{6},s_{2})]
  }{R_{162}^-[@(R_{164}^-[x_{1}],C_{161}^C[v_{6}])]} \\\hline
  \xrightarrow{ iS,cpin}& \letrecms{ E_{25},
    CH_{6}(cx_{7}=cx_{6},cx_{9}=cx_{8}),
    cx_{6}=v_{6},x_{1}=R_{2}^-[@(cx_{9},s_{2})]
  }{R_{162}^-[@(R_{164}^-[x_{1}],C_{161}^C[v_{6}])]} \\ \xrightarrow{
    eno,cpe.0}& \letrecms{ E_{25},
    CH_{6}(cx_{7}=cx_{6},cx_{9}=cx_{8}),
    cx_{6}=v_{6},x_{1}=R_{2}^-[@(v_{6},s_{2})]
  }{R_{162}^-[@(R_{164}^-[x_{1}],C_{161}^C[v_{6}])]} \\ \end{array}$  
\end{minipage}}


\framebox{\begin{minipage}{1\textwidth}
\fdiagrammA{\iscpin}{\enolbeta}{\enolbeta}{\iscpin} \\[0.2cm]
$\begin{array}[t]{rl} \multicolumn{2}{l}{\letrecm{ E_{6},
      CH_{6}(cx_{7}=cx_{6},cx_{9}=cx_{8}), cx_{6}=v_{6} }{@((\lambda
      x_{1} . C_{19}^C[cx_{9}]),r_{1})} }\\ \hline \xrightarrow{
    eno,lbeta2}& \letrecms{ E_{6}, CH_{6}(cx_{7}=cx_{6},cx_{9}=cx_{8}),
    cx_{6}=v_{6} }{\letrecm{   x_{1}=r_{1} }{C_{19}^C[cx_{9}]}} \\
  \xrightarrow{ iS,cpin}& \letrecms{ E_{6},
    CH_{6}(cx_{7}=cx_{6},cx_{9}=cx_{8}), cx_{6}=v_{6} }{\letrecm{
      x_{1}=r_{1} }{C_{19}^C[v_{6}]}} \\\hline \xrightarrow{ iS,cpin}&
  \letrecms{ E_{6}, CH_{6}(cx_{7}=cx_{6},cx_{9}=cx_{8}), cx_{6}=v_{6}
  }{@((\lambda x_{1} . C_{19}^C[v_{6}]),r_{1})} \\ \xrightarrow{
    eno,lbeta2}& \letrecms{ E_{6}, CH_{6}(cx_{7}=cx_{6},cx_{9}=cx_{8}),
    cx_{6}=v_{6} }{\letrecm{   x_{1}=r_{1} }{C_{19}^C[v_{6}]}} \\
\end{array}$ \end{minipage}} 

\framebox{\begin{minipage}{1\textwidth}
\fdiagrammA{\iscpin}{\enolapp}{\enolapp}{\iscpin}\\[0.2cm]
$\begin{array}[t]{rl} \multicolumn{2}{l}{R_{3}^-[@(\letrecm{ E_{6}, CH_{6}(cx_{7}=cx_{6},cx_{9}=cx_{8}), cx_{6}=v_{6} }{C_{6}^C[cx_{9}]},s_{1})] }\\ \hline \xrightarrow{ eno,lapp1}& R_{3}^-[\letrecm{ E_{6}, CH_{6}(cx_{7}=cx_{6},cx_{9}=cx_{8}), cx_{6}=v_{6} }{@(C_{6}^C[cx_{9}],s_{1})}] \\ \xrightarrow{ iS,cpin}& R_{3}^-[\letrecm{ E_{6}, CH_{6}(cx_{7}=cx_{6},cx_{9}=cx_{8}), cx_{6}=v_{6} }{@(C_{6}^C[v_{6}],s_{1})}] \\\hline \xrightarrow{ iS,cpin}& R_{3}^-[@(\letrecm{ E_{6}, CH_{6}(cx_{7}=cx_{6},cx_{9}=cx_{8}), cx_{6}=v_{6} }{C_{6}^C[v_{6}]},s_{1})] \\ \xrightarrow{ eno,lapp1}& R_{3}^-[\letrecm{ E_{6}, CH_{6}(cx_{7}=cx_{6},cx_{9}=cx_{8}), cx_{6}=v_{6} }{@(C_{6}^C[v_{6}],s_{1})}] \\ \end{array}$ 
\end{minipage}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% eno,a, is,cpe
\subsection{Vollständiger Satz von Gabeldiagrammen für (\emph{iS,cp-e})}
Das Programm berechnet 222 Gabeldiagramme für eine
$(iS,cp-e)$-Reduktion.
Wir geben die Diagramme an, die sich unterscheiden. 

\framebox{\begin{minipage}{1\textwidth}  
\fdiagrammA{\iscpe}{\enolletin}{\enolletin}{\iscpe}\\[0.2cm]
$\begin{array}[t]{rl} \multicolumn{2}{l}{\letrecms{ E_{7},
      CH_{7}(cy_{7}=cy_{6},cy_{9}=cy_{8}),
      cy_{6}=v_{7},y_{6}=C_{7}^C[cy_{9}] }{\letrecm{ E_{2} }{r_{1}}}
  }\\ \hline \xrightarrow{ eno,lletin}& \letrecm{ E_{7},E_{2},
    CH_{7}(cy_{7}=cy_{6},cy_{9}=cy_{8}),
    cy_{6}=v_{7},y_{6}=C_{7}^C[cy_{9}] }{r_{1}} \\ \xrightarrow{
    iS,cpe}& \letrecm{ E_{7},E_{2},
    CH_{7}(cy_{7}=cy_{6},cy_{9}=cy_{8}),
    cy_{6}=v_{7},y_{6}=C_{7}^C[v_{7}] }{r_{1}} \\\hline \xrightarrow{
    iS,cpe}& \letrecms{ E_{7}, CH_{7}(cy_{7}=cy_{6},cy_{9}=cy_{8}),
    cy_{6}=v_{7},y_{6}=C_{7}^C[v_{7}] }{\letrecm{ E_{2} }{r_{1}}} \\
  \xrightarrow{ eno,lletin}& \letrecm{ E_{7},E_{2},
    CH_{7}(cy_{7}=cy_{6},cy_{9}=cy_{8}),
    cy_{6}=v_{7},y_{6}=C_{7}^C[v_{7}] }{r_{1}} \\ \end{array}$  
\end{minipage}}

\framebox{\begin{minipage}{1\textwidth}  
\fdiagrammA{\iscpe}{\enollete}{\enollete}{\iscpe}\\[0.2cm]
$\begin{array}[t]{rl} \multicolumn{2}{l}{\letrecms{ E_{7},
      CH_{7}(cy_{7}=cy_{6},cy_{9}=cy_{8}),
      cy_{6}=v_{7},y_{6}=\letrecm{ E_{2} }{C_{17}^C[cy_{9}]}
    }{R_{1}^-[y_{6}]} }\\ \hline \xrightarrow{ eno,llete.0}& \letrecms{
    E_{7},E_{2}, CH_{7}(cy_{7}=cy_{6},cy_{9}=cy_{8}),
    cy_{6}=v_{7},y_{6}=C_{17}^C[cy_{9}] }{R_{1}^-[y_{6}]} \\
  \xrightarrow{ iS,cpe}& \letrecms{ E_{7},E_{2},
    CH_{7}(cy_{7}=cy_{6},cy_{9}=cy_{8}),
    cy_{6}=v_{7},y_{6}=C_{17}^C[v_{7}] }{R_{1}^-[y_{6}]} \\\hline
  \xrightarrow{ iS,cpe}& \letrecmt{ E_{7},
    CH_{7}(cy_{7}=cy_{6},cy_{9}=cy_{8}), cy_{6}=v_{7},}{y_{6}=\letrecm{
      E_{2} }{C_{17}^C[v_{7}]} }{R_{1}^-[y_{6}]} \\ \xrightarrow{
    eno,llete.0}& \letrecms{ E_{7},E_{2},
    CH_{7}(cy_{7}=cy_{6},cy_{9}=cy_{8}),
    cy_{6}=v_{7},y_{6}=C_{17}^C[v_{7}] }{R_{1}^-[y_{6}]} \\
\end{array}$  
\end{minipage}}

%\framebox{\begin{minipage}{1\textwidth}  $\begin{array}[t]{rl} \multicolumn{2}{l}{\letrecm{ E_{28}, CH_{1}(cx_{2}=cy_{6},cx_{4}=cx_{3}),CH_{7}(cy_{7}=cy_{6},cy_{9}=cy_{8}), cy_{6}=v_{7},y_{6}=C_{7}^C[cy_{9}] }{R_{1}^-[cx_{4}]} }\\ \hline \xrightarrow{ eno,cpin}& \letrecm{ E_{28}, CH_{1}(cx_{2}=cy_{6},cx_{4}=cx_{3}),CH_{7}(cy_{7}=cy_{6},cy_{9}=cy_{8}), cy_{6}=v_{7},y_{6}=C_{7}^C[cy_{9}] }{R_{1}^-[v_{7}]} \\ \xrightarrow{ is,cpe}& \letrecm{ E_{28}, CH_{1}(cx_{2}=cy_{6},cx_{4}=cx_{3}),CH_{7}(cy_{7}=cy_{6},cy_{9}=cy_{8}), cy_{6}=v_{7},y_{6}=C_{7}^C[v_{7}] }{R_{1}^-[v_{7}]} \\\hline \xrightarrow{ is,cpe}& \letrecm{ E_{28}, CH_{1}(cx_{2}=cy_{6},cx_{4}=cx_{3}),CH_{7}(cy_{7}=cy_{6},cy_{9}=cy_{8}), cy_{6}=v_{7},y_{6}=C_{7}^C[v_{7}] }{R_{1}^-[cx_{4}]} \\ \xrightarrow{ eno,cpin}& \letrecm{ E_{28}, CH_{1}(cx_{2}=cy_{6},cx_{4}=cx_{3}),CH_{7}(cy_{7}=cy_{6},cy_{9}=cy_{8}), cy_{6}=v_{7},y_{6}=C_{7}^C[v_{7}] }{R_{1}^-[v_{7}]} \\ \end{array}$ 
%\fdiagrammA{\iscpe}{\enocpe}{\enocpe}{\iscpe}
%\end{minipage}
 
\framebox{\begin{minipage}{1\textwidth}  
\fdiagrammA{\iscpe}{\enocpin}{\enocpin}{\iscpe}\\[0.2cm]
$\begin{array}{rl} \multicolumn{2}{l}{\letrecm{ E_{235},
      CH_{18}(cx_{2}=cy_{6},(cx_{4}=cx_{3}),cx_{3}=cx_{21}),
      cy_{6}=v_{7} }{R_{1}^-[cx_{4}]} }\\ \hline \xrightarrow{
    eno,cpin}& \letrecms{ E_{235},
    CH_{18}(cx_{2}=cy_{6},(cx_{4}=cx_{3}),cx_{3}=cx_{21}),
    cy_{6}=v_{7} }{R_{1}^-[v_{7}]} \\ \xrightarrow{ iS,cpe}& \letrecm{
    E_{235}, CH_{18}(cx_{2}=cy_{6},cx_{3}=cx_{21}),
    cx_{4}=v_{7},cy_{6}=v_{7} }{R_{1}^-[v_{7}]} \\\hline \xrightarrow{
    iS,cpe}& \letrecm{ E_{235}, CH_{18}(cx_{2}=cy_{6},cx_{3}=cx_{21}),
    cx_{4}=v_{7},cy_{6}=v_{7} }{R_{1}^-[cx_{4}]} \\ \xrightarrow{
    eno,cpin}& \letrecm{ E_{235},
    CH_{18}(cx_{2}=cy_{6},cx_{3}=cx_{21}),, cx_{4}=v_{7},cy_{6}=v_{7}
  }{R_{1}^-[v_{7}]} \\ \end{array}$  
\end{minipage}}

\framebox{\begin{minipage}{1\textwidth}  
\fdiagrammA{\iscpe}{\enocpe}{\enocpe}{\iscpe}\\[0.2cm]
$\begin{array}{rl} \multicolumn{2}{l}{\letrecmt{ E_{897},
      CH_{680}(cy_{2}=cy_{6},(cy_{4}=cy_{3}),cy_{3}=cy_{683}),}{
      cy_{6}=v_{7},x_{1}=R_{2}^-[@(cy_{4},s_{2})] }{R_{1}^-[x_{1}]}
  }\\ \hline \xrightarrow{ eno,cpe.0}& \letrecmt{ E_{897},
    CH_{680}(cy_{2}=cy_{6},(cy_{4}=cy_{3}),cy_{3}=cy_{683}),}{
    cy_{6}=v_{7},x_{1}=R_{2}^-[@(v_{7},s_{2})] }{R_{1}^-[x_{1}]} \\
  \xrightarrow{ iS,cpe}& \letrecmt{ E_{897},
    CH_{680}(cy_{2}=cy_{6},cy_{3}=cy_{683}),}{
    cy_{4}=v_{7},cy_{6}=v_{7},x_{1}=R_{2}^-[@(v_{7},s_{2})]
  }{R_{1}^-[x_{1}]} \\\hline \xrightarrow{ iS,cpe}& \letrecmt{ E_{897},
    CH_{680}(cy_{2}=cy_{6},cy_{3}=cy_{683}),}{
    cy_{4}=v_{7},cy_{6}=v_{7},x_{1}=R_{2}^-[@(cy_{4},s_{2})]
  }{R_{1}^-[x_{1}]} \\ \xrightarrow{ eno,cpe.0}& \letrecmt{ E_{897},
    CH_{680}(cy_{2}=cy_{6},cy_{3}=cy_{683}),}{
    cy_{4}=v_{7},cy_{6}=v_{7},x_{1}=R_{2}^-[@(v_{7},s_{2})]
  }{R_{1}^-[x_{1}]} \\ \end{array}$  
\end{minipage}}


\framebox{\begin{minipage}{1\textwidth}  
\fdiagrammB{\iscpe}{\enocpin}{\enocpin}{\iscpin}{\iscpe}\\[0.2cm]
$\begin{array}[t]{rl} \multicolumn{2}{l}{\letrecmt{ E_{630},
      CH_{1}(cx_{2}=y_{6},cx_{4}=cx_{3}),CH_{7}(cy_{7}=cy_{6},cy_{9}=cy_{8}),}{cy_{6}=v_{7},y_{6}=(\lambda x_{618} . C_{617}^C[cy_{9}]) }{R_{1}^-[cx_{4}]} }\\ \hline \xrightarrow{ eno,cpin}& \letrecmt{ E_{630}, CH_{1}(cx_{2}=y_{6},cx_{4}=cx_{3}),CH_{7}(cy_{7}=cy_{6},cy_{9}=cy_{8}),}{ cy_{6}=v_{7},y_{6}=(\lambda x_{618} . C_{617}^C[cy_{9}]) }{R_{1}^-[(\lambda x_{618} . C_{617}^C[cy_{9}])]} \\ \xrightarrow{ iS,cpin}& \letrecmt{ E_{630}, CH_{1}(cx_{2}=y_{6},cx_{4}=cx_{3}),CH_{7}(cy_{7}=cy_{6},cy_{9}=cy_{8}),}{ cy_{6}=v_{7},y_{6}=(\lambda x_{618} . C_{617}^C[cy_{9}]) }{R_{1}^-[(\lambda x_{618} . C_{617}^C[v_{7}])]} \\ \xrightarrow{ iS,cpe}& \letrecmt{ E_{630}, CH_{1}(cx_{2}=y_{6},cx_{4}=cx_{3}),CH_{7}(cy_{7}=cy_{6},cy_{9}=cy_{8}),}{ cy_{6}=v_{7},y_{6}=(\lambda x_{618} . C_{617}^C[v_{7}]) }{R_{1}^-[(\lambda x_{618} . C_{617}^C[v_{7}])]} \\\hline \xrightarrow{ iS,cpe}& \letrecmt{ E_{630}, CH_{1}(cx_{2}=y_{6},cx_{4}=cx_{3}),CH_{7}(cy_{7}=cy_{6},cy_{9}=cy_{8}),}{ cy_{6}=v_{7},y_{6}=(\lambda x_{618} . C_{617}^C[v_{7}]) }{R_{1}^-[cx_{4}]} \\ \xrightarrow{ eno,cpin}& \letrecmt{ E_{630}, CH_{1}(cx_{2}=y_{6},cx_{4}=cx_{3}),CH_{7}(cy_{7}=cy_{6},cy_{9}=cy_{8}),}{ cy_{6}=v_{7},y_{6}=(\lambda x_{618} . C_{617}^C[v_{7}]) }{R_{1}^-[(\lambda x_{618} . C_{617}^C[v_{7}])]} \\ \end{array}$  
\end{minipage}}


\framebox{\begin{minipage}{1\textwidth}  
\fdiagrammB{\iscpe}{\enocpe}{\enocpe}{\iscpe}{\iscpe}\\[0.2cm]
$\begin{array}[t]{rl} \multicolumn{2}{l}{\letrecmt{ E_{1301},
      CH_{2}(cy_{2}=y_{6},cy_{4}=cy_{3}),CH_{7}(cy_{7}=cy_{6},cy_{9}=cy_{8}),}{ cy_{6}=v_{7},x_{1}=R_{2}^-[@(cy_{4},s_{2})],y_{6}=(\lambda x_{1280} . C_{1279}^C[cy_{9}]) }{R_{1}^-[x_{1}]} }\\ \hline \xrightarrow{ eno,cpe.0}& \letrecmt{ E_{1301}, CH_{2}(cy_{2}=y_{6},cy_{4}=cy_{3}),CH_{7}(cy_{7}=cy_{6},cy_{9}=cy_{8}),}{ cy_{6}=v_{7},x_{1}=R_{2}^-[@((\lambda x_{1280} . C_{1279}^C[cy_{9}]),s_{2})],y_{6}=(\lambda x_{1280} . C_{1279}^C[cy_{9}]) }{R_{1}^-[x_{1}]} \\ \xrightarrow{ iS,cpe}& \letrecmt{ E_{1301}, CH_{2}(cy_{2}=y_{6},cy_{4}=cy_{3}),CH_{7}(cy_{7}=cy_{6},cy_{9}=cy_{8}),}{ cy_{6}=v_{7},x_{1}=R_{2}^-[@((\lambda x_{1280} . C_{1279}^C[v_{7}]),s_{2})],y_{6}=(\lambda x_{1280} . C_{1279}^C[cy_{9}]) }{R_{1}^-[x_{1}]} \\ \xrightarrow{ iS,cpe}& \letrecmt{ E_{1301}, CH_{2}(cy_{2}=y_{6},cy_{4}=cy_{3}),CH_{7}(cy_{7}=cy_{6},cy_{9}=cy_{8}),}{ cy_{6}=v_{7},x_{1}=R_{2}^-[@((\lambda x_{1280} . C_{1279}^C[v_{7}]),s_{2})],y_{6}=(\lambda x_{1280} . C_{1279}^C[v_{7}]) }{R_{1}^-[x_{1}]} \\\hline \xrightarrow{ iS,cpe}& \letrecmt{ E_{1301}, CH_{2}(cy_{2}=y_{6},cy_{4}=cy_{3}),CH_{7}(cy_{7}=cy_{6},cy_{9}=cy_{8}),}{ cy_{6}=v_{7},x_{1}=R_{2}^-[@(cy_{4},s_{2})],y_{6}=(\lambda x_{1280} . C_{1279}^C[v_{7}]) }{R_{1}^-[x_{1}]} \\ \xrightarrow{ eno,cpe.0}& \letrecmt{ E_{1301}, CH_{2}(cy_{2}=y_{6},cy_{4}=cy_{3}),CH_{7}(cy_{7}=cy_{6},cy_{9}=cy_{8}),}{ cy_{6}=v_{7},x_{1}=R_{2}^-[@((\lambda x_{1280} . C_{1279}^C[v_{7}]),s_{2})],y_{6}=(\lambda x_{1280} . C_{1279}^C[v_{7}]) }{R_{1}^-[x_{1}]} \\ \end{array}$  
\end{minipage}}

\framebox{\begin{minipage}{1\textwidth}  
\fdiagrammA{\iscpe}{\enolbeta}{\enolbeta}{\iscpe}\\[0.2cm]
$\begin{array}[t]{rl} \multicolumn{2}{l}{\letrecms{ E_{7},
      CH_{7}(cy_{7}=cy_{6},cy_{9}=cy_{8}),
      cy_{6}=v_{7},y_{6}=@((\lambda y_{27} . C_{28}^C[cy_{9}]),r_{1})
    }{R_{3}^-[y_{6}]} }\\ \hline \xrightarrow{ eno,lbeta3.0}&
  \letrecmt{ E_{7}, CH_{7}(cy_{7}=cy_{6},cy_{9}=cy_{8}),
    cy_{6}=v_{7},}{y_{6}=\letrecm{   y_{6}=r_{1} }{C_{28}^C[cy_{9}]}
  }{R_{3}^-[y_{6}]} \\ \xrightarrow{ iS,cpe}& \letrecmt{ E_{7},
    CH_{7}(cy_{7}=cy_{6},cy_{9}=cy_{8}), cy_{6}=v_{7},}{y_{6}=\letrecm{
      y_{6}=r_{1} }{C_{28}^C[v_{7}]} }{R_{3}^-[y_{6}]} \\\hline
  \xrightarrow{ iS,cpe}& \letrecmt{ E_{7},
    CH_{7}(cy_{7}=cy_{6},cy_{9}=cy_{8}), cy_{6}=v_{7},}{y_{6}=@((\lambda
    y_{27} . C_{28}^C[v_{7}]),r_{1}) }{R_{3}^-[y_{6}]} \\
  \xrightarrow{ eno,lbeta3.0}& \letrecmt{ E_{7},
    CH_{7}(cy_{7}=cy_{6},cy_{9}=cy_{8}), cy_{6}=v_{7},}{y_{6}=\letrecm{
      y_{6}=r_{1} }{C_{28}^C[v_{7}]} }{R_{3}^-[y_{6}]} \\ \end{array}$  
\end{minipage}}

\framebox{\begin{minipage}{1\textwidth}  
\fdiagrammA{\iscpe}{\enolapp}{\enolapp}{\iscpe}\\[0.2cm]
$\begin{array}[t]{rl} \multicolumn{2}{l}{R_{3}^-[@(\letrecm{ E_{7},
	CH_{7}(cy_{7}=cy_{6},cy_{9}=cy_{8}),
	cy_{6}=v_{7},y_{6}=C_{7}^C[cy_{9}] }{r_{6}},s_{1})] }\\ \hline
  \xrightarrow{ eno,lapp1}& R_{3}^-[\letrecms{ E_{7},
      CH_{7}(cy_{7}=cy_{6},cy_{9}=cy_{8}),
      cy_{6}=v_{7},y_{6}=C_{7}^C[cy_{9}] }{@(r_{6},s_{1})}] \\
  \xrightarrow{ iS,cpe}& R_{3}^-[\letrecms{ E_{7},
      CH_{7}(cy_{7}=cy_{6},cy_{9}=cy_{8}),
      cy_{6}=v_{7},y_{6}=C_{7}^C[v_{7}] }{@(r_{6},s_{1})}] \\\hline 
  \xrightarrow{ iS,cpe}& R_{3}^-[@(\letrecms{ E_{7},
      CH_{7}(cy_{7}=cy_{6},cy_{9}=cy_{8}),
      cy_{6}=v_{7},y_{6}=C_{7}^C[v_{7}] }{r_{6}},s_{1})] \\
  \xrightarrow{ eno,lapp1}& R_{3}^-[\letrecms{ E_{7},
      CH_{7}(cy_{7}=cy_{6},cy_{9}=cy_{8}),
      cy_{6}=v_{7},y_{6}=C_{7}^C[v_{7}] }{@(r_{6},s_{1})}] \\
\end{array}$  
\end{minipage}}

Durch die Zusammenfassung der einzelnen Diagramme ergibt sich der berechnete
vollständige Satz von Gabeldiagrammen für $(iS,cp)$:

%\Ovalbox
\[\xymatrix@R=1.5cm@C=1.5cm{%Vierecke
\cdot \ar@{->}[rr]^{\mathbf{iS,cp}} \ar@{->}[d]_{\mathbf{eno,a}} & & \cdot \ar@{.>}[d]^{\mathbf{eno,a}} \\
\cdot \ar@{.>}[rr]^{\mathbf{iS,cp}}                                  & & \cdot
}\quad
%\Ovalbox
\xymatrix@R=1.5cm@C=1.5cm{%Vierecke
\cdot \ar@{->}[rr]^{\mathbf{iS,cp}} \ar@{->}[d]_{\mathbf{eno,cp}} & & \cdot \ar@{.>}[d]^{\mathbf{eno,cp}} \\
\cdot \ar@{.>}[r]^{\mathbf{iS,cp}}                                   & \cdot \ar@{.>}[r]^{\mathbf{iS,cp}}  & \cdot
}\]

\chapter{Zusammenfassung und Ausblick}
\label{cha:zusamm-und-ausbl}
\section{Zusammenfassung}
In dieser Arbeit wird ein einfacher $\lambda$-Kalkül mit einem 
\letr-Konstrukt betrachtet, der auf einer 
Teilmenge des $LR$-Kalküls aus \citeA{schmidt-schauss_safety_2007}
basiert. Der verwendete Kalkül wird als $\Lambda^{let}$-Kalkül
bezeichnet und besteht aus einer Sprache $L_{\Lambda^{let}}$, deren
Elemente Ausdrücke sind, aus Reduktionsregeln, die Ausdrücke
transformieren und einer standardisierten Form der Auswertung, der
Normalordnung. Der Kalkül wird in Kapitel \ref{cha:der-lambdalet-kalkul} definiert. 
In diesem Kapitel wird außerdem 
das zentrale semantische Konzept des Kalküls, die kontextuelle
Gleichheit von Ausdrücken und darauf aufbauend die Korrektheit von
Programmtransformationen definiert. Als wesentliches Hilfsmittel zum
Beweis der Korrektheit von Programmtransformationen dienen
vollständige Sätze von Gabel- und Vertauschungsdiagrammen. 

Das Ziel dieser Arbeit ist es, eine Methode zu entwickeln, mit der
vollständige Sätze von Gabeldiagrammen für den  
$\Lambda^{let}$-Kalkül berechnet werden können. 
Die Methode basiert auf der Berechnung von Überlappungen von 
Reduktionsregeln, wozu Reduktionsregeln des $\Lambda^{let}$-Kalküls
unifiziert werden müssen. 

Der Hauptteil der Arbeit (Kapitel \ref{cha:unif-fur-terme-mit-sorten},
\ref{cha:ac-unifikation}, \ref{cha:unif-von-ketten} und \ref{cha:unif-von-kontexten}) befasst sich mit den
Unifikationsmethoden, die zur Unifikation von verschiedenen  
Konstrukten, die in $\Lambda^{let}$-Reduktionsregeln enthalten sind,
benötigt werden.
Im Verlauf der vier Kapitel wird sukzessiv eine Signatur
$\sigmaLet$ definiert, mit deren Hilfe Konstrukte, die in
$\Lambda^{let}$-Reduktionsregeln vorkommen, als Terme über der
Signatur $\sigmaLet$ dargestellt und unifiziert werden können. 

Die Reduktionsregeln in $\Lambda^{let}$ enthalten Variablen
verschiedener Sorten. In Kapitel \ref{cha:unif-fur-terme-mit-sorten}
werden Terme mit Sorten definiert 
%und die Signatur $\sigmaLet$ eingeführt, über der Terme erster Ordnung 
und das Verfahren 
zur Unifikation von Termen mit Sorten beschrieben, 
das auf der Arbeit von \cite{schmidt-schauss_computational_1989} basiert. 
Es wird gezeigt, dass der Unifikationsalgorithmus terminiert und 
vollständig ist. 
%und die vollständige Menge der Unifikatoren für alle
%Unifikationsprobleme, die zur Berechnung von Überlappunge gelöster
%werden müssen, eine Kardinalität von 1 hat. 

Kapitel \ref{cha:ac-unifikation} befasst sich mit der Unifikation von
Funktionssymbolen, deren Argumente vertauschbar sind. 
Diese Unifikationsmethode wird benötigt, da die Elemente von
\letr-Umgebungen in $\Lambda^{let}$ vertauschbar sind und diese
Vertauschbarkeit bei der Unifikation berücksichtigt werden muss. 
Es wird ein Unifikationsalgorithmus aus der Theorie der
Unifikation von Mengen \cite{dovier_uniform_2000} vorgestellt, der terminiert 
und vollständig ist.

\letr-Umgebungen in $\Lambda^{let}$-Reduktionsregeln enthalten in
manchen Fällen ein Konstrukt, um Variablenketten beliebiger Länge
darzustellen. Die Methoden, die zur Unifikation von Variablenketten
verwendet werden, sind in Kapitel \ref{cha:unif-von-ketten} beschrieben.  
%Überlegungen zur Terminierung der Unifikationsprozedur in den Fällen,
%die zur Berechnung von Überlappungen relevant sind, werden 

Als letztes Konstrukt, das es bei der Unifikation zu berücksichtigen
gilt, enthalten $\Lambda^{let}$-Reduktionsregeln Kontextvariablen mit
Sorten. Deren Unifikation erfolgt wie in 
Kapitel \ref{cha:unif-von-kontexten} dargelegt. Dabei orientieren wir uns hauptsächlich
an der Arbeit von \cite{comon_completion_1998-1} und skizzieren dessen Überlegungen
zur Vollständigkeit und Terminierung der Unifikationsprozedur.  

In Kapitel \ref{cha:berechn-von-uberl} wird der Begriff der Überlappung von Reduktionsregeln
formal definiert. Dazu fassen wir zuerst die Definition der Signatur
$\sigmaLet$, die zur Darstellung und Unifikation von
$\Lambda^{let}$-Reduktionsregeln verwendet wird, zusammen. 
Dann werden Reduktionsregeln für Terme über dieser
Signatur und eine standardisierte Form der Auswertung, analog zu den
entsprechenden Definitionen des $\Lambda^{let}$-Kalküls definiert. 
Die in $\sigmaLet$ definierte Normalordnungsreduktion stellt eine
Einschränkung der Normalordnungsreduktion aus $\Lambda^{let}$ dar.
Abschließend beschreiben wir, wie alle Überlappungen für einen 
vollständigen Satz von Gabeldiagrammen berechnet werden können. 

Das abschließende Kapitel \ref{cha:impl-und-ergebn} befasst sich mit
der Implementierung, die im Rahmen dieser Arbeit entstanden ist. 
Sie berechnet vollständige Sätze von Gabeldiagrammen. 
Wir skizzieren einige Datenstrukturen des Programms und geben 
Beispiele für die Arbeitsweise der wichtigsten Funktionen.
Anschließend geben wir die vollständigen Sätze von Gabeldiagrammen
an, die das Programm berechnet. 

\section{Ausblick}
Abschließend zeigen wir einige Erweiterungen und Verbesserungen auf, die durch
zukünftige Forschung erreicht werden könnten.

\subsection{Anpassung der Implementierung an die Unifikationstheorien}
Wie wir in Kapitel \ref{cha:impl-und-ergebn} zu Beginn dargelegt haben,
entspricht die Implementierung, die im Rahmen der Arbeit entstanden
ist nicht in allen Aspekten den vorgestellten Unifikationstheorien. 
Um eine höhere Sicherheit bezüglich der Terminierung und
der Vollständigkeit des programmierten Unifikationsalgorithmus zu
erhalten, ist eine Anpassung des Programms an die Unifikationstheorien
notwendig. Dazu ist das Programm so zu verändern, dass anstatt
Ausdrücken mit Metavariablen Terme mit Sorten zur Unifikation
verwendet werden. Außerdem sind die einzelnen Unifikationsregeln des
Programms so abzuändern, dass sie den Regeln der Theorien
entsprechen. 

Das Programm kann auch noch an verschieden anderen Stellen erweiterte
werden. Beispielsweise um ein Modul, das es erlaubt eine Menge von
Gabeldiagrammen einzugeben. Anhand der Berechnung aller Überlappungen
kann dann getestet werden, ob die eingegebene Menge von Diagrammen
vollständig ist. 
Eine weitere, wünschenswerte Funktion ist die Berechnung einer
vollständigen Menge von Vertauschungsdiagrammen. 
\subsection{Offene Fragen zur Unifikation von Termen mit Variablenketten} 
Die Behandlung der Unifikation von Termen mit Variablenketten in
Kapitel \ref{cha:unif-von-ketten} ist eher informell. An vielen Stellen, an den
eigentlich Beweise von Aussagen nötig sind, werden lediglich
Beispiele gegeben. Insbesondere die Vollständigkeit der
Unifikationsprozedur wird nicht ausführlich untersucht. 
Hierzu sind weitere Untersuchungen notwendig. 
%Der Grund dafür liegt darin, dass vermutet wird, dass die 
%Theorie der Variablenketten \emph{Split} einen unendlichen
%Unifikationstyp hat,  

\subsection{Berechnung von Diagrammen für andere Kalküle}
Die Berechnung von Gabeldiagrammen erfolgt in dieser Arbeit für 
den einfachen $\Lambda^{let}$-Kalkül, der über die Konstrukte 
Applikation, Abstraktion und \letr ~ verfügt. 
In der Literatur zur Korrektheit von Programmtransformationen
existieren eine Vielzahl von Kalkülen, die über einen größeren
Sprachumfang verfügen 
\cite{schmidt-schauss_fundio:lambda-calculus_2003,schmidt-schauss_safety_2007,sabel_semantics_2008}.
Des weiteren gibt es Kalküle, in denen die Normalordnungsreduktion in 
einer anderen Form als in $\Lambda^{let}$ definiert wird
\cite{schmidt-schauss_correctness_2007}.
Für diese Kalküle ist es interessant zu untersuchen, ob sich die
hier vorgestellten Methoden verwenden lassen, um für sie vollständige
Sätze von Gabeldiagrammen zu berechnen. 


\bibliography{Library}

\end{document}
